/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.1.6 (2020-01-28)
 */
(function(domGlobals) {
    const noop = function() {};
    const noarg = function(f) {
        return function() {
            return f();
        };
    };
    const compose = function(fa, fb) {
        return function() {
            const args = [];
            for (let _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return fa(fb.apply(null, args));
        };
    };
    const constant = function(value) {
        return function() {
            return value;
        };
    };
    const identity = function(x) {
        return x;
    };
    function curry(fn) {
        const initialArgs = [];
        for (let _i = 1; _i < arguments.length; _i++) {
            initialArgs[_i - 1] = arguments[_i];
        }
        return function() {
            const restArgs = [];
            for (let _i = 0; _i < arguments.length; _i++) {
                restArgs[_i] = arguments[_i];
            }
            const all = initialArgs.concat(restArgs);
            return fn.apply(null, all);
        };
    }
    const not = function(f) {
        return function() {
            const args = [];
            for (let _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return !f.apply(null, args);
        };
    };
    const die = function(msg) {
        return function() {
            throw new Error(msg);
        };
    };
    const never = constant(false);
    const always = constant(true);

    const global$1 = tinymce.util.Tools.resolve('tinymce.ThemeManager');

    var __assign = function() {
        __assign =
            Object.assign ||
            function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (const p in s)
                        if (Object.prototype.hasOwnProperty.call(s, p))
                            t[p] = s[p];
                }
                return t;
            };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        const t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === 'function')
            for (
                var i = 0, p = Object.getOwnPropertySymbols(s);
                i < p.length;
                i++
            ) {
                if (
                    e.indexOf(p[i]) < 0 &&
                    Object.prototype.propertyIsEnumerable.call(s, p[i])
                )
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (let a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    const none = function() {
        return NONE;
    };
    var NONE = (function() {
        const eq = function(o) {
            return o.isNone();
        };
        const call = function(thunk) {
            return thunk();
        };
        const id = function(n) {
            return n;
        };
        const me = {
            fold(n, s) {
                return n();
            },
            is: never,
            isSome: never,
            isNone: always,
            getOr: id,
            getOrThunk: call,
            getOrDie(msg) {
                throw new Error(msg || 'error: getOrDie called on none.');
            },
            getOrNull: constant(null),
            getOrUndefined: constant(undefined),
            or: id,
            orThunk: call,
            map: none,
            each: noop,
            bind: none,
            exists: never,
            forall: always,
            filter: none,
            equals: eq,
            equals_: eq,
            toArray() {
                return [];
            },
            toString: constant('none()'),
        };
        if (Object.freeze) {
            Object.freeze(me);
        }
        return me;
    })();
    var some = function(a) {
        const constant_a = constant(a);
        const self = function() {
            return me;
        };
        const bind = function(f) {
            return f(a);
        };
        var me = {
            fold(n, s) {
                return s(a);
            },
            is(v) {
                return a === v;
            },
            isSome: always,
            isNone: never,
            getOr: constant_a,
            getOrThunk: constant_a,
            getOrDie: constant_a,
            getOrNull: constant_a,
            getOrUndefined: constant_a,
            or: self,
            orThunk: self,
            map(f) {
                return some(f(a));
            },
            each(f) {
                f(a);
            },
            bind,
            exists: bind,
            forall: bind,
            filter(f) {
                return f(a) ? me : NONE;
            },
            toArray() {
                return [a];
            },
            toString() {
                return `some(${a})`;
            },
            equals(o) {
                return o.is(a);
            },
            equals_(o, elementEq) {
                return o.fold(never, function(b) {
                    return elementEq(a, b);
                });
            },
        };
        return me;
    };
    const from = function(value) {
        return value === null || value === undefined ? NONE : some(value);
    };
    const Option = {
        some,
        none,
        from,
    };

    var value = function(o) {
        const is = function(v) {
            return o === v;
        };
        const or = function(opt) {
            return value(o);
        };
        const orThunk = function(f) {
            return value(o);
        };
        const map = function(f) {
            return value(f(o));
        };
        const mapError = function(f) {
            return value(o);
        };
        const each = function(f) {
            f(o);
        };
        const bind = function(f) {
            return f(o);
        };
        const fold = function(_, onValue) {
            return onValue(o);
        };
        const exists = function(f) {
            return f(o);
        };
        const forall = function(f) {
            return f(o);
        };
        const toOption = function() {
            return Option.some(o);
        };
        return {
            is,
            isValue: always,
            isError: never,
            getOr: constant(o),
            getOrThunk: constant(o),
            getOrDie: constant(o),
            or,
            orThunk,
            fold,
            map,
            mapError,
            each,
            bind,
            exists,
            forall,
            toOption,
        };
    };
    var error = function(message) {
        const getOrThunk = function(f) {
            return f();
        };
        const getOrDie = function() {
            return die(String(message))();
        };
        const or = function(opt) {
            return opt;
        };
        const orThunk = function(f) {
            return f();
        };
        const map = function(f) {
            return error(message);
        };
        const mapError = function(f) {
            return error(f(message));
        };
        const bind = function(f) {
            return error(message);
        };
        const fold = function(onError, _) {
            return onError(message);
        };
        return {
            is: never,
            isValue: never,
            isError: always,
            getOr: identity,
            getOrThunk,
            getOrDie,
            or,
            orThunk,
            fold,
            map,
            mapError,
            each: noop,
            bind,
            exists: never,
            forall: always,
            toOption: Option.none,
        };
    };
    const fromOption = function(opt, err) {
        return opt.fold(function() {
            return error(err);
        }, value);
    };
    const Result = {
        value,
        error,
        fromOption,
    };

    const typeOf = function(x) {
        if (x === null) {
            return 'null';
        }
        const t = typeof x;
        if (
            t === 'object' &&
            (Array.prototype.isPrototypeOf(x) ||
                (x.constructor && x.constructor.name === 'Array'))
        ) {
            return 'array';
        }
        if (
            t === 'object' &&
            (String.prototype.isPrototypeOf(x) ||
                (x.constructor && x.constructor.name === 'String'))
        ) {
            return 'string';
        }
        return t;
    };
    const isType = function(type) {
        return function(value) {
            return typeOf(value) === type;
        };
    };
    const isString = isType('string');
    const isObject = isType('object');
    const isArray = isType('array');
    const isBoolean = isType('boolean');
    const isFunction = isType('function');
    const isNumber = isType('number');
    const isArrayOf = function(value, pred) {
        if (isArray(value)) {
            for (let i = 0, len = value.length; i < len; ++i) {
                if (pred(value[i]) !== true) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };

    const nativeSlice = Array.prototype.slice;
    const nativeIndexOf = Array.prototype.indexOf;
    const nativePush = Array.prototype.push;
    const rawIndexOf = function(ts, t) {
        return nativeIndexOf.call(ts, t);
    };
    const indexOf = function(xs, x) {
        const r = rawIndexOf(xs, x);
        return r === -1 ? Option.none() : Option.some(r);
    };
    const contains = function(xs, x) {
        return rawIndexOf(xs, x) > -1;
    };
    const exists = function(xs, pred) {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                return true;
            }
        }
        return false;
    };
    const range = function(num, f) {
        const r = [];
        for (let i = 0; i < num; i++) {
            r.push(f(i));
        }
        return r;
    };
    const chunk = function(array, size) {
        const r = [];
        for (let i = 0; i < array.length; i += size) {
            const s = nativeSlice.call(array, i, i + size);
            r.push(s);
        }
        return r;
    };
    const map = function(xs, f) {
        const len = xs.length;
        const r = new Array(len);
        for (let i = 0; i < len; i++) {
            const x = xs[i];
            r[i] = f(x, i);
        }
        return r;
    };
    const each = function(xs, f) {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            f(x, i);
        }
    };
    const eachr = function(xs, f) {
        for (let i = xs.length - 1; i >= 0; i--) {
            const x = xs[i];
            f(x, i);
        }
    };
    const partition = function(xs, pred) {
        const pass = [];
        const fail = [];
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            const arr = pred(x, i) ? pass : fail;
            arr.push(x);
        }
        return {
            pass,
            fail,
        };
    };
    const filter = function(xs, pred) {
        const r = [];
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                r.push(x);
            }
        }
        return r;
    };
    const foldr = function(xs, f, acc) {
        eachr(xs, function(x) {
            acc = f(acc, x);
        });
        return acc;
    };
    const foldl = function(xs, f, acc) {
        each(xs, function(x) {
            acc = f(acc, x);
        });
        return acc;
    };
    const find = function(xs, pred) {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                return Option.some(x);
            }
        }
        return Option.none();
    };
    const findIndex = function(xs, pred) {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                return Option.some(i);
            }
        }
        return Option.none();
    };
    const flatten = function(xs) {
        const r = [];
        for (let i = 0, len = xs.length; i < len; ++i) {
            if (!isArray(xs[i])) {
                throw new Error(
                    `Arr.flatten item ${i} was not an array, input: ${xs}`,
                );
            }
            nativePush.apply(r, xs[i]);
        }
        return r;
    };
    const bind = function(xs, f) {
        const output = map(xs, f);
        return flatten(output);
    };
    const forall = function(xs, pred) {
        for (let i = 0, len = xs.length; i < len; ++i) {
            const x = xs[i];
            if (pred(x, i) !== true) {
                return false;
            }
        }
        return true;
    };
    const reverse = function(xs) {
        const r = nativeSlice.call(xs, 0);
        r.reverse();
        return r;
    };
    const difference = function(a1, a2) {
        return filter(a1, function(x) {
            return !contains(a2, x);
        });
    };
    const pure = function(x) {
        return [x];
    };
    const sort = function(xs, comparator) {
        const copy = nativeSlice.call(xs, 0);
        copy.sort(comparator);
        return copy;
    };
    const head = function(xs) {
        return xs.length === 0 ? Option.none() : Option.some(xs[0]);
    };
    const last = function(xs) {
        return xs.length === 0 ? Option.none() : Option.some(xs[xs.length - 1]);
    };
    const from$1 = isFunction(Array.from)
        ? Array.from
        : function(x) {
              return nativeSlice.call(x);
          };

    const { keys } = Object;
    const { hasOwnProperty } = Object;
    const each$1 = function(obj, f) {
        const props = keys(obj);
        for (let k = 0, len = props.length; k < len; k++) {
            const i = props[k];
            const x = obj[i];
            f(x, i);
        }
    };
    const map$1 = function(obj, f) {
        return tupleMap(obj, function(x, i) {
            return {
                k: i,
                v: f(x, i),
            };
        });
    };
    var tupleMap = function(obj, f) {
        const r = {};
        each$1(obj, function(x, i) {
            const tuple = f(x, i);
            r[tuple.k] = tuple.v;
        });
        return r;
    };
    const mapToArray = function(obj, f) {
        const r = [];
        each$1(obj, function(value, name) {
            r.push(f(value, name));
        });
        return r;
    };
    const find$1 = function(obj, pred) {
        const props = keys(obj);
        for (let k = 0, len = props.length; k < len; k++) {
            const i = props[k];
            const x = obj[i];
            if (pred(x, i, obj)) {
                return Option.some(x);
            }
        }
        return Option.none();
    };
    const values = function(obj) {
        return mapToArray(obj, function(v) {
            return v;
        });
    };
    const get = function(obj, key) {
        return has(obj, key) ? Option.from(obj[key]) : Option.none();
    };
    var has = function(obj, key) {
        return hasOwnProperty.call(obj, key);
    };

    const generate = function(cases) {
        if (!isArray(cases)) {
            throw new Error('cases must be an array');
        }
        if (cases.length === 0) {
            throw new Error('there must be at least one case');
        }
        const constructors = [];
        const adt = {};
        each(cases, function(acase, count) {
            const keys$1 = keys(acase);
            if (keys$1.length !== 1) {
                throw new Error('one and only one name per case');
            }
            const key = keys$1[0];
            const value = acase[key];
            if (adt[key] !== undefined) {
                throw new Error(`duplicate key detected:${key}`);
            } else if (key === 'cata') {
                throw new Error('cannot have a case named cata (sorry)');
            } else if (!isArray(value)) {
                throw new Error('case arguments must be an array');
            }
            constructors.push(key);
            adt[key] = function() {
                const argLength = arguments.length;
                if (argLength !== value.length) {
                    throw new Error(
                        `Wrong number of arguments to case ${key}. Expected ${value.length} (${value}), got ${argLength}`,
                    );
                }
                const args = new Array(argLength);
                for (let i = 0; i < args.length; i++) {
                    args[i] = arguments[i];
                }
                const match = function(branches) {
                    const branchKeys = keys(branches);
                    if (constructors.length !== branchKeys.length) {
                        throw new Error(
                            `Wrong number of arguments to match. Expected: ${constructors.join(
                                ',',
                            )}\nActual: ${branchKeys.join(',')}`,
                        );
                    }
                    const allReqd = forall(constructors, function(reqKey) {
                        return contains(branchKeys, reqKey);
                    });
                    if (!allReqd) {
                        throw new Error(
                            `Not all branches were specified when using match. Specified: ${branchKeys.join(
                                ', ',
                            )}\nRequired: ${constructors.join(', ')}`,
                        );
                    }
                    return branches[key].apply(null, args);
                };
                return {
                    fold() {
                        if (arguments.length !== cases.length) {
                            throw new Error(
                                `Wrong number of arguments to fold. Expected ${cases.length}, got ${arguments.length}`,
                            );
                        }
                        const target = arguments[count];
                        return target.apply(null, args);
                    },
                    match,
                    log(label) {
                        domGlobals.console.log(label, {
                            constructors,
                            constructor: key,
                            params: args,
                        });
                    },
                };
            };
        });
        return adt;
    };
    const Adt = { generate };

    const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    const shallow = function(old, nu) {
        return nu;
    };
    const deep = function(old, nu) {
        const bothObjects = isObject(old) && isObject(nu);
        return bothObjects ? deepMerge(old, nu) : nu;
    };
    const baseMerge = function(merger) {
        return function() {
            const objects = new Array(arguments.length);
            for (let i = 0; i < objects.length; i++) {
                objects[i] = arguments[i];
            }
            if (objects.length === 0) {
                throw new Error("Can't merge zero objects");
            }
            const ret = {};
            for (let j = 0; j < objects.length; j++) {
                const curObject = objects[j];
                for (const key in curObject) {
                    if (hasOwnProperty$1.call(curObject, key)) {
                        ret[key] = merger(ret[key], curObject[key]);
                    }
                }
            }
            return ret;
        };
    };
    var deepMerge = baseMerge(deep);
    const merge = baseMerge(shallow);

    const cached = function(f) {
        let called = false;
        let r;
        return function() {
            const args = [];
            for (let _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!called) {
                called = true;
                r = f.apply(null, args);
            }
            return r;
        };
    };

    const adt = Adt.generate([
        { strict: [] },
        { defaultedThunk: ['fallbackThunk'] },
        { asOption: [] },
        { asDefaultedOptionThunk: ['fallbackThunk'] },
        { mergeWithThunk: ['baseThunk'] },
    ]);
    const defaulted = function(fallback) {
        return adt.defaultedThunk(constant(fallback));
    };
    const mergeWith = function(base) {
        return adt.mergeWithThunk(constant(base));
    };
    const { strict } = adt;
    const { asOption } = adt;
    const { defaultedThunk } = adt;
    const { mergeWithThunk } = adt;

    const exclude = function(obj, fields) {
        const r = {};
        each$1(obj, function(v, k) {
            if (!contains(fields, k)) {
                r[k] = v;
            }
        });
        return r;
    };

    const readOpt = function(key) {
        return function(obj) {
            return has(obj, key) ? Option.from(obj[key]) : Option.none();
        };
    };
    const readOr = function(key, fallback) {
        return function(obj) {
            return has(obj, key) ? obj[key] : fallback;
        };
    };
    const readOptFrom = function(obj, key) {
        return readOpt(key)(obj);
    };
    const hasKey = function(obj, key) {
        return has(obj, key) && obj[key] !== undefined && obj[key] !== null;
    };

    const wrap = function(key, value) {
        const r = {};
        r[key] = value;
        return r;
    };
    const wrapAll = function(keyvalues) {
        const r = {};
        each(keyvalues, function(kv) {
            r[kv.key] = kv.value;
        });
        return r;
    };

    const comparison = Adt.generate([
        {
            bothErrors: ['error1', 'error2'],
        },
        {
            firstError: ['error1', 'value2'],
        },
        {
            secondError: ['value1', 'error2'],
        },
        {
            bothValues: ['value1', 'value2'],
        },
    ]);
    const partition$1 = function(results) {
        const errors = [];
        const values = [];
        each(results, function(result) {
            result.fold(
                function(err) {
                    errors.push(err);
                },
                function(value) {
                    values.push(value);
                },
            );
        });
        return {
            errors,
            values,
        };
    };

    const exclude$1 = function(obj, fields) {
        return exclude(obj, fields);
    };
    const readOpt$1 = function(key) {
        return readOpt(key);
    };
    const readOr$1 = function(key, fallback) {
        return readOr(key, fallback);
    };
    const readOptFrom$1 = function(obj, key) {
        return readOptFrom(obj, key);
    };
    const wrap$1 = function(key, value) {
        return wrap(key, value);
    };
    const wrapAll$1 = function(keyvalues) {
        return wrapAll(keyvalues);
    };
    const mergeValues = function(values, base) {
        return values.length === 0
            ? Result.value(base)
            : Result.value(deepMerge(base, merge.apply(undefined, values)));
    };
    const mergeErrors = function(errors) {
        return Result.error(flatten(errors));
    };
    const consolidate = function(objs, base) {
        const partitions = partition$1(objs);
        return partitions.errors.length > 0
            ? mergeErrors(partitions.errors)
            : mergeValues(partitions.values, base);
    };
    const hasKey$1 = function(obj, key) {
        return hasKey(obj, key);
    };

    let SimpleResultType;
    (function(SimpleResultType) {
        SimpleResultType[(SimpleResultType.Error = 0)] = 'Error';
        SimpleResultType[(SimpleResultType.Value = 1)] = 'Value';
    })(SimpleResultType || (SimpleResultType = {}));
    const fold = function(res, onError, onValue) {
        return res.stype === SimpleResultType.Error
            ? onError(res.serror)
            : onValue(res.svalue);
    };
    const partition$2 = function(results) {
        const values = [];
        const errors = [];
        each(results, function(obj) {
            fold(
                obj,
                function(err) {
                    return errors.push(err);
                },
                function(val) {
                    return values.push(val);
                },
            );
        });
        return {
            values,
            errors,
        };
    };
    const mapError = function(res, f) {
        if (res.stype === SimpleResultType.Error) {
            return {
                stype: SimpleResultType.Error,
                serror: f(res.serror),
            };
        }
        return res;
    };
    const map$2 = function(res, f) {
        if (res.stype === SimpleResultType.Value) {
            return {
                stype: SimpleResultType.Value,
                svalue: f(res.svalue),
            };
        }
        return res;
    };
    const bind$1 = function(res, f) {
        if (res.stype === SimpleResultType.Value) {
            return f(res.svalue);
        }
        return res;
    };
    const bindError = function(res, f) {
        if (res.stype === SimpleResultType.Error) {
            return f(res.serror);
        }
        return res;
    };
    const svalue = function(v) {
        return {
            stype: SimpleResultType.Value,
            svalue: v,
        };
    };
    const serror = function(e) {
        return {
            stype: SimpleResultType.Error,
            serror: e,
        };
    };
    const toResult = function(res) {
        return fold(res, Result.error, Result.value);
    };
    const fromResult = function(res) {
        return res.fold(serror, svalue);
    };
    const SimpleResult = {
        fromResult,
        toResult,
        svalue,
        partition: partition$2,
        serror,
        bind: bind$1,
        bindError,
        map: map$2,
        mapError,
        fold,
    };

    const mergeValues$1 = function(values, base) {
        return values.length > 0
            ? SimpleResult.svalue(
                  deepMerge(base, merge.apply(undefined, values)),
              )
            : SimpleResult.svalue(base);
    };
    const mergeErrors$1 = function(errors) {
        return compose(SimpleResult.serror, flatten)(errors);
    };
    const consolidateObj = function(objects, base) {
        const partition = SimpleResult.partition(objects);
        return partition.errors.length > 0
            ? mergeErrors$1(partition.errors)
            : mergeValues$1(partition.values, base);
    };
    const consolidateArr = function(objects) {
        const partitions = SimpleResult.partition(objects);
        return partitions.errors.length > 0
            ? mergeErrors$1(partitions.errors)
            : SimpleResult.svalue(partitions.values);
    };
    const ResultCombine = {
        consolidateObj,
        consolidateArr,
    };

    const typeAdt = Adt.generate([
        {
            setOf: ['validator', 'valueType'],
        },
        { arrOf: ['valueType'] },
        { objOf: ['fields'] },
        { itemOf: ['validator'] },
        {
            choiceOf: ['key', 'branches'],
        },
        { thunk: ['description'] },
        {
            func: ['args', 'outputSchema'],
        },
    ]);
    const fieldAdt = Adt.generate([
        {
            field: ['name', 'presence', 'type'],
        },
        { state: ['name'] },
    ]);

    const formatObj = function(input) {
        return isObject(input) && keys(input).length > 100
            ? ' removed due to size'
            : JSON.stringify(input, null, 2);
    };
    const formatErrors = function(errors) {
        const es =
            errors.length > 10
                ? errors.slice(0, 10).concat([
                      {
                          path: [],
                          getErrorInfo() {
                              return '... (only showing first ten failures)';
                          },
                      },
                  ])
                : errors;
        return map(es, function(e) {
            return `Failed path: (${e.path.join(' > ')})\n${e.getErrorInfo()}`;
        });
    };

    const nu = function(path, getErrorInfo) {
        return SimpleResult.serror([
            {
                path,
                getErrorInfo,
            },
        ]);
    };
    const missingStrict = function(path, key, obj) {
        return nu(path, function() {
            return `Could not find valid *strict* value for "${key}" in ${formatObj(obj)}`;
        });
    };
    const missingKey = function(path, key) {
        return nu(path, function() {
            return `Choice schema did not contain choice key: "${key}"`;
        });
    };
    const missingBranch = function(path, branches, branch) {
        return nu(path, function() {
            return `The chosen schema: "${branch}" did not exist in branches: ${formatObj(branches)}`;
        });
    };
    const unsupportedFields = function(path, unsupported) {
        return nu(path, function() {
            return `There are unsupported fields: [${unsupported.join(
                ', ',
            )}] specified`;
        });
    };
    const custom = function(path, err) {
        return nu(path, function() {
            return err;
        });
    };

    const adt$1 = Adt.generate([
        {
            field: ['key', 'okey', 'presence', 'prop'],
        },
        {
            state: ['okey', 'instantiator'],
        },
    ]);
    const strictAccess = function(path, obj, key) {
        return readOptFrom(obj, key).fold(function() {
            return missingStrict(path, key, obj);
        }, SimpleResult.svalue);
    };
    const fallbackAccess = function(obj, key, fallbackThunk) {
        const v = readOptFrom(obj, key).fold(function() {
            return fallbackThunk(obj);
        }, identity);
        return SimpleResult.svalue(v);
    };
    const optionAccess = function(obj, key) {
        return SimpleResult.svalue(readOptFrom(obj, key));
    };
    const optionDefaultedAccess = function(obj, key, fallback) {
        const opt = readOptFrom(obj, key).map(function(val) {
            return val === true ? fallback(obj) : val;
        });
        return SimpleResult.svalue(opt);
    };
    const cExtractOne = function(path, obj, field, strength) {
        return field.fold(
            function(key, okey, presence, prop) {
                const bundle = function(av) {
                    const result = prop.extract(
                        path.concat([key]),
                        strength,
                        av,
                    );
                    return SimpleResult.map(result, function(res) {
                        return wrap(okey, strength(res));
                    });
                };
                const bundleAsOption = function(optValue) {
                    return optValue.fold(
                        function() {
                            const outcome = wrap(okey, strength(Option.none()));
                            return SimpleResult.svalue(outcome);
                        },
                        function(ov) {
                            const result = prop.extract(
                                path.concat([key]),
                                strength,
                                ov,
                            );
                            return SimpleResult.map(result, function(res) {
                                return wrap(okey, strength(Option.some(res)));
                            });
                        },
                    );
                };
                return (function() {
                    return presence.fold(
                        function() {
                            return SimpleResult.bind(
                                strictAccess(path, obj, key),
                                bundle,
                            );
                        },
                        function(fallbackThunk) {
                            return SimpleResult.bind(
                                fallbackAccess(obj, key, fallbackThunk),
                                bundle,
                            );
                        },
                        function() {
                            return SimpleResult.bind(
                                optionAccess(obj, key),
                                bundleAsOption,
                            );
                        },
                        function(fallbackThunk) {
                            return SimpleResult.bind(
                                optionDefaultedAccess(obj, key, fallbackThunk),
                                bundleAsOption,
                            );
                        },
                        function(baseThunk) {
                            const base = baseThunk(obj);
                            const result = SimpleResult.map(
                                fallbackAccess(obj, key, constant({})),
                                function(v) {
                                    return deepMerge(base, v);
                                },
                            );
                            return SimpleResult.bind(result, bundle);
                        },
                    );
                })();
            },
            function(okey, instantiator) {
                const state = instantiator(obj);
                return SimpleResult.svalue(wrap(okey, strength(state)));
            },
        );
    };
    const cExtract = function(path, obj, fields, strength) {
        const results = map(fields, function(field) {
            return cExtractOne(path, obj, field, strength);
        });
        return ResultCombine.consolidateObj(results, {});
    };
    const valueThunk = function(getDelegate) {
        const extract = function(path, strength, val) {
            return getDelegate().extract(path, strength, val);
        };
        const toString = function() {
            return getDelegate().toString();
        };
        const toDsl = function() {
            return getDelegate().toDsl();
        };
        return {
            extract,
            toString,
            toDsl,
        };
    };
    const value$1 = function(validator) {
        const extract = function(path, strength, val) {
            return SimpleResult.bindError(validator(val, strength), function(
                err,
            ) {
                return custom(path, err);
            });
        };
        const toString = function() {
            return 'val';
        };
        const toDsl = function() {
            return typeAdt.itemOf(validator);
        };
        return {
            extract,
            toString,
            toDsl,
        };
    };
    const getSetKeys = function(obj) {
        const keys$1 = keys(obj);
        return filter(keys$1, function(k) {
            return hasKey$1(obj, k);
        });
    };
    const objOfOnly = function(fields) {
        const delegate = objOf(fields);
        const fieldNames = foldr(
            fields,
            function(acc, f) {
                return f.fold(function(key) {
                    return deepMerge(acc, wrap$1(key, true));
                }, constant(acc));
            },
            {},
        );
        const extract = function(path, strength, o) {
            const keys = isBoolean(o) ? [] : getSetKeys(o);
            const extra = filter(keys, function(k) {
                return !hasKey$1(fieldNames, k);
            });
            return extra.length === 0
                ? delegate.extract(path, strength, o)
                : unsupportedFields(path, extra);
        };
        return {
            extract,
            toString: delegate.toString,
            toDsl: delegate.toDsl,
        };
    };
    var objOf = function(fields) {
        const extract = function(path, strength, o) {
            return cExtract(path, o, fields, strength);
        };
        const toString = function() {
            const fieldStrings = map(fields, function(field) {
                return field.fold(
                    function(key, okey, presence, prop) {
                        return `${key} -> ${prop.toString()}`;
                    },
                    function(okey, instantiator) {
                        return `state(${okey})`;
                    },
                );
            });
            return `obj{\n${fieldStrings.join('\n')}}`;
        };
        const toDsl = function() {
            return typeAdt.objOf(
                map(fields, function(f) {
                    return f.fold(
                        function(key, okey, presence, prop) {
                            return fieldAdt.field(key, presence, prop);
                        },
                        function(okey, instantiator) {
                            return fieldAdt.state(okey);
                        },
                    );
                }),
            );
        };
        return {
            extract,
            toString,
            toDsl,
        };
    };
    const arrOf = function(prop) {
        const extract = function(path, strength, array) {
            const results = map(array, function(a, i) {
                return prop.extract(path.concat([`[${i}]`]), strength, a);
            });
            return ResultCombine.consolidateArr(results);
        };
        const toString = function() {
            return `array(${prop.toString()})`;
        };
        const toDsl = function() {
            return typeAdt.arrOf(prop);
        };
        return {
            extract,
            toString,
            toDsl,
        };
    };
    const setOf = function(validator, prop) {
        const validateKeys = function(path, keys) {
            return arrOf(value$1(validator)).extract(path, identity, keys);
        };
        const extract = function(path, strength, o) {
            const keys$1 = keys(o);
            const validatedKeys = validateKeys(path, keys$1);
            return SimpleResult.bind(validatedKeys, function(validKeys) {
                const schema = map(validKeys, function(vk) {
                    return adt$1.field(vk, vk, strict(), prop);
                });
                return objOf(schema).extract(path, strength, o);
            });
        };
        const toString = function() {
            return `setOf(${prop.toString()})`;
        };
        const toDsl = function() {
            return typeAdt.setOf(validator, prop);
        };
        return {
            extract,
            toString,
            toDsl,
        };
    };
    const anyValue = constant(value$1(SimpleResult.svalue));
    const arrOfObj = compose(arrOf, objOf);
    const { state } = adt$1;
    const { field } = adt$1;

    const chooseFrom = function(path, strength, input, branches, ch) {
        const fields = readOptFrom$1(branches, ch);
        return fields.fold(
            function() {
                return missingBranch(path, branches, ch);
            },
            function(vp) {
                return vp.extract(
                    path.concat([`branch: ${ch}`]),
                    strength,
                    input,
                );
            },
        );
    };
    const choose = function(key, branches) {
        const extract = function(path, strength, input) {
            const choice = readOptFrom$1(input, key);
            return choice.fold(
                function() {
                    return missingKey(path, key);
                },
                function(chosen) {
                    return chooseFrom(path, strength, input, branches, chosen);
                },
            );
        };
        const toString = function() {
            return `chooseOn(${key}). Possible values: ${keys(branches)}`;
        };
        const toDsl = function() {
            return typeAdt.choiceOf(key, branches);
        };
        return {
            extract,
            toString,
            toDsl,
        };
    };

    const _anyValue = value$1(SimpleResult.svalue);
    const arrOfObj$1 = function(objFields) {
        return arrOfObj(objFields);
    };
    const arrOfVal = function() {
        return arrOf(_anyValue);
    };
    const valueThunkOf = valueThunk;
    const valueOf = function(validator) {
        return value$1(function(v) {
            return validator(v).fold(SimpleResult.serror, SimpleResult.svalue);
        });
    };
    const setOf$1 = function(validator, prop) {
        return setOf(function(v) {
            return SimpleResult.fromResult(validator(v));
        }, prop);
    };
    const extract = function(label, prop, strength, obj) {
        const res = prop.extract([label], strength, obj);
        return SimpleResult.mapError(res, function(errs) {
            return {
                input: obj,
                errors: errs,
            };
        });
    };
    const asRaw = function(label, prop, obj) {
        return SimpleResult.toResult(extract(label, prop, identity, obj));
    };
    const getOrDie = function(extraction) {
        return extraction.fold(function(errInfo) {
            throw new Error(formatError(errInfo));
        }, identity);
    };
    const asRawOrDie = function(label, prop, obj) {
        return getOrDie(asRaw(label, prop, obj));
    };
    var formatError = function(errInfo) {
        return `Errors: \n${formatErrors(
            errInfo.errors,
        )}\n\nInput object: ${formatObj(errInfo.input)}`;
    };
    const chooseProcessor = function(key, branches) {
        return choose(key, branches);
    };
    const choose$1 = function(key, branches) {
        return choose(key, map$1(branches, objOf));
    };
    const anyValue$1 = constant(_anyValue);
    const typedValue = function(validator, expectedType) {
        return value$1(function(a) {
            const actualType = typeof a;
            return validator(a)
                ? SimpleResult.svalue(a)
                : SimpleResult.serror(
                      `Expected type: ${expectedType} but got: ${actualType}`,
                  );
        });
    };
    const number = typedValue(isNumber, 'number');
    const string = typedValue(isString, 'string');
    const boolean = typedValue(isBoolean, 'boolean');
    const functionProcessor = typedValue(isFunction, 'function');
    var isPostMessageable = function(val) {
        const every = function(iter, callbackFn) {
            let result = iter.next();
            while (!result.done) {
                if (!callbackFn(result.value)) {
                    return false;
                }
                result = iter.next();
            }
            return true;
        };
        if (Object(val) !== val) {
            return true;
        }
        switch ({}.toString.call(val).slice(8, -1)) {
            case 'Boolean':
            case 'Number':
            case 'String':
            case 'Date':
            case 'RegExp':
            case 'Blob':
            case 'FileList':
            case 'ImageData':
            case 'ImageBitmap':
            case 'ArrayBuffer':
                return true;
            case 'Array':
            case 'Object':
                return Object.keys(val).every(function(prop) {
                    return isPostMessageable(val[prop]);
                });
            case 'Map':
                return (
                    every(val.keys(), isPostMessageable) &&
                    every(val.values(), isPostMessageable)
                );
            case 'Set':
                return every(val.keys(), isPostMessageable);
            default:
                return false;
        }
    };
    const postMessageable = value$1(function(a) {
        return isPostMessageable(a)
            ? SimpleResult.svalue(a)
            : SimpleResult.serror(
                  'Expected value to be acceptable for sending via postMessage',
              );
    });

    const validateEnum = function(values) {
        return valueOf(function(value) {
            return contains(values, value)
                ? Result.value(value)
                : Result.error(
                      `Unsupported value: "${value}", choose one of "${values.join(
                          ', ',
                      )}".`,
                  );
        });
    };
    const strict$1 = function(key) {
        return field(key, key, strict(), anyValue());
    };
    const strictOf = function(key, schema) {
        return field(key, key, strict(), schema);
    };
    const strictNumber = function(key) {
        return strictOf(key, number);
    };
    const strictString = function(key) {
        return strictOf(key, string);
    };
    const strictStringEnum = function(key, values) {
        return field(key, key, strict(), validateEnum(values));
    };
    const strictBoolean = function(key) {
        return strictOf(key, boolean);
    };
    const strictFunction = function(key) {
        return strictOf(key, functionProcessor);
    };
    const forbid = function(key, message) {
        return field(
            key,
            key,
            asOption(),
            value$1(function(v) {
                return SimpleResult.serror(
                    `The field: ${key} is forbidden. ${message}`,
                );
            }),
        );
    };
    const strictObjOf = function(key, objSchema) {
        return field(key, key, strict(), objOf(objSchema));
    };
    const strictArrayOfObj = function(key, objFields) {
        return field(key, key, strict(), arrOfObj(objFields));
    };
    const strictArrayOf = function(key, schema) {
        return field(key, key, strict(), arrOf(schema));
    };
    const option = function(key) {
        return field(key, key, asOption(), anyValue());
    };
    const optionOf = function(key, schema) {
        return field(key, key, asOption(), schema);
    };
    const optionNumber = function(key) {
        return optionOf(key, number);
    };
    const optionString = function(key) {
        return optionOf(key, string);
    };
    const optionFunction = function(key) {
        return optionOf(key, functionProcessor);
    };
    const optionArrayOf = function(key, schema) {
        return optionOf(key, arrOf(schema));
    };
    const optionObjOf = function(key, objSchema) {
        return optionOf(key, objOf(objSchema));
    };
    const optionObjOfOnly = function(key, objSchema) {
        return optionOf(key, objOfOnly(objSchema));
    };
    const defaulted$1 = function(key, fallback) {
        return field(key, key, defaulted(fallback), anyValue());
    };
    const defaultedOf = function(key, fallback, schema) {
        return field(key, key, defaulted(fallback), schema);
    };
    const defaultedNumber = function(key, fallback) {
        return defaultedOf(key, fallback, number);
    };
    const defaultedString = function(key, fallback) {
        return defaultedOf(key, fallback, string);
    };
    const defaultedStringEnum = function(key, fallback, values) {
        return defaultedOf(key, fallback, validateEnum(values));
    };
    const defaultedBoolean = function(key, fallback) {
        return defaultedOf(key, fallback, boolean);
    };
    const defaultedFunction = function(key, fallback) {
        return defaultedOf(key, fallback, functionProcessor);
    };
    const defaultedPostMsg = function(key, fallback) {
        return defaultedOf(key, fallback, postMessageable);
    };
    const defaultedArrayOf = function(key, fallback, schema) {
        return defaultedOf(key, fallback, arrOf(schema));
    };
    const defaultedObjOf = function(key, fallback, objSchema) {
        return defaultedOf(key, fallback, objOf(objSchema));
    };
    const state$1 = function(okey, instantiator) {
        return state(okey, instantiator);
    };

    var Cell = function(initial) {
        let value = initial;
        const get = function() {
            return value;
        };
        const set = function(v) {
            value = v;
        };
        const clone = function() {
            return Cell(get());
        };
        return {
            get,
            set,
            clone,
        };
    };

    const fromHtml = function(html, scope) {
        const doc = scope || domGlobals.document;
        const div = doc.createElement('div');
        div.innerHTML = html;
        if (!div.hasChildNodes() || div.childNodes.length > 1) {
            domGlobals.console.error(
                'HTML does not have a single root node',
                html,
            );
            throw new Error('HTML must have a single root node');
        }
        return fromDom(div.childNodes[0]);
    };
    const fromTag = function(tag, scope) {
        const doc = scope || domGlobals.document;
        const node = doc.createElement(tag);
        return fromDom(node);
    };
    const fromText = function(text, scope) {
        const doc = scope || domGlobals.document;
        const node = doc.createTextNode(text);
        return fromDom(node);
    };
    var fromDom = function(node) {
        if (node === null || node === undefined) {
            throw new Error('Node cannot be null or undefined');
        }
        return { dom: constant(node) };
    };
    const fromPoint = function(docElm, x, y) {
        const doc = docElm.dom();
        return Option.from(doc.elementFromPoint(x, y)).map(fromDom);
    };
    const Element = {
        fromHtml,
        fromTag,
        fromText,
        fromDom,
        fromPoint,
    };

    const compareDocumentPosition = function(a, b, match) {
        return (a.compareDocumentPosition(b) & match) !== 0;
    };
    const documentPositionPreceding = function(a, b) {
        return compareDocumentPosition(
            a,
            b,
            domGlobals.Node.DOCUMENT_POSITION_PRECEDING,
        );
    };
    const documentPositionContainedBy = function(a, b) {
        return compareDocumentPosition(
            a,
            b,
            domGlobals.Node.DOCUMENT_POSITION_CONTAINED_BY,
        );
    };
    const Node = {
        documentPositionPreceding,
        documentPositionContainedBy,
    };

    const firstMatch = function(regexes, s) {
        for (let i = 0; i < regexes.length; i++) {
            const x = regexes[i];
            if (x.test(s)) {
                return x;
            }
        }
        return undefined;
    };
    const find$2 = function(regexes, agent) {
        const r = firstMatch(regexes, agent);
        if (!r) {
            return {
                major: 0,
                minor: 0,
            };
        }
        const group = function(i) {
            return Number(agent.replace(r, `$${i}`));
        };
        return nu$1(group(1), group(2));
    };
    const detect = function(versionRegexes, agent) {
        const cleanedAgent = String(agent).toLowerCase();
        if (versionRegexes.length === 0) {
            return unknown();
        }
        return find$2(versionRegexes, cleanedAgent);
    };
    var unknown = function() {
        return nu$1(0, 0);
    };
    var nu$1 = function(major, minor) {
        return {
            major,
            minor,
        };
    };
    const Version = {
        nu: nu$1,
        detect,
        unknown,
    };

    const edge = 'Edge';
    const chrome = 'Chrome';
    const ie = 'IE';
    const opera = 'Opera';
    const firefox = 'Firefox';
    const safari = 'Safari';
    const isBrowser = function(name, current) {
        return function() {
            return current === name;
        };
    };
    const unknown$1 = function() {
        return nu$2({
            current: undefined,
            version: Version.unknown(),
        });
    };
    var nu$2 = function(info) {
        const { current } = info;
        const { version } = info;
        return {
            current,
            version,
            isEdge: isBrowser(edge, current),
            isChrome: isBrowser(chrome, current),
            isIE: isBrowser(ie, current),
            isOpera: isBrowser(opera, current),
            isFirefox: isBrowser(firefox, current),
            isSafari: isBrowser(safari, current),
        };
    };
    const Browser = {
        unknown: unknown$1,
        nu: nu$2,
        edge: constant(edge),
        chrome: constant(chrome),
        ie: constant(ie),
        opera: constant(opera),
        firefox: constant(firefox),
        safari: constant(safari),
    };

    const windows = 'Windows';
    const ios = 'iOS';
    const android = 'Android';
    const linux = 'Linux';
    const osx = 'OSX';
    const solaris = 'Solaris';
    const freebsd = 'FreeBSD';
    const chromeos = 'ChromeOS';
    const isOS = function(name, current) {
        return function() {
            return current === name;
        };
    };
    const unknown$2 = function() {
        return nu$3({
            current: undefined,
            version: Version.unknown(),
        });
    };
    var nu$3 = function(info) {
        const { current } = info;
        const { version } = info;
        return {
            current,
            version,
            isWindows: isOS(windows, current),
            isiOS: isOS(ios, current),
            isAndroid: isOS(android, current),
            isOSX: isOS(osx, current),
            isLinux: isOS(linux, current),
            isSolaris: isOS(solaris, current),
            isFreeBSD: isOS(freebsd, current),
            isChromeOS: isOS(chromeos, current),
        };
    };
    const OperatingSystem = {
        unknown: unknown$2,
        nu: nu$3,
        windows: constant(windows),
        ios: constant(ios),
        android: constant(android),
        linux: constant(linux),
        osx: constant(osx),
        solaris: constant(solaris),
        freebsd: constant(freebsd),
        chromeos: constant(chromeos),
    };

    const DeviceType = function(os, browser, userAgent, mediaMatch) {
        const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
        const isiPhone = os.isiOS() && !isiPad;
        const isMobile = os.isiOS() || os.isAndroid();
        const isTouch = isMobile || mediaMatch('(pointer:coarse)');
        const isTablet =
            isiPad ||
            (!isiPhone && isMobile && mediaMatch('(min-device-width:768px)'));
        const isPhone = isiPhone || (isMobile && !isTablet);
        const iOSwebview =
            browser.isSafari() &&
            os.isiOS() &&
            /safari/i.test(userAgent) === false;
        const isDesktop = !isPhone && !isTablet && !iOSwebview;
        return {
            isiPad: constant(isiPad),
            isiPhone: constant(isiPhone),
            isTablet: constant(isTablet),
            isPhone: constant(isPhone),
            isTouch: constant(isTouch),
            isAndroid: os.isAndroid,
            isiOS: os.isiOS,
            isWebView: constant(iOSwebview),
            isDesktop: constant(isDesktop),
        };
    };

    const detect$1 = function(candidates, userAgent) {
        const agent = String(userAgent).toLowerCase();
        return find(candidates, function(candidate) {
            return candidate.search(agent);
        });
    };
    const detectBrowser = function(browsers, userAgent) {
        return detect$1(browsers, userAgent).map(function(browser) {
            const version = Version.detect(browser.versionRegexes, userAgent);
            return {
                current: browser.name,
                version,
            };
        });
    };
    const detectOs = function(oses, userAgent) {
        return detect$1(oses, userAgent).map(function(os) {
            const version = Version.detect(os.versionRegexes, userAgent);
            return {
                current: os.name,
                version,
            };
        });
    };
    const UaString = {
        detectBrowser,
        detectOs,
    };

    const checkRange = function(str, substr, start) {
        if (substr === '') {
            return true;
        }
        if (str.length < substr.length) {
            return false;
        }
        const x = str.substr(start, start + substr.length);
        return x === substr;
    };
    const contains$1 = function(str, substr) {
        return str.indexOf(substr) !== -1;
    };
    const endsWith = function(str, suffix) {
        return checkRange(str, suffix, str.length - suffix.length);
    };
    const trim = function(str) {
        return str.replace(/^\s+|\s+$/g, '');
    };

    const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    const checkContains = function(target) {
        return function(uastring) {
            return contains$1(uastring, target);
        };
    };
    const browsers = [
        {
            name: 'Edge',
            versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
            search(uastring) {
                return (
                    contains$1(uastring, 'edge/') &&
                    contains$1(uastring, 'chrome') &&
                    contains$1(uastring, 'safari') &&
                    contains$1(uastring, 'applewebkit')
                );
            },
        },
        {
            name: 'Chrome',
            versionRegexes: [
                /.*?chrome\/([0-9]+)\.([0-9]+).*/,
                normalVersionRegex,
            ],
            search(uastring) {
                return (
                    contains$1(uastring, 'chrome') &&
                    !contains$1(uastring, 'chromeframe')
                );
            },
        },
        {
            name: 'IE',
            versionRegexes: [
                /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
                /.*?rv:([0-9]+)\.([0-9]+).*/,
            ],
            search(uastring) {
                return (
                    contains$1(uastring, 'msie') ||
                    contains$1(uastring, 'trident')
                );
            },
        },
        {
            name: 'Opera',
            versionRegexes: [
                normalVersionRegex,
                /.*?opera\/([0-9]+)\.([0-9]+).*/,
            ],
            search: checkContains('opera'),
        },
        {
            name: 'Firefox',
            versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
            search: checkContains('firefox'),
        },
        {
            name: 'Safari',
            versionRegexes: [
                normalVersionRegex,
                /.*?cpu os ([0-9]+)_([0-9]+).*/,
            ],
            search(uastring) {
                return (
                    (contains$1(uastring, 'safari') ||
                        contains$1(uastring, 'mobile/')) &&
                    contains$1(uastring, 'applewebkit')
                );
            },
        },
    ];
    const oses = [
        {
            name: 'Windows',
            search: checkContains('win'),
            versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/],
        },
        {
            name: 'iOS',
            search(uastring) {
                return (
                    contains$1(uastring, 'iphone') ||
                    contains$1(uastring, 'ipad')
                );
            },
            versionRegexes: [
                /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
                /.*cpu os ([0-9]+)_([0-9]+).*/,
                /.*cpu iphone os ([0-9]+)_([0-9]+).*/,
            ],
        },
        {
            name: 'Android',
            search: checkContains('android'),
            versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/],
        },
        {
            name: 'OSX',
            search: checkContains('mac os x'),
            versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/],
        },
        {
            name: 'Linux',
            search: checkContains('linux'),
            versionRegexes: [],
        },
        {
            name: 'Solaris',
            search: checkContains('sunos'),
            versionRegexes: [],
        },
        {
            name: 'FreeBSD',
            search: checkContains('freebsd'),
            versionRegexes: [],
        },
        {
            name: 'ChromeOS',
            search: checkContains('cros'),
            versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/],
        },
    ];
    const PlatformInfo = {
        browsers: constant(browsers),
        oses: constant(oses),
    };

    const detect$2 = function(userAgent, mediaMatch) {
        const browsers = PlatformInfo.browsers();
        const oses = PlatformInfo.oses();
        const browser = UaString.detectBrowser(browsers, userAgent).fold(
            Browser.unknown,
            Browser.nu,
        );
        const os = UaString.detectOs(oses, userAgent).fold(
            OperatingSystem.unknown,
            OperatingSystem.nu,
        );
        const deviceType = DeviceType(os, browser, userAgent, mediaMatch);
        return {
            browser,
            os,
            deviceType,
        };
    };
    const PlatformDetection = { detect: detect$2 };

    const mediaMatch = function(query) {
        return domGlobals.window.matchMedia(query).matches;
    };
    const platform = Cell(
        PlatformDetection.detect(domGlobals.navigator.userAgent, mediaMatch),
    );
    const detect$3 = function() {
        return platform.get();
    };

    const ATTRIBUTE = domGlobals.Node.ATTRIBUTE_NODE;
    const CDATA_SECTION = domGlobals.Node.CDATA_SECTION_NODE;
    const COMMENT = domGlobals.Node.COMMENT_NODE;
    const DOCUMENT = domGlobals.Node.DOCUMENT_NODE;
    const DOCUMENT_TYPE = domGlobals.Node.DOCUMENT_TYPE_NODE;
    const DOCUMENT_FRAGMENT = domGlobals.Node.DOCUMENT_FRAGMENT_NODE;
    const ELEMENT = domGlobals.Node.ELEMENT_NODE;
    const TEXT = domGlobals.Node.TEXT_NODE;
    const PROCESSING_INSTRUCTION = domGlobals.Node.PROCESSING_INSTRUCTION_NODE;
    const ENTITY_REFERENCE = domGlobals.Node.ENTITY_REFERENCE_NODE;
    const ENTITY = domGlobals.Node.ENTITY_NODE;
    const NOTATION = domGlobals.Node.NOTATION_NODE;

    const ELEMENT$1 = ELEMENT;
    const DOCUMENT$1 = DOCUMENT;
    const is = function(element, selector) {
        const dom = element.dom();
        if (dom.nodeType !== ELEMENT$1) {
            return false;
        }
        const elem = dom;
        if (elem.matches !== undefined) {
            return elem.matches(selector);
        }
        if (elem.msMatchesSelector !== undefined) {
            return elem.msMatchesSelector(selector);
        }
        if (elem.webkitMatchesSelector !== undefined) {
            return elem.webkitMatchesSelector(selector);
        }
        if (elem.mozMatchesSelector !== undefined) {
            return elem.mozMatchesSelector(selector);
        }
        throw new Error('Browser lacks native selectors');
    };
    const bypassSelector = function(dom) {
        return (
            (dom.nodeType !== ELEMENT$1 && dom.nodeType !== DOCUMENT$1) ||
            dom.childElementCount === 0
        );
    };
    const all = function(selector, scope) {
        const base = scope === undefined ? domGlobals.document : scope.dom();
        return bypassSelector(base)
            ? []
            : map(base.querySelectorAll(selector), Element.fromDom);
    };
    const one = function(selector, scope) {
        const base = scope === undefined ? domGlobals.document : scope.dom();
        return bypassSelector(base)
            ? Option.none()
            : Option.from(base.querySelector(selector)).map(Element.fromDom);
    };

    const eq = function(e1, e2) {
        return e1.dom() === e2.dom();
    };
    const regularContains = function(e1, e2) {
        const d1 = e1.dom();
        const d2 = e2.dom();
        return d1 === d2 ? false : d1.contains(d2);
    };
    const ieContains = function(e1, e2) {
        return Node.documentPositionContainedBy(e1.dom(), e2.dom());
    };
    const { browser } = detect$3();
    const contains$2 = browser.isIE() ? ieContains : regularContains;

    const isSource = function(component, simulatedEvent) {
        return eq(component.element(), simulatedEvent.event().target());
    };

    function ClosestOrAncestor(is, ancestor, scope, a, isRoot) {
        return is(scope, a)
            ? Option.some(scope)
            : isFunction(isRoot) && isRoot(scope)
            ? Option.none()
            : ancestor(scope, a, isRoot);
    }

    const Global =
        typeof domGlobals.window !== 'undefined'
            ? domGlobals.window
            : Function('return this;')();

    const name = function(element) {
        const r = element.dom().nodeName;
        return r.toLowerCase();
    };
    const type = function(element) {
        return element.dom().nodeType;
    };
    const isType$1 = function(t) {
        return function(element) {
            return type(element) === t;
        };
    };
    const isElement = isType$1(ELEMENT);
    const isText = isType$1(TEXT);

    const inBody = function(element) {
        const dom = isText(element) ? element.dom().parentNode : element.dom();
        return (
            dom !== undefined &&
            dom !== null &&
            dom.ownerDocument.body.contains(dom)
        );
    };
    const body = cached(function() {
        return getBody(Element.fromDom(domGlobals.document));
    });
    var getBody = function(doc) {
        const b = doc.dom().body;
        if (b === null || b === undefined) {
            throw new Error('Body is not available yet');
        }
        return Element.fromDom(b);
    };

    const ancestor = function(scope, predicate, isRoot) {
        let element = scope.dom();
        const stop = isFunction(isRoot) ? isRoot : constant(false);
        while (element.parentNode) {
            element = element.parentNode;
            const el = Element.fromDom(element);
            if (predicate(el)) {
                return Option.some(el);
            }
            if (stop(el)) {
                break;
            }
        }
        return Option.none();
    };
    const closest = function(scope, predicate, isRoot) {
        const is = function(s, test) {
            return test(s);
        };
        return ClosestOrAncestor(is, ancestor, scope, predicate, isRoot);
    };
    const descendant = function(scope, predicate) {
        var descend = function(node) {
            for (let i = 0; i < node.childNodes.length; i++) {
                const child_1 = Element.fromDom(node.childNodes[i]);
                if (predicate(child_1)) {
                    return Option.some(child_1);
                }
                const res = descend(node.childNodes[i]);
                if (res.isSome()) {
                    return res;
                }
            }
            return Option.none();
        };
        return descend(scope.dom());
    };

    const closest$1 = function(target, transform, isRoot) {
        const delegate = closest(
            target,
            function(elem) {
                return transform(elem).isSome();
            },
            isRoot,
        );
        return delegate.bind(transform);
    };

    const nu$4 = function(parts) {
        if (
            !hasKey$1(parts, 'can') &&
            !hasKey$1(parts, 'abort') &&
            !hasKey$1(parts, 'run')
        ) {
            throw new Error(
                `EventHandler defined by: ${JSON.stringify(
                    parts,
                    null,
                    2,
                )} does not have can, abort, or run!`,
            );
        }
        return asRawOrDie(
            'Extracting event.handler',
            objOfOnly([
                defaulted$1('can', constant(true)),
                defaulted$1('abort', constant(false)),
                defaulted$1('run', noop),
            ]),
            parts,
        );
    };
    const all$1 = function(handlers, f) {
        return function() {
            const args = [];
            for (let _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return foldl(
                handlers,
                function(acc, handler) {
                    return acc && f(handler).apply(undefined, args);
                },
                true,
            );
        };
    };
    const any = function(handlers, f) {
        return function() {
            const args = [];
            for (let _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return foldl(
                handlers,
                function(acc, handler) {
                    return acc || f(handler).apply(undefined, args);
                },
                false,
            );
        };
    };
    const read = function(handler) {
        return isFunction(handler)
            ? {
                  can: constant(true),
                  abort: constant(false),
                  run: handler,
              }
            : handler;
    };
    const fuse = function(handlers) {
        const can = all$1(handlers, function(handler) {
            return handler.can;
        });
        const abort = any(handlers, function(handler) {
            return handler.abort;
        });
        const run = function() {
            const args = [];
            for (let _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            each(handlers, function(handler) {
                handler.run.apply(undefined, args);
            });
        };
        return nu$4({
            can,
            abort,
            run,
        });
    };

    const touchstart = constant('touchstart');
    const touchmove = constant('touchmove');
    const touchend = constant('touchend');
    const touchcancel = constant('touchcancel');
    const mousedown = constant('mousedown');
    const mousemove = constant('mousemove');
    const mouseout = constant('mouseout');
    const mouseup = constant('mouseup');
    const mouseover = constant('mouseover');
    const focusin = constant('focusin');
    const focusout = constant('focusout');
    const keydown = constant('keydown');
    const keyup = constant('keyup');
    const input = constant('input');
    const change = constant('change');
    const click = constant('click');
    const transitionend = constant('transitionend');
    const selectstart = constant('selectstart');

    const alloy = { tap: constant('alloy.tap') };
    const focus = constant('alloy.focus');
    const postBlur = constant('alloy.blur.post');
    const postPaste = constant('alloy.paste.post');
    const receive = constant('alloy.receive');
    const execute = constant('alloy.execute');
    const focusItem = constant('alloy.focus.item');
    const { tap } = alloy;
    const longpress = constant('alloy.longpress');
    const sandboxClose = constant('alloy.sandbox.close');
    const typeaheadCancel = constant('alloy.typeahead.cancel');
    const systemInit = constant('alloy.system.init');
    const documentTouchmove = constant('alloy.system.touchmove');
    const documentTouchend = constant('alloy.system.touchend');
    const windowScroll = constant('alloy.system.scroll');
    const windowResize = constant('alloy.system.resize');
    const attachedToDom = constant('alloy.system.attached');
    const detachedFromDom = constant('alloy.system.detached');
    const dismissRequested = constant('alloy.system.dismissRequested');
    const repositionRequested = constant('alloy.system.repositionRequested');
    const focusShifted = constant('alloy.focusmanager.shifted');
    const slotVisibility = constant('alloy.slotcontainer.visibility');
    const changeTab = constant('alloy.change.tab');
    const dismissTab = constant('alloy.dismiss.tab');
    const highlight = constant('alloy.highlight');
    const dehighlight = constant('alloy.dehighlight');

    const emit = function(component, event) {
        dispatchWith(component, component.element(), event, {});
    };
    const emitWith = function(component, event, properties) {
        dispatchWith(component, component.element(), event, properties);
    };
    const emitExecute = function(component) {
        emit(component, execute());
    };
    const dispatch = function(component, target, event) {
        dispatchWith(component, target, event, {});
    };
    var dispatchWith = function(component, target, event, properties) {
        const data = { target, ...properties };
        component
            .getSystem()
            .triggerEvent(event, target, map$1(data, constant));
    };
    const dispatchEvent = function(component, target, event, simulatedEvent) {
        component
            .getSystem()
            .triggerEvent(event, target, simulatedEvent.event());
    };

    const derive = function(configs) {
        return wrapAll$1(configs);
    };
    const abort = function(name, predicate) {
        return {
            key: name,
            value: nu$4({ abort: predicate }),
        };
    };
    const can = function(name, predicate) {
        return {
            key: name,
            value: nu$4({ can: predicate }),
        };
    };
    const preventDefault = function(name) {
        return {
            key: name,
            value: nu$4({
                run(component, simulatedEvent) {
                    simulatedEvent.event().prevent();
                },
            }),
        };
    };
    const run = function(name, handler) {
        return {
            key: name,
            value: nu$4({ run: handler }),
        };
    };
    const runActionExtra = function(name, action, extra) {
        return {
            key: name,
            value: nu$4({
                run(component, simulatedEvent) {
                    action.apply(
                        undefined,
                        [component, simulatedEvent].concat(extra),
                    );
                },
            }),
        };
    };
    const runOnName = function(name) {
        return function(handler) {
            return run(name, handler);
        };
    };
    const runOnSourceName = function(name) {
        return function(handler) {
            return {
                key: name,
                value: nu$4({
                    run(component, simulatedEvent) {
                        if (isSource(component, simulatedEvent)) {
                            handler(component, simulatedEvent);
                        }
                    },
                }),
            };
        };
    };
    const redirectToUid = function(name, uid) {
        return run(name, function(component, simulatedEvent) {
            component
                .getSystem()
                .getByUid(uid)
                .each(function(redirectee) {
                    dispatchEvent(
                        redirectee,
                        redirectee.element(),
                        name,
                        simulatedEvent,
                    );
                });
        });
    };
    const redirectToPart = function(name, detail, partName) {
        const uid = detail.partUids[partName];
        return redirectToUid(name, uid);
    };
    const runWithTarget = function(name, f) {
        return run(name, function(component, simulatedEvent) {
            const ev = simulatedEvent.event();
            const target = component
                .getSystem()
                .getByDom(ev.target())
                .fold(
                    function() {
                        const closest = closest$1(
                            ev.target(),
                            function(el) {
                                return component
                                    .getSystem()
                                    .getByDom(el)
                                    .toOption();
                            },
                            constant(false),
                        );
                        return closest.getOr(component);
                    },
                    function(c) {
                        return c;
                    },
                );
            f(component, target, simulatedEvent);
        });
    };
    const cutter = function(name) {
        return run(name, function(component, simulatedEvent) {
            simulatedEvent.cut();
        });
    };
    const stopper = function(name) {
        return run(name, function(component, simulatedEvent) {
            simulatedEvent.stop();
        });
    };
    const runOnSource = function(name, f) {
        return runOnSourceName(name)(f);
    };
    const runOnAttached = runOnSourceName(attachedToDom());
    const runOnDetached = runOnSourceName(detachedFromDom());
    const runOnInit = runOnSourceName(systemInit());
    const runOnExecute = runOnName(execute());

    const Immutable = function() {
        const fields = [];
        for (let _i = 0; _i < arguments.length; _i++) {
            fields[_i] = arguments[_i];
        }
        return function() {
            const values = [];
            for (let _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            if (fields.length !== values.length) {
                throw new Error(
                    `Wrong number of arguments to struct. Expected "[${fields.length}]", got ${values.length} arguments`,
                );
            }
            const struct = {};
            each(fields, function(name, i) {
                struct[name] = constant(values[i]);
            });
            return struct;
        };
    };

    const sort$1 = function(arr) {
        return arr.slice(0).sort();
    };
    const reqMessage = function(required, keys) {
        throw new Error(
            `All required keys (${sort$1(required).join(
                ', ',
            )}) were not specified. Specified keys were: ${sort$1(keys).join(
                ', ',
            )}.`,
        );
    };
    const unsuppMessage = function(unsupported) {
        throw new Error(
            `Unsupported keys for object: ${sort$1(unsupported).join(', ')}`,
        );
    };
    const validateStrArr = function(label, array) {
        if (!isArray(array)) {
            throw new Error(
                `The ${label} fields must be an array. Was: ${array}.`,
            );
        }
        each(array, function(a) {
            if (!isString(a)) {
                throw new Error(
                    `The value ${a} in the ${label} fields was not a string.`,
                );
            }
        });
    };
    const checkDupes = function(everything) {
        const sorted = sort$1(everything);
        const dupe = find(sorted, function(s, i) {
            return i < sorted.length - 1 && s === sorted[i + 1];
        });
        dupe.each(function(d) {
            throw new Error(
                `The field: ${d} occurs more than once in the combined fields: [${sorted.join(
                    ', ',
                )}].`,
            );
        });
    };

    const MixedBag = function(required, optional) {
        const everything = required.concat(optional);
        if (everything.length === 0) {
            throw new Error(
                'You must specify at least one required or optional field.',
            );
        }
        validateStrArr('required', required);
        validateStrArr('optional', optional);
        checkDupes(everything);
        return function(obj) {
            const keys$1 = keys(obj);
            const allReqd = forall(required, function(req) {
                return contains(keys$1, req);
            });
            if (!allReqd) {
                reqMessage(required, keys$1);
            }
            const unsupported = filter(keys$1, function(key) {
                return !contains(everything, key);
            });
            if (unsupported.length > 0) {
                unsuppMessage(unsupported);
            }
            const r = {};
            each(required, function(req) {
                r[req] = constant(obj[req]);
            });
            each(optional, function(opt) {
                r[opt] = constant(
                    Object.prototype.hasOwnProperty.call(obj, opt)
                        ? Option.some(obj[opt])
                        : Option.none(),
                );
            });
            return r;
        };
    };

    const owner = function(element) {
        return Element.fromDom(element.dom().ownerDocument);
    };
    const documentElement = function(element) {
        return Element.fromDom(element.dom().ownerDocument.documentElement);
    };
    const defaultView = function(element) {
        return Element.fromDom(element.dom().ownerDocument.defaultView);
    };
    const parent = function(element) {
        return Option.from(element.dom().parentNode).map(Element.fromDom);
    };
    const offsetParent = function(element) {
        return Option.from(element.dom().offsetParent).map(Element.fromDom);
    };
    const nextSibling = function(element) {
        return Option.from(element.dom().nextSibling).map(Element.fromDom);
    };
    const children = function(element) {
        return map(element.dom().childNodes, Element.fromDom);
    };
    const child = function(element, index) {
        const cs = element.dom().childNodes;
        return Option.from(cs[index]).map(Element.fromDom);
    };
    const firstChild = function(element) {
        return child(element, 0);
    };
    const spot = Immutable('element', 'offset');

    const fromHtml$1 = function(html, scope) {
        const doc = scope || domGlobals.document;
        const div = doc.createElement('div');
        div.innerHTML = html;
        return children(Element.fromDom(div));
    };

    const before = function(marker, element) {
        const parent$1 = parent(marker);
        parent$1.each(function(v) {
            v.dom().insertBefore(element.dom(), marker.dom());
        });
    };
    const after = function(marker, element) {
        const sibling = nextSibling(marker);
        sibling.fold(
            function() {
                const parent$1 = parent(marker);
                parent$1.each(function(v) {
                    append(v, element);
                });
            },
            function(v) {
                before(v, element);
            },
        );
    };
    const prepend = function(parent, element) {
        const firstChild$1 = firstChild(parent);
        firstChild$1.fold(
            function() {
                append(parent, element);
            },
            function(v) {
                parent.dom().insertBefore(element.dom(), v.dom());
            },
        );
    };
    var append = function(parent, element) {
        parent.dom().appendChild(element.dom());
    };
    const appendAt = function(parent, element, index) {
        child(parent, index).fold(
            function() {
                append(parent, element);
            },
            function(v) {
                before(v, element);
            },
        );
    };

    const before$1 = function(marker, elements) {
        each(elements, function(x) {
            before(marker, x);
        });
    };
    const append$1 = function(parent, elements) {
        each(elements, function(x) {
            append(parent, x);
        });
    };

    const empty = function(element) {
        element.dom().textContent = '';
        each(children(element), function(rogue) {
            remove(rogue);
        });
    };
    var remove = function(element) {
        const dom = element.dom();
        if (dom.parentNode !== null) {
            dom.parentNode.removeChild(dom);
        }
    };
    const unwrap = function(wrapper) {
        const children$1 = children(wrapper);
        if (children$1.length > 0) {
            before$1(wrapper, children$1);
        }
        remove(wrapper);
    };

    const get$1 = function(element) {
        return element.dom().innerHTML;
    };
    const set = function(element, content) {
        const owner$1 = owner(element);
        const docDom = owner$1.dom();
        const fragment = Element.fromDom(docDom.createDocumentFragment());
        const contentElements = fromHtml$1(content, docDom);
        append$1(fragment, contentElements);
        empty(element);
        append(element, fragment);
    };
    const getOuter = function(element) {
        const container = Element.fromTag('div');
        const clone = Element.fromDom(element.dom().cloneNode(true));
        append(container, clone);
        return get$1(container);
    };

    const rawSet = function(dom, key, value) {
        if (isString(value) || isBoolean(value) || isNumber(value)) {
            dom.setAttribute(key, `${value}`);
        } else {
            domGlobals.console.error(
                'Invalid call to Attr.set. Key ',
                key,
                ':: Value ',
                value,
                ':: Element ',
                dom,
            );
            throw new Error('Attribute value was not simple');
        }
    };
    const set$1 = function(element, key, value) {
        rawSet(element.dom(), key, value);
    };
    const setAll = function(element, attrs) {
        const dom = element.dom();
        each$1(attrs, function(v, k) {
            rawSet(dom, k, v);
        });
    };
    const get$2 = function(element, key) {
        const v = element.dom().getAttribute(key);
        return v === null ? undefined : v;
    };
    const has$1 = function(element, key) {
        const dom = element.dom();
        return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;
    };
    const remove$1 = function(element, key) {
        element.dom().removeAttribute(key);
    };

    const clone = function(original, isDeep) {
        return Element.fromDom(original.dom().cloneNode(isDeep));
    };
    const shallow$1 = function(original) {
        return clone(original, false);
    };

    const getHtml = function(element) {
        const clone = shallow$1(element);
        return getOuter(clone);
    };

    const element = function(elem) {
        return getHtml(elem);
    };

    const isRecursive = function(component, originator, target) {
        return eq(originator, component.element()) && !eq(originator, target);
    };
    const events = derive([
        can(focus(), function(component, simulatedEvent) {
            const originator = simulatedEvent.event().originator();
            const target = simulatedEvent.event().target();
            if (isRecursive(component, originator, target)) {
                domGlobals.console.warn(
                    `${focus()} did not get interpreted by the desired target. ` +
                        `\nOriginator: ${element(
                            originator,
                        )}\nTarget: ${element(
                            target,
                        )}\nCheck the ${focus()} event handlers`,
                );
                return false;
            }
            return true;
        }),
    ]);

    const DefaultEvents = /* #__PURE__ */ Object.freeze({
        events,
    });

    let unique = 0;
    const generate$1 = function(prefix) {
        const date = new Date();
        const time = date.getTime();
        const random = Math.floor(Math.random() * 1000000000);
        unique++;
        return `${prefix}_${random}${unique}${String(time)}`;
    };

    const prefix = constant('alloy-id-');
    const idAttr = constant('data-alloy-id');

    const prefix$1 = prefix();
    const idAttr$1 = idAttr();
    const write = function(label, elem) {
        const id = generate$1(prefix$1 + label);
        writeOnly(elem, id);
        return id;
    };
    var writeOnly = function(elem, uid) {
        Object.defineProperty(elem.dom(), idAttr$1, {
            value: uid,
            writable: true,
        });
    };
    const read$1 = function(elem) {
        const id = isElement(elem) ? elem.dom()[idAttr$1] : null;
        return Option.from(id);
    };
    const generate$2 = function(prefix) {
        return generate$1(prefix);
    };

    const make = identity;

    const NoContextApi = function(getComp) {
        const fail = function(event) {
            return function() {
                throw new Error(
                    `The component must be in a context to send: ${event}\n${element(
                        getComp().element(),
                    )} is not in context.`,
                );
            };
        };
        return {
            debugInfo: constant('fake'),
            triggerEvent: fail('triggerEvent'),
            triggerFocus: fail('triggerFocus'),
            triggerEscape: fail('triggerEscape'),
            build: fail('build'),
            addToWorld: fail('addToWorld'),
            removeFromWorld: fail('removeFromWorld'),
            addToGui: fail('addToGui'),
            removeFromGui: fail('removeFromGui'),
            getByUid: fail('getByUid'),
            getByDom: fail('getByDom'),
            broadcast: fail('broadcast'),
            broadcastOn: fail('broadcastOn'),
            broadcastEvent: fail('broadcastEvent'),
            isConnected: constant(false),
        };
    };
    const singleton = NoContextApi();

    const markAsBehaviourApi = function(f, apiName, apiFunction) {
        const delegate = apiFunction.toString();
        const endIndex = delegate.indexOf(')') + 1;
        const openBracketIndex = delegate.indexOf('(');
        const parameters = delegate
            .substring(openBracketIndex + 1, endIndex - 1)
            .split(/,\s*/);
        f.toFunctionAnnotation = function() {
            return {
                name: apiName,
                parameters: cleanParameters(
                    parameters.slice(0, 1).concat(parameters.slice(3)),
                ),
            };
        };
        return f;
    };
    var cleanParameters = function(parameters) {
        return map(parameters, function(p) {
            return endsWith(p, '/*')
                ? p.substring(0, p.length - '/*'.length)
                : p;
        });
    };
    const markAsExtraApi = function(f, extraName) {
        const delegate = f.toString();
        const endIndex = delegate.indexOf(')') + 1;
        const openBracketIndex = delegate.indexOf('(');
        const parameters = delegate
            .substring(openBracketIndex + 1, endIndex - 1)
            .split(/,\s*/);
        f.toFunctionAnnotation = function() {
            return {
                name: extraName,
                parameters: cleanParameters(parameters),
            };
        };
        return f;
    };
    const markAsSketchApi = function(f, apiFunction) {
        const delegate = apiFunction.toString();
        const endIndex = delegate.indexOf(')') + 1;
        const openBracketIndex = delegate.indexOf('(');
        const parameters = delegate
            .substring(openBracketIndex + 1, endIndex - 1)
            .split(/,\s*/);
        f.toFunctionAnnotation = function() {
            return {
                name: 'OVERRIDE',
                parameters: cleanParameters(parameters.slice(1)),
            };
        };
        return f;
    };

    const premadeTag = generate$1('alloy-premade');
    const premade = function(comp) {
        return wrap$1(premadeTag, comp);
    };
    const getPremade = function(spec) {
        return readOptFrom$1(spec, premadeTag);
    };
    const makeApi = function(f) {
        return markAsSketchApi(function(component) {
            const rest = [];
            for (let _i = 1; _i < arguments.length; _i++) {
                rest[_i - 1] = arguments[_i];
            }
            return f.apply(
                undefined,
                [component.getApis()].concat([component].concat(rest)),
            );
        }, f);
    };

    const NoState = {
        init() {
            return nu$5({
                readState() {
                    return 'No State required';
                },
            });
        },
    };
    var nu$5 = function(spec) {
        return spec;
    };

    const generateFrom = function(spec, all) {
        const schema = map(all, function(a) {
            return optionObjOf(a.name(), [
                strict$1('config'),
                defaulted$1('state', NoState),
            ]);
        });
        const validated = asRaw(
            'component.behaviours',
            objOf(schema),
            spec.behaviours,
        ).fold(
            function(errInfo) {
                throw new Error(
                    `${formatError(errInfo)}\nComplete spec:\n${JSON.stringify(
                        spec,
                        null,
                        2,
                    )}`,
                );
            },
            function(v) {
                return v;
            },
        );
        return {
            list: all,
            data: map$1(validated, function(optBlobThunk) {
                const optBlob = optBlobThunk;
                const output = optBlob.map(function(blob) {
                    return {
                        config: blob.config,
                        state: blob.state.init(blob.config),
                    };
                });
                return function() {
                    return output;
                };
            }),
        };
    };
    const getBehaviours = function(bData) {
        return bData.list;
    };
    const getData = function(bData) {
        return bData.data;
    };

    const byInnerKey = function(data, tuple) {
        const r = {};
        each$1(data, function(detail, key) {
            each$1(detail, function(value, indexKey) {
                const chain = readOr$1(indexKey, [])(r);
                r[indexKey] = chain.concat([tuple(key, value)]);
            });
        });
        return r;
    };

    const nu$6 = function(s) {
        return {
            classes: s.classes !== undefined ? s.classes : [],
            attributes: s.attributes !== undefined ? s.attributes : {},
            styles: s.styles !== undefined ? s.styles : {},
        };
    };
    const merge$1 = function(defnA, mod) {
        return {
            ...defnA,
            attributes: { ...defnA.attributes, ...mod.attributes },
            styles: { ...defnA.styles, ...mod.styles },
            classes: defnA.classes.concat(mod.classes),
        };
    };

    const combine = function(info, baseMod, behaviours, base) {
        const modsByBehaviour = { ...baseMod };
        each(behaviours, function(behaviour) {
            modsByBehaviour[behaviour.name()] = behaviour.exhibit(info, base);
        });
        const nameAndMod = function(name, modification) {
            return {
                name,
                modification,
            };
        };
        const byAspect = byInnerKey(modsByBehaviour, nameAndMod);
        const combineObjects = function(objects) {
            return foldr(
                objects,
                function(b, a) {
                    return { ...a.modification, ...b };
                },
                {},
            );
        };
        const combinedClasses = foldr(
            byAspect.classes,
            function(b, a) {
                return a.modification.concat(b);
            },
            [],
        );
        const combinedAttributes = combineObjects(byAspect.attributes);
        const combinedStyles = combineObjects(byAspect.styles);
        return nu$6({
            classes: combinedClasses,
            attributes: combinedAttributes,
            styles: combinedStyles,
        });
    };

    const sortKeys = function(label, keyName, array, order) {
        const sliced = array.slice(0);
        try {
            const sorted = sliced.sort(function(a, b) {
                const aKey = a[keyName]();
                const bKey = b[keyName]();
                const aIndex = order.indexOf(aKey);
                const bIndex = order.indexOf(bKey);
                if (aIndex === -1) {
                    throw new Error(
                        `The ordering for ${label} does not have an entry for ${aKey}.\nOrder specified: ${JSON.stringify(
                            order,
                            null,
                            2,
                        )}`,
                    );
                }
                if (bIndex === -1) {
                    throw new Error(
                        `The ordering for ${label} does not have an entry for ${bKey}.\nOrder specified: ${JSON.stringify(
                            order,
                            null,
                            2,
                        )}`,
                    );
                }
                if (aIndex < bIndex) {
                    return -1;
                }
                if (bIndex < aIndex) {
                    return 1;
                }
                return 0;
            });
            return Result.value(sorted);
        } catch (err) {
            return Result.error([err]);
        }
    };

    const uncurried = function(handler, purpose) {
        return {
            handler,
            purpose: constant(purpose),
        };
    };
    const curried = function(handler, purpose) {
        return {
            cHandler: handler,
            purpose: constant(purpose),
        };
    };
    const curryArgs = function(descHandler, extraArgs) {
        return curried(
            curry.apply(undefined, [descHandler.handler].concat(extraArgs)),
            descHandler.purpose(),
        );
    };
    const getCurried = function(descHandler) {
        return descHandler.cHandler;
    };

    const behaviourTuple = function(name, handler) {
        return {
            name: constant(name),
            handler: constant(handler),
        };
    };
    const nameToHandlers = function(behaviours, info) {
        const r = {};
        each(behaviours, function(behaviour) {
            r[behaviour.name()] = behaviour.handlers(info);
        });
        return r;
    };
    const groupByEvents = function(info, behaviours, base) {
        const behaviourEvents = {
            ...base,
            ...nameToHandlers(behaviours, info),
        };
        return byInnerKey(behaviourEvents, behaviourTuple);
    };
    const combine$1 = function(info, eventOrder, behaviours, base) {
        const byEventName = groupByEvents(info, behaviours, base);
        return combineGroups(byEventName, eventOrder);
    };
    const assemble = function(rawHandler) {
        const handler = read(rawHandler);
        return function(component, simulatedEvent) {
            const rest = [];
            for (let _i = 2; _i < arguments.length; _i++) {
                rest[_i - 2] = arguments[_i];
            }
            const args = [component, simulatedEvent].concat(rest);
            if (handler.abort.apply(undefined, args)) {
                simulatedEvent.stop();
            } else if (handler.can.apply(undefined, args)) {
                handler.run.apply(undefined, args);
            }
        };
    };
    const missingOrderError = function(eventName, tuples) {
        return Result.error([
            `The event (${eventName}) has more than one behaviour that listens to it.\nWhen this occurs, you must ` +
                `specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).\nThe behaviours that ` +
                `can trigger it are: ${JSON.stringify(
                    map(tuples, function(c) {
                        return c.name();
                    }),
                    null,
                    2,
                )}`,
        ]);
    };
    const fuse$1 = function(tuples, eventOrder, eventName) {
        const order = eventOrder[eventName];
        if (!order) {
            return missingOrderError(eventName, tuples);
        }
        return sortKeys(`Event: ${eventName}`, 'name', tuples, order).map(
            function(sortedTuples) {
                const handlers = map(sortedTuples, function(tuple) {
                    return tuple.handler();
                });
                return fuse(handlers);
            },
        );
    };
    var combineGroups = function(byEventName, eventOrder) {
        const r = mapToArray(byEventName, function(tuples, eventName) {
            const combined =
                tuples.length === 1
                    ? Result.value(tuples[0].handler())
                    : fuse$1(tuples, eventOrder, eventName);
            return combined.map(function(handler) {
                const assembled = assemble(handler);
                const purpose =
                    tuples.length > 1
                        ? filter(eventOrder[eventName], function(o) {
                              return exists(tuples, function(t) {
                                  return t.name() === o;
                              });
                          }).join(' > ')
                        : tuples[0].name();
                return wrap$1(eventName, uncurried(assembled, purpose));
            });
        });
        return consolidate(r, {});
    };

    const toInfo = function(spec) {
        return asRaw(
            'custom.definition',
            objOf([
                field(
                    'dom',
                    'dom',
                    strict(),
                    objOf([
                        strict$1('tag'),
                        defaulted$1('styles', {}),
                        defaulted$1('classes', []),
                        defaulted$1('attributes', {}),
                        option('value'),
                        option('innerHtml'),
                    ]),
                ),
                strict$1('components'),
                strict$1('uid'),
                defaulted$1('events', {}),
                defaulted$1('apis', {}),
                field(
                    'eventOrder',
                    'eventOrder',
                    mergeWith({
                        'alloy.execute': [
                            'disabling',
                            'alloy.base.behaviour',
                            'toggling',
                            'typeaheadevents',
                        ],
                        'alloy.focus': [
                            'alloy.base.behaviour',
                            'focusing',
                            'keying',
                        ],
                        'alloy.system.init': [
                            'alloy.base.behaviour',
                            'disabling',
                            'toggling',
                            'representing',
                        ],
                        input: [
                            'alloy.base.behaviour',
                            'representing',
                            'streaming',
                            'invalidating',
                        ],
                        'alloy.system.detached': [
                            'alloy.base.behaviour',
                            'representing',
                            'item-events',
                            'tooltipping',
                        ],
                        mousedown: [
                            'focusing',
                            'alloy.base.behaviour',
                            'item-type-events',
                        ],
                        touchstart: [
                            'focusing',
                            'alloy.base.behaviour',
                            'item-type-events',
                        ],
                        mouseover: ['item-type-events', 'tooltipping'],
                    }),
                    anyValue$1(),
                ),
                option('domModification'),
            ]),
            spec,
        );
    };
    const toDefinition = function(detail) {
        return {
            ...detail.dom,
            uid: detail.uid,
            domChildren: map(detail.components, function(comp) {
                return comp.element();
            }),
        };
    };
    const toModification = function(detail) {
        return detail.domModification.fold(function() {
            return nu$6({});
        }, nu$6);
    };
    const toEvents = function(info) {
        return info.events;
    };

    const read$2 = function(element, attr) {
        const value = get$2(element, attr);
        return value === undefined || value === '' ? [] : value.split(' ');
    };
    const add = function(element, attr, id) {
        const old = read$2(element, attr);
        const nu = old.concat([id]);
        set$1(element, attr, nu.join(' '));
        return true;
    };
    const remove$2 = function(element, attr, id) {
        const nu = filter(read$2(element, attr), function(v) {
            return v !== id;
        });
        if (nu.length > 0) {
            set$1(element, attr, nu.join(' '));
        } else {
            remove$1(element, attr);
        }
        return false;
    };

    const supports = function(element) {
        return element.dom().classList !== undefined;
    };
    const get$3 = function(element) {
        return read$2(element, 'class');
    };
    const add$1 = function(element, clazz) {
        return add(element, 'class', clazz);
    };
    const remove$3 = function(element, clazz) {
        return remove$2(element, 'class', clazz);
    };

    const add$2 = function(element, clazz) {
        if (supports(element)) {
            element.dom().classList.add(clazz);
        } else {
            add$1(element, clazz);
        }
    };
    const cleanClass = function(element) {
        const classList = supports(element)
            ? element.dom().classList
            : get$3(element);
        if (classList.length === 0) {
            remove$1(element, 'class');
        }
    };
    const remove$4 = function(element, clazz) {
        if (supports(element)) {
            const { classList } = element.dom();
            classList.remove(clazz);
        } else {
            remove$3(element, clazz);
        }
        cleanClass(element);
    };
    const has$2 = function(element, clazz) {
        return supports(element) && element.dom().classList.contains(clazz);
    };

    const add$3 = function(element, classes) {
        each(classes, function(x) {
            add$2(element, x);
        });
    };
    const remove$5 = function(element, classes) {
        each(classes, function(x) {
            remove$4(element, x);
        });
    };

    const isSupported = function(dom) {
        return (
            dom.style !== undefined && isFunction(dom.style.getPropertyValue)
        );
    };

    const internalSet = function(dom, property, value) {
        if (!isString(value)) {
            domGlobals.console.error(
                'Invalid call to CSS.set. Property ',
                property,
                ':: Value ',
                value,
                ':: Element ',
                dom,
            );
            throw new Error(`CSS value must be a string: ${value}`);
        }
        if (isSupported(dom)) {
            dom.style.setProperty(property, value);
        }
    };
    const internalRemove = function(dom, property) {
        if (isSupported(dom)) {
            dom.style.removeProperty(property);
        }
    };
    const set$2 = function(element, property, value) {
        const dom = element.dom();
        internalSet(dom, property, value);
    };
    const setAll$1 = function(element, css) {
        const dom = element.dom();
        each$1(css, function(v, k) {
            internalSet(dom, k, v);
        });
    };
    const setOptions = function(element, css) {
        const dom = element.dom();
        each$1(css, function(v, k) {
            v.fold(
                function() {
                    internalRemove(dom, k);
                },
                function(value) {
                    internalSet(dom, k, value);
                },
            );
        });
    };
    const get$4 = function(element, property) {
        const dom = element.dom();
        const styles = domGlobals.window.getComputedStyle(dom);
        const r = styles.getPropertyValue(property);
        const v =
            r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;
        return v === null ? undefined : v;
    };
    var getUnsafeProperty = function(dom, property) {
        return isSupported(dom) ? dom.style.getPropertyValue(property) : '';
    };
    const getRaw = function(element, property) {
        const dom = element.dom();
        const raw = getUnsafeProperty(dom, property);
        return Option.from(raw).filter(function(r) {
            return r.length > 0;
        });
    };
    const isValidValue = function(tag, property, value) {
        const element = Element.fromTag(tag);
        set$2(element, property, value);
        const style = getRaw(element, property);
        return style.isSome();
    };
    const remove$6 = function(element, property) {
        const dom = element.dom();
        internalRemove(dom, property);
        if (has$1(element, 'style') && trim(get$2(element, 'style')) === '') {
            remove$1(element, 'style');
        }
    };
    const reflow = function(e) {
        return e.dom().offsetWidth;
    };

    const get$5 = function(element) {
        return element.dom().value;
    };
    const set$3 = function(element, value) {
        if (value === undefined) {
            throw new Error('Value.set was undefined');
        }
        element.dom().value = value;
    };

    const renderToDom = function(definition) {
        const subject = Element.fromTag(definition.tag);
        setAll(subject, definition.attributes);
        add$3(subject, definition.classes);
        setAll$1(subject, definition.styles);
        definition.innerHtml.each(function(html) {
            return set(subject, html);
        });
        const children = definition.domChildren;
        append$1(subject, children);
        definition.value.each(function(value) {
            set$3(subject, value);
        });
        if (!definition.uid) {
            debugger;
        }
        writeOnly(subject, definition.uid);
        return subject;
    };

    const getBehaviours$1 = function(spec) {
        const behaviours = readOr$1('behaviours', {})(spec);
        const keys$1 = filter(keys(behaviours), function(k) {
            return behaviours[k] !== undefined;
        });
        return map(keys$1, function(k) {
            return behaviours[k].me;
        });
    };
    const generateFrom$1 = function(spec, all) {
        return generateFrom(spec, all);
    };
    const generate$3 = function(spec) {
        const all = getBehaviours$1(spec);
        return generateFrom$1(spec, all);
    };

    const getDomDefinition = function(info, bList, bData) {
        const definition = toDefinition(info);
        const infoModification = toModification(info);
        const baseModification = {
            'alloy.base.modification': infoModification,
        };
        const modification =
            bList.length > 0
                ? combine(bData, baseModification, bList, definition)
                : infoModification;
        return merge$1(definition, modification);
    };
    const getEvents = function(info, bList, bData) {
        const baseEvents = { 'alloy.base.behaviour': toEvents(info) };
        return combine$1(bData, info.eventOrder, bList, baseEvents).getOrDie();
    };
    const build = function(spec) {
        const getMe = function() {
            return me;
        };
        const systemApi = Cell(singleton);
        const info = getOrDie(toInfo(spec));
        const bBlob = generate$3(spec);
        const bList = getBehaviours(bBlob);
        const bData = getData(bBlob);
        const modDefinition = getDomDefinition(info, bList, bData);
        const item = renderToDom(modDefinition);
        const events = getEvents(info, bList, bData);
        const subcomponents = Cell(info.components);
        const connect = function(newApi) {
            systemApi.set(newApi);
        };
        const disconnect = function() {
            systemApi.set(NoContextApi(getMe));
        };
        const syncComponents = function() {
            const children$1 = children(item);
            const subs = bind(children$1, function(child) {
                return systemApi
                    .get()
                    .getByDom(child)
                    .fold(
                        function() {
                            return [];
                        },
                        function(c) {
                            return [c];
                        },
                    );
            });
            subcomponents.set(subs);
        };
        const config = function(behaviour) {
            const b = bData;
            const f = isFunction(b[behaviour.name()])
                ? b[behaviour.name()]
                : function() {
                      throw new Error(
                          `Could not find ${behaviour.name()} in ${JSON.stringify(
                              spec,
                              null,
                              2,
                          )}`,
                      );
                  };
            return f();
        };
        const hasConfigured = function(behaviour) {
            return isFunction(bData[behaviour.name()]);
        };
        const getApis = function() {
            return info.apis;
        };
        const readState = function(behaviourName) {
            return bData[behaviourName]()
                .map(function(b) {
                    return b.state.readState();
                })
                .getOr('not enabled');
        };
        var me = {
            getSystem: systemApi.get,
            config,
            hasConfigured,
            spec: constant(spec),
            readState,
            getApis,
            connect,
            disconnect,
            element: constant(item),
            syncComponents,
            components: subcomponents.get,
            events: constant(events),
        };
        return me;
    };

    const buildSubcomponents = function(spec) {
        const components = readOr$1('components', [])(spec);
        return map(components, build$1);
    };
    const buildFromSpec = function(userSpec) {
        const _a = make(userSpec);
        const specEvents = _a.events;
        const spec = __rest(_a, ['events']);
        const components = buildSubcomponents(spec);
        const completeSpec = {
            ...spec,
            events: { ...DefaultEvents, ...specEvents },
            components,
        };
        return Result.value(build(completeSpec));
    };
    const text = function(textContent) {
        const element = Element.fromText(textContent);
        return external({ element });
    };
    var external = function(spec) {
        const extSpec = asRawOrDie(
            'external.component',
            objOfOnly([strict$1('element'), option('uid')]),
            spec,
        );
        const systemApi = Cell(NoContextApi());
        const connect = function(newApi) {
            systemApi.set(newApi);
        };
        const disconnect = function() {
            systemApi.set(
                NoContextApi(function() {
                    return me;
                }),
            );
        };
        extSpec.uid.each(function(uid) {
            writeOnly(extSpec.element, uid);
        });
        var me = {
            getSystem: systemApi.get,
            config: Option.none,
            hasConfigured: constant(false),
            connect,
            disconnect,
            getApis() {
                return {};
            },
            element: constant(extSpec.element),
            spec: constant(spec),
            readState: constant('No state'),
            syncComponents: noop,
            components: constant([]),
            events: constant({}),
        };
        return premade(me);
    };
    const uids = generate$2;
    var build$1 = function(spec) {
        return getPremade(spec).fold(
            function() {
                const userSpecWithUid = spec.hasOwnProperty('uid')
                    ? spec
                    : { uid: uids(''), ...spec };
                return buildFromSpec(userSpecWithUid).getOrDie();
            },
            function(prebuilt) {
                return prebuilt;
            },
        );
    };
    const premade$1 = premade;

    function Dimension(name, getOffset) {
        const set = function(element, h) {
            if (!isNumber(h) && !h.match(/^[0-9]+$/)) {
                throw new Error(
                    `${name}.set accepts only positive integer values. Value was ${h}`,
                );
            }
            const dom = element.dom();
            if (isSupported(dom)) {
                dom.style[name] = `${h}px`;
            }
        };
        const get = function(element) {
            const r = getOffset(element);
            if (r <= 0 || r === null) {
                const css = get$4(element, name);
                return parseFloat(css) || 0;
            }
            return r;
        };
        const getOuter = get;
        const aggregate = function(element, properties) {
            return foldl(
                properties,
                function(acc, property) {
                    const val = get$4(element, property);
                    const value = val === undefined ? 0 : parseInt(val, 10);
                    return isNaN(value) ? acc : acc + value;
                },
                0,
            );
        };
        const max = function(element, value, properties) {
            const cumulativeInclusions = aggregate(element, properties);
            const absoluteMax =
                value > cumulativeInclusions ? value - cumulativeInclusions : 0;
            return absoluteMax;
        };
        return {
            set,
            get,
            getOuter,
            aggregate,
            max,
        };
    }

    const api = Dimension('height', function(element) {
        const dom = element.dom();
        return inBody(element)
            ? dom.getBoundingClientRect().height
            : dom.offsetHeight;
    });
    const get$6 = function(element) {
        return api.get(element);
    };
    const getOuter$1 = function(element) {
        return api.getOuter(element);
    };
    const setMax = function(element, value) {
        const inclusions = [
            'margin-top',
            'border-top-width',
            'padding-top',
            'padding-bottom',
            'border-bottom-width',
            'margin-bottom',
        ];
        const absMax = api.max(element, value, inclusions);
        set$2(element, 'max-height', `${absMax}px`);
    };

    var r = function(left, top) {
        const translate = function(x, y) {
            return r(left + x, top + y);
        };
        return {
            left: constant(left),
            top: constant(top),
            translate,
        };
    };
    const Position = r;

    const boxPosition = function(dom) {
        const box = dom.getBoundingClientRect();
        return Position(box.left, box.top);
    };
    const firstDefinedOrZero = function(a, b) {
        return a !== undefined ? a : b !== undefined ? b : 0;
    };
    const absolute = function(element) {
        const doc = element.dom().ownerDocument;
        const { body } = doc;
        const win = doc.defaultView;
        const html = doc.documentElement;
        if (body === element.dom()) {
            return Position(body.offsetLeft, body.offsetTop);
        }
        const scrollTop = firstDefinedOrZero(win.pageYOffset, html.scrollTop);
        const scrollLeft = firstDefinedOrZero(win.pageXOffset, html.scrollLeft);
        const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
        const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
        return viewport(element).translate(
            scrollLeft - clientLeft,
            scrollTop - clientTop,
        );
    };
    var viewport = function(element) {
        const dom = element.dom();
        const doc = dom.ownerDocument;
        const { body } = doc;
        if (body === dom) {
            return Position(body.offsetLeft, body.offsetTop);
        }
        if (!inBody(element)) {
            return Position(0, 0);
        }
        return boxPosition(dom);
    };

    const api$1 = Dimension('width', function(element) {
        return element.dom().offsetWidth;
    });
    const set$4 = function(element, h) {
        api$1.set(element, h);
    };
    const get$7 = function(element) {
        return api$1.get(element);
    };
    const getOuter$2 = function(element) {
        return api$1.getOuter(element);
    };
    const setMax$1 = function(element, value) {
        const inclusions = [
            'margin-left',
            'border-left-width',
            'padding-left',
            'padding-right',
            'border-right-width',
            'margin-right',
        ];
        const absMax = api$1.max(element, value, inclusions);
        set$2(element, 'max-width', `${absMax}px`);
    };

    const isSafari = detect$3().browser.isSafari();
    const get$8 = function(_DOC) {
        const doc = _DOC !== undefined ? _DOC.dom() : domGlobals.document;
        const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
        const y = doc.body.scrollTop || doc.documentElement.scrollTop;
        return Position(x, y);
    };

    const bounds = function(x, y, width, height) {
        return {
            x: constant(x),
            y: constant(y),
            width: constant(width),
            height: constant(height),
            right: constant(x + width),
            bottom: constant(y + height),
        };
    };
    const getBounds = function(_win) {
        const win = _win === undefined ? domGlobals.window : _win;
        const doc = win.document;
        const scroll = get$8(Element.fromDom(doc));
        const { visualViewport } = win;
        if (visualViewport !== undefined) {
            return bounds(
                Math.max(visualViewport.pageLeft, scroll.left()),
                Math.max(visualViewport.pageTop, scroll.top()),
                visualViewport.width,
                visualViewport.height,
            );
        }
        const html = doc.documentElement;
        const width = html.clientWidth;
        const height = html.clientHeight;
        return bounds(scroll.left(), scroll.top(), width, height);
    };

    var walkUp = function(navigation, doc) {
        const frame = navigation.view(doc);
        return frame.fold(constant([]), function(f) {
            const parent = navigation.owner(f);
            const rest = walkUp(navigation, parent);
            return [f].concat(rest);
        });
    };
    const pathTo = function(element, navigation) {
        const d = navigation.owner(element);
        const paths = walkUp(navigation, d);
        return Option.some(paths);
    };

    const view = function(doc) {
        const element =
            doc.dom() === domGlobals.document
                ? Option.none()
                : Option.from(doc.dom().defaultView.frameElement);
        return element.map(Element.fromDom);
    };
    const owner$1 = function(element) {
        return owner(element);
    };

    const Navigation = /* #__PURE__ */ Object.freeze({
        view,
        owner: owner$1,
    });

    const find$3 = function(element) {
        const doc = Element.fromDom(domGlobals.document);
        const scroll = get$8(doc);
        const path = pathTo(element, Navigation);
        return path.fold(curry(absolute, element), function(frames) {
            const offset = viewport(element);
            const r = foldr(
                frames,
                function(b, a) {
                    const loc = viewport(a);
                    return {
                        left: b.left + loc.left(),
                        top: b.top + loc.top(),
                    };
                },
                {
                    left: 0,
                    top: 0,
                },
            );
            return Position(
                r.left + offset.left() + scroll.left(),
                r.top + offset.top() + scroll.top(),
            );
        });
    };

    const pointed = Immutable('point', 'width', 'height');
    const rect = Immutable('x', 'y', 'width', 'height');
    const bounds$1 = function(x, y, width, height) {
        return {
            x: constant(x),
            y: constant(y),
            width: constant(width),
            height: constant(height),
            right: constant(x + width),
            bottom: constant(y + height),
        };
    };
    const box = function(element) {
        const xy = absolute(element);
        const w = getOuter$2(element);
        const h = getOuter$1(element);
        return bounds$1(xy.left(), xy.top(), w, h);
    };
    const absolute$1 = function(element) {
        const position = find$3(element);
        const width = getOuter$2(element);
        const height = getOuter$1(element);
        return bounds$1(position.left(), position.top(), width, height);
    };
    const win = function() {
        return getBounds(domGlobals.window);
    };

    const closest$2 = function(scope, predicate, isRoot) {
        return closest(scope, predicate, isRoot).isSome();
    };

    const ancestor$1 = function(scope, selector, isRoot) {
        return ancestor(
            scope,
            function(e) {
                return is(e, selector);
            },
            isRoot,
        );
    };
    const descendant$1 = function(scope, selector) {
        return one(selector, scope);
    };
    const closest$3 = function(scope, selector, isRoot) {
        return ClosestOrAncestor(is, ancestor$1, scope, selector, isRoot);
    };

    const find$4 = function(queryElem) {
        const dependent = closest(queryElem, function(elem) {
            if (!isElement(elem)) {
                return false;
            }
            const id = get$2(elem, 'id');
            return id !== undefined && id.indexOf('aria-owns') > -1;
        });
        return dependent.bind(function(dep) {
            const id = get$2(dep, 'id');
            const doc = owner(dep);
            return descendant$1(doc, `[aria-owns="${id}"]`);
        });
    };
    const manager = function() {
        const ariaId = generate$1('aria-owns');
        const link = function(elem) {
            set$1(elem, 'aria-owns', ariaId);
        };
        const unlink = function(elem) {
            remove$1(elem, 'aria-owns');
        };
        return {
            id: constant(ariaId),
            link,
            unlink,
        };
    };

    const isAriaPartOf = function(component, queryElem) {
        return find$4(queryElem).exists(function(owner) {
            return isPartOf(component, owner);
        });
    };
    var isPartOf = function(component, queryElem) {
        return (
            closest$2(
                queryElem,
                function(el) {
                    return eq(el, component.element());
                },
                constant(false),
            ) || isAriaPartOf(component, queryElem)
        );
    };

    const cat = function(arr) {
        const r = [];
        const push = function(x) {
            r.push(x);
        };
        for (let i = 0; i < arr.length; i++) {
            arr[i].each(push);
        }
        return r;
    };
    const sequence = function(arr) {
        const r = [];
        for (let i = 0; i < arr.length; i++) {
            const x = arr[i];
            if (x.isSome()) {
                r.push(x.getOrDie());
            } else {
                return Option.none();
            }
        }
        return Option.some(r);
    };
    const findMap = function(arr, f) {
        for (let i = 0; i < arr.length; i++) {
            const r = f(arr[i], i);
            if (r.isSome()) {
                return r;
            }
        }
        return Option.none();
    };
    const lift2 = function(oa, ob, f) {
        return oa.isSome() && ob.isSome()
            ? Option.some(f(oa.getOrDie(), ob.getOrDie()))
            : Option.none();
    };
    const lift3 = function(oa, ob, oc, f) {
        return oa.isSome() && ob.isSome() && oc.isSome()
            ? Option.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie()))
            : Option.none();
    };

    const unknown$3 = 'unknown';
    let EventConfiguration;
    (function(EventConfiguration) {
        EventConfiguration[(EventConfiguration.STOP = 0)] = 'STOP';
        EventConfiguration[(EventConfiguration.NORMAL = 1)] = 'NORMAL';
        EventConfiguration[(EventConfiguration.LOGGING = 2)] = 'LOGGING';
    })(EventConfiguration || (EventConfiguration = {}));
    const eventConfig = Cell({});
    const makeEventLogger = function(eventName, initialTarget) {
        const sequence = [];
        const startTime = new Date().getTime();
        return {
            logEventCut(name, target, purpose) {
                sequence.push({
                    outcome: 'cut',
                    target,
                    purpose,
                });
            },
            logEventStopped(name, target, purpose) {
                sequence.push({
                    outcome: 'stopped',
                    target,
                    purpose,
                });
            },
            logNoParent(name, target, purpose) {
                sequence.push({
                    outcome: 'no-parent',
                    target,
                    purpose,
                });
            },
            logEventNoHandlers(name, target) {
                sequence.push({
                    outcome: 'no-handlers-left',
                    target,
                });
            },
            logEventResponse(name, target, purpose) {
                sequence.push({
                    outcome: 'response',
                    purpose,
                    target,
                });
            },
            write() {
                const finishTime = new Date().getTime();
                if (
                    contains(
                        ['mousemove', 'mouseover', 'mouseout', systemInit()],
                        eventName,
                    )
                ) {
                    return;
                }
                domGlobals.console.log(eventName, {
                    event: eventName,
                    time: finishTime - startTime,
                    target: initialTarget.dom(),
                    sequence: map(sequence, function(s) {
                        if (
                            !contains(['cut', 'stopped', 'response'], s.outcome)
                        ) {
                            return s.outcome;
                        }
                        return `{${
                            s.purpose
                        }} ${s.outcome} at (${element(s.target)})`;
                    }),
                });
            },
        };
    };
    const processEvent = function(eventName, initialTarget, f) {
        const status = readOptFrom$1(eventConfig.get(), eventName)
            .orThunk(function() {
                const patterns = keys(eventConfig.get());
                return findMap(patterns, function(p) {
                    return eventName.indexOf(p) > -1
                        ? Option.some(eventConfig.get()[p])
                        : Option.none();
                });
            })
            .getOr(EventConfiguration.NORMAL);
        switch (status) {
            case EventConfiguration.NORMAL:
                return f(noLogger());
            case EventConfiguration.LOGGING: {
                const logger = makeEventLogger(eventName, initialTarget);
                const output = f(logger);
                logger.write();
                return output;
            }
            case EventConfiguration.STOP:
                return true;
        }
    };
    const path = ['alloy/data/Fields', 'alloy/debugging/Debugging'];
    const getTrace = function() {
        const err = new Error();
        if (err.stack !== undefined) {
            const lines = err.stack.split('\n');
            return find(lines, function(line) {
                return (
                    line.indexOf('alloy') > 0 &&
                    !exists(path, function(p) {
                        return line.indexOf(p) > -1;
                    })
                );
            }).getOr(unknown$3);
        }
        return unknown$3;
    };
    const ignoreEvent = {
        logEventCut: noop,
        logEventStopped: noop,
        logNoParent: noop,
        logEventNoHandlers: noop,
        logEventResponse: noop,
        write: noop,
    };
    const monitorEvent = function(eventName, initialTarget, f) {
        return processEvent(eventName, initialTarget, f);
    };
    var noLogger = constant(ignoreEvent);

    const menuFields = constant([strict$1('menu'), strict$1('selectedMenu')]);
    const itemFields = constant([strict$1('item'), strict$1('selectedItem')]);
    const schema = constant(objOf(itemFields().concat(menuFields())));
    const itemSchema = constant(objOf(itemFields()));

    const _initSize = strictObjOf('initSize', [
        strict$1('numColumns'),
        strict$1('numRows'),
    ]);
    const itemMarkers = function() {
        return strictOf('markers', itemSchema());
    };
    const tieredMenuMarkers = function() {
        return strictObjOf(
            'markers',
            [strict$1('backgroundMenu')]
                .concat(menuFields())
                .concat(itemFields()),
        );
    };
    const markers = function(required) {
        return strictObjOf('markers', map(required, strict$1));
    };
    const onPresenceHandler = function(label, fieldName, presence) {
        const trace = getTrace();
        return field(
            fieldName,
            fieldName,
            presence,
            valueOf(function(f) {
                return Result.value(function() {
                    const args = [];
                    for (let _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return f.apply(undefined, args);
                });
            }),
        );
    };
    const onHandler = function(fieldName) {
        return onPresenceHandler('onHandler', fieldName, defaulted(noop));
    };
    const onKeyboardHandler = function(fieldName) {
        return onPresenceHandler(
            'onKeyboardHandler',
            fieldName,
            defaulted(Option.none),
        );
    };
    const onStrictHandler = function(fieldName) {
        return onPresenceHandler('onHandler', fieldName, strict());
    };
    const onStrictKeyboardHandler = function(fieldName) {
        return onPresenceHandler('onKeyboardHandler', fieldName, strict());
    };
    const output = function(name, value) {
        return state$1(name, constant(value));
    };
    const snapshot = function(name) {
        return state$1(name, identity);
    };
    const initSize = constant(_initSize);

    const nu$7 = Immutable('x', 'y', 'bubble', 'direction', 'label');

    const adt$2 = Adt.generate([
        { southeast: [] },
        { southwest: [] },
        { northeast: [] },
        { northwest: [] },
        { south: [] },
        { north: [] },
        { east: [] },
        { west: [] },
    ]);
    const cata = function(
        subject,
        southeast,
        southwest,
        northeast,
        northwest,
        south,
        north,
        east,
        west,
    ) {
        return subject.fold(
            southeast,
            southwest,
            northeast,
            northwest,
            south,
            north,
            east,
            west,
        );
    };
    const cataVertical = function(subject, south, middle, north) {
        return subject.fold(
            south,
            south,
            north,
            north,
            south,
            north,
            middle,
            middle,
        );
    };
    const cataHorizontal = function(subject, east, middle, west) {
        return subject.fold(east, west, east, west, middle, middle, east, west);
    };
    const { southeast } = adt$2;
    const { southwest } = adt$2;
    const { northeast } = adt$2;
    const { northwest } = adt$2;
    const { south } = adt$2;
    const { north } = adt$2;
    const { east } = adt$2;
    const { west } = adt$2;

    const eastX = function(anchor) {
        return anchor.x();
    };
    const middleX = function(anchor, element) {
        return anchor.x() + anchor.width() / 2 - element.width() / 2;
    };
    const westX = function(anchor, element) {
        return anchor.x() + anchor.width() - element.width();
    };
    const northY = function(anchor, element) {
        return anchor.y() - element.height();
    };
    const southY = function(anchor) {
        return anchor.y() + anchor.height();
    };
    const centreY = function(anchor, element) {
        return anchor.y() + anchor.height() / 2 - element.height() / 2;
    };
    const eastEdgeX = function(anchor) {
        return anchor.x() + anchor.width();
    };
    const westEdgeX = function(anchor, element) {
        return anchor.x() - element.width();
    };
    const southeast$1 = function(anchor, element, bubbles) {
        return nu$7(
            eastX(anchor),
            southY(anchor),
            bubbles.southeast(),
            southeast(),
            'layout-se',
        );
    };
    const southwest$1 = function(anchor, element, bubbles) {
        return nu$7(
            westX(anchor, element),
            southY(anchor),
            bubbles.southwest(),
            southwest(),
            'layout-sw',
        );
    };
    const northeast$1 = function(anchor, element, bubbles) {
        return nu$7(
            eastX(anchor),
            northY(anchor, element),
            bubbles.northeast(),
            northeast(),
            'layout-ne',
        );
    };
    const northwest$1 = function(anchor, element, bubbles) {
        return nu$7(
            westX(anchor, element),
            northY(anchor, element),
            bubbles.northwest(),
            northwest(),
            'layout-nw',
        );
    };
    const north$1 = function(anchor, element, bubbles) {
        return nu$7(
            middleX(anchor, element),
            northY(anchor, element),
            bubbles.north(),
            north(),
            'layout-n',
        );
    };
    const south$1 = function(anchor, element, bubbles) {
        return nu$7(
            middleX(anchor, element),
            southY(anchor),
            bubbles.south(),
            south(),
            'layout-s',
        );
    };
    const east$1 = function(anchor, element, bubbles) {
        return nu$7(
            eastEdgeX(anchor),
            centreY(anchor, element),
            bubbles.east(),
            east(),
            'layout-e',
        );
    };
    const west$1 = function(anchor, element, bubbles) {
        return nu$7(
            westEdgeX(anchor, element),
            centreY(anchor, element),
            bubbles.west(),
            west(),
            'layout-w',
        );
    };
    const all$2 = function() {
        return [
            southeast$1,
            southwest$1,
            northeast$1,
            northwest$1,
            south$1,
            north$1,
            east$1,
            west$1,
        ];
    };
    const allRtl = function() {
        return [
            southwest$1,
            southeast$1,
            northwest$1,
            northeast$1,
            south$1,
            north$1,
            east$1,
            west$1,
        ];
    };
    const belowOrAbove = function() {
        return [
            southeast$1,
            southwest$1,
            northeast$1,
            northwest$1,
            south$1,
            north$1,
        ];
    };
    const belowOrAboveRtl = function() {
        return [
            southwest$1,
            southeast$1,
            northwest$1,
            northeast$1,
            south$1,
            north$1,
        ];
    };

    const executeEvent = function(bConfig, bState, executor) {
        return runOnExecute(function(component) {
            executor(component, bConfig, bState);
        });
    };
    const loadEvent = function(bConfig, bState, f) {
        return runOnInit(function(component, simulatedEvent) {
            f(component, bConfig, bState);
        });
    };
    const create = function(schema, name, active, apis, extra, state) {
        const configSchema = objOfOnly(schema);
        const schemaSchema = optionObjOf(name, [
            optionObjOfOnly('config', schema),
        ]);
        return doCreate(
            configSchema,
            schemaSchema,
            name,
            active,
            apis,
            extra,
            state,
        );
    };
    const createModes = function(modes, name, active, apis, extra, state) {
        const configSchema = modes;
        const schemaSchema = optionObjOf(name, [optionOf('config', modes)]);
        return doCreate(
            configSchema,
            schemaSchema,
            name,
            active,
            apis,
            extra,
            state,
        );
    };
    const wrapApi = function(bName, apiFunction, apiName) {
        const f = function(component) {
            const rest = [];
            for (let _i = 1; _i < arguments.length; _i++) {
                rest[_i - 1] = arguments[_i];
            }
            const args = [component].concat(rest);
            return component.config({ name: constant(bName) }).fold(
                function() {
                    throw new Error(
                        `We could not find any behaviour configuration for: ${bName}. Using API: ${apiName}`,
                    );
                },
                function(info) {
                    const rest = Array.prototype.slice.call(args, 1);
                    return apiFunction.apply(
                        undefined,
                        [component, info.config, info.state].concat(rest),
                    );
                },
            );
        };
        return markAsBehaviourApi(f, apiName, apiFunction);
    };
    const revokeBehaviour = function(name) {
        return {
            key: name,
            value: undefined,
        };
    };
    var doCreate = function(
        configSchema,
        schemaSchema,
        name,
        active,
        apis,
        extra,
        state,
    ) {
        const getConfig = function(info) {
            return hasKey$1(info, name) ? info[name]() : Option.none();
        };
        const wrappedApis = map$1(apis, function(apiF, apiName) {
            return wrapApi(name, apiF, apiName);
        });
        const wrappedExtra = map$1(extra, function(extraF, extraName) {
            return markAsExtraApi(extraF, extraName);
        });
        var me = {
            ...wrappedExtra,
            ...wrappedApis,
            revoke: curry(revokeBehaviour, name),
            config(spec) {
                const prepared = asRawOrDie(
                    `${name}-config`,
                    configSchema,
                    spec,
                );
                return {
                    key: name,
                    value: {
                        config: prepared,
                        me,
                        configAsRaw: cached(function() {
                            return asRawOrDie(
                                `${name}-config`,
                                configSchema,
                                spec,
                            );
                        }),
                        initialConfig: spec,
                        state,
                    },
                };
            },
            schema() {
                return schemaSchema;
            },
            exhibit(info, base) {
                return getConfig(info)
                    .bind(function(behaviourInfo) {
                        return readOptFrom$1(active, 'exhibit').map(function(
                            exhibitor,
                        ) {
                            return exhibitor(
                                base,
                                behaviourInfo.config,
                                behaviourInfo.state,
                            );
                        });
                    })
                    .getOr(nu$6({}));
            },
            name() {
                return name;
            },
            handlers(info) {
                return getConfig(info)
                    .map(function(behaviourInfo) {
                        const getEvents = readOr$1('events', function(a, b) {
                            return {};
                        })(active);
                        return getEvents(
                            behaviourInfo.config,
                            behaviourInfo.state,
                        );
                    })
                    .getOr({});
            },
        };
        return me;
    };

    const derive$1 = function(capabilities) {
        return wrapAll$1(capabilities);
    };
    const simpleSchema = objOfOnly([
        strict$1('fields'),
        strict$1('name'),
        defaulted$1('active', {}),
        defaulted$1('apis', {}),
        defaulted$1('state', NoState),
        defaulted$1('extra', {}),
    ]);
    const create$1 = function(data) {
        const value = asRawOrDie(
            `Creating behaviour: ${data.name}`,
            simpleSchema,
            data,
        );
        return create(
            value.fields,
            value.name,
            value.active,
            value.apis,
            value.extra,
            value.state,
        );
    };
    const modeSchema = objOfOnly([
        strict$1('branchKey'),
        strict$1('branches'),
        strict$1('name'),
        defaulted$1('active', {}),
        defaulted$1('apis', {}),
        defaulted$1('state', NoState),
        defaulted$1('extra', {}),
    ]);
    const createModes$1 = function(data) {
        const value = asRawOrDie(
            `Creating behaviour: ${data.name}`,
            modeSchema,
            data,
        );
        return createModes(
            choose$1(value.branchKey, value.branches),
            value.name,
            value.active,
            value.apis,
            value.extra,
            value.state,
        );
    };
    const revoke = constant(undefined);

    const chooseChannels = function(channels, message) {
        return message.universal()
            ? channels
            : filter(channels, function(ch) {
                  return contains(message.channels(), ch);
              });
    };
    const events$1 = function(receiveConfig) {
        return derive([
            run(receive(), function(component, message) {
                const channelMap = receiveConfig.channels;
                const channels = keys(channelMap);
                const targetChannels = chooseChannels(channels, message);
                each(targetChannels, function(ch) {
                    const channelInfo = channelMap[ch];
                    const channelSchema = channelInfo.schema;
                    const data = asRawOrDie(
                        `channel[${ch}] data\nReceiver: ${element(
                            component.element(),
                        )}`,
                        channelSchema,
                        message.data(),
                    );
                    channelInfo.onReceive(component, data);
                });
            }),
        ]);
    };

    const ActiveReceiving = /* #__PURE__ */ Object.freeze({
        events: events$1,
    });

    const ReceivingSchema = [
        strictOf(
            'channels',
            setOf$1(
                Result.value,
                objOfOnly([
                    onStrictHandler('onReceive'),
                    defaulted$1('schema', anyValue$1()),
                ]),
            ),
        ),
    ];

    const Receiving = create$1({
        fields: ReceivingSchema,
        name: 'receiving',
        active: ActiveReceiving,
    });

    const exhibit = function(base, posConfig) {
        return nu$6({
            classes: [],
            styles: posConfig.useFixed() ? {} : { position: 'relative' },
        });
    };

    const ActivePosition = /* #__PURE__ */ Object.freeze({
        exhibit,
    });

    const focus$1 = function(element) {
        element.dom().focus();
    };
    const blur = function(element) {
        element.dom().blur();
    };
    const hasFocus = function(element) {
        const doc = owner(element).dom();
        return element.dom() === doc.activeElement;
    };
    const active = function(_doc) {
        const doc = _doc !== undefined ? _doc.dom() : domGlobals.document;
        return Option.from(doc.activeElement).map(Element.fromDom);
    };
    const search = function(element) {
        return active(owner(element)).filter(function(e) {
            return element.dom().contains(e.dom());
        });
    };

    const preserve = function(f, container) {
        const ownerDoc = owner(container);
        const refocus = active(ownerDoc).bind(function(focused) {
            const hasFocus = function(elem) {
                return eq(focused, elem);
            };
            return hasFocus(container)
                ? Option.some(container)
                : descendant(container, hasFocus);
        });
        const result = f(container);
        refocus.each(function(oldFocus) {
            active(ownerDoc)
                .filter(function(newFocus) {
                    return eq(newFocus, oldFocus);
                })
                .fold(function() {
                    focus$1(oldFocus);
                }, noop);
        });
        return result;
    };

    const allAlignments = [
        'valignCentre',
        'alignLeft',
        'alignRight',
        'alignCentre',
        'top',
        'bottom',
        'left',
        'right',
    ];
    const nu$8 = function(width, yoffset, classes) {
        const getClasses = function(prop) {
            return readOptFrom$1(classes, prop).getOr([]);
        };
        const make = function(xDelta, yDelta, alignmentsOn) {
            const alignmentsOff = difference(allAlignments, alignmentsOn);
            return {
                offset() {
                    return Position(xDelta, yDelta);
                },
                classesOn() {
                    return bind(alignmentsOn, getClasses);
                },
                classesOff() {
                    return bind(alignmentsOff, getClasses);
                },
            };
        };
        return {
            southeast() {
                return make(-width, yoffset, ['top', 'alignLeft']);
            },
            southwest() {
                return make(width, yoffset, ['top', 'alignRight']);
            },
            south() {
                return make(-width / 2, yoffset, ['top', 'alignCentre']);
            },
            northeast() {
                return make(-width, -yoffset, ['bottom', 'alignLeft']);
            },
            northwest() {
                return make(width, -yoffset, ['bottom', 'alignRight']);
            },
            north() {
                return make(-width / 2, -yoffset, ['bottom', 'alignCentre']);
            },
            east() {
                return make(width, -yoffset / 2, ['valignCentre', 'left']);
            },
            west() {
                return make(-width, -yoffset / 2, ['valignCentre', 'right']);
            },
            innerNorthwest() {
                return make(-width, yoffset, ['top', 'alignRight']);
            },
            innerNortheast() {
                return make(width, yoffset, ['top', 'alignLeft']);
            },
            innerNorth() {
                return make(-width / 2, yoffset, ['top', 'alignCentre']);
            },
            innerSouthwest() {
                return make(-width, -yoffset, ['bottom', 'alignRight']);
            },
            innerSoutheast() {
                return make(width, -yoffset, ['bottom', 'alignLeft']);
            },
            innerSouth() {
                return make(-width / 2, -yoffset, ['bottom', 'alignCentre']);
            },
            innerWest() {
                return make(width, -yoffset / 2, ['valignCentre', 'right']);
            },
            innerEast() {
                return make(-width, -yoffset / 2, ['valignCentre', 'left']);
            },
        };
    };
    const fallback = function() {
        return nu$8(0, 0, {});
    };

    const decision = MixedBag(
        [
            'x',
            'y',
            'width',
            'height',
            'maxHeight',
            'maxWidth',
            'direction',
            'classes',
            'label',
            'candidateYforTest',
        ],
        [],
    );
    const css = Immutable('position', 'left', 'top', 'right', 'bottom');

    const adt$3 = Adt.generate([
        { none: [] },
        {
            relative: ['x', 'y', 'width', 'height'],
        },
        {
            fixed: ['x', 'y', 'width', 'height'],
        },
    ]);
    const positionWithDirection = function(
        posName,
        decision,
        x,
        y,
        width,
        height,
    ) {
        const decisionX = decision.x() - x;
        const decisionY = decision.y() - y;
        const decisionWidth = decision.width();
        const decisionHeight = decision.height();
        const decisionRight = width - (decisionX + decisionWidth);
        const decisionBottom = height - (decisionY + decisionHeight);
        const left = Option.some(decisionX);
        const top = Option.some(decisionY);
        const right = Option.some(decisionRight);
        const bottom = Option.some(decisionBottom);
        const none = Option.none();
        return cata(
            decision.direction(),
            function() {
                return css(posName, left, top, none, none);
            },
            function() {
                return css(posName, none, top, right, none);
            },
            function() {
                return css(posName, left, none, none, bottom);
            },
            function() {
                return css(posName, none, none, right, bottom);
            },
            function() {
                return css(posName, left, top, none, none);
            },
            function() {
                return css(posName, left, none, none, bottom);
            },
            function() {
                return css(posName, left, top, none, none);
            },
            function() {
                return css(posName, none, top, right, none);
            },
        );
    };
    const reposition = function(origin, decision) {
        return origin.fold(
            function() {
                return css(
                    'absolute',
                    Option.some(decision.x()),
                    Option.some(decision.y()),
                    Option.none(),
                    Option.none(),
                );
            },
            function(x, y, width, height) {
                return positionWithDirection(
                    'absolute',
                    decision,
                    x,
                    y,
                    width,
                    height,
                );
            },
            function(x, y, width, height) {
                return positionWithDirection(
                    'fixed',
                    decision,
                    x,
                    y,
                    width,
                    height,
                );
            },
        );
    };
    const toBox = function(origin, element) {
        const rel = curry(find$3, element);
        const position = origin.fold(rel, rel, function() {
            const scroll = get$8();
            return find$3(element).translate(-scroll.left(), -scroll.top());
        });
        const width = getOuter$2(element);
        const height = getOuter$1(element);
        return bounds$1(position.left(), position.top(), width, height);
    };
    const viewport$1 = function(origin, getBounds) {
        return getBounds.fold(
            function() {
                return origin.fold(win, win, bounds$1);
            },
            function(b) {
                return origin.fold(b, b, function() {
                    const bounds = b();
                    const pos = translate(origin, bounds.x(), bounds.y());
                    return bounds$1(
                        pos.left(),
                        pos.top(),
                        bounds.width(),
                        bounds.height(),
                    );
                });
            },
        );
    };
    var translate = function(origin, x, y) {
        const pos = Position(x, y);
        const removeScroll = function() {
            const outerScroll = get$8();
            return pos.translate(-outerScroll.left(), -outerScroll.top());
        };
        return origin.fold(constant(pos), constant(pos), removeScroll);
    };
    const cata$1 = function(subject, onNone, onRelative, onFixed) {
        return subject.fold(onNone, onRelative, onFixed);
    };
    const { relative } = adt$3;
    const { fixed } = adt$3;

    const nu$9 = function(x) {
        return x;
    };

    const onDirection = function(isLtr, isRtl) {
        return function(element) {
            return getDirection(element) === 'rtl' ? isRtl : isLtr;
        };
    };
    var getDirection = function(element) {
        return get$4(element, 'direction') === 'rtl' ? 'rtl' : 'ltr';
    };

    const schema$1 = function() {
        return optionObjOf('layouts', [strict$1('onLtr'), strict$1('onRtl')]);
    };
    const get$9 = function(elem, info, defaultLtr, defaultRtl) {
        const ltr = info.layouts
            .map(function(ls) {
                return ls.onLtr(elem);
            })
            .getOr(defaultLtr);
        const rtl = info.layouts
            .map(function(ls) {
                return ls.onRtl(elem);
            })
            .getOr(defaultRtl);
        const f = onDirection(ltr, rtl);
        return f(elem);
    };

    const placement = function(component, anchorInfo, origin) {
        const { hotspot } = anchorInfo;
        const anchorBox = toBox(origin, hotspot.element());
        const layouts = get$9(
            component.element(),
            anchorInfo,
            belowOrAbove(),
            belowOrAboveRtl(),
        );
        return Option.some(
            nu$9({
                anchorBox,
                bubble: anchorInfo.bubble.getOr(fallback()),
                overrides: anchorInfo.overrides,
                layouts,
                placer: Option.none(),
            }),
        );
    };
    const HotspotAnchor = [
        strict$1('hotspot'),
        option('bubble'),
        defaulted$1('overrides', {}),
        schema$1(),
        output('placement', placement),
    ];

    const placement$1 = function(component, anchorInfo, origin) {
        const pos = translate(origin, anchorInfo.x, anchorInfo.y);
        const anchorBox = bounds$1(
            pos.left(),
            pos.top(),
            anchorInfo.width,
            anchorInfo.height,
        );
        const layouts = get$9(
            component.element(),
            anchorInfo,
            all$2(),
            allRtl(),
        );
        return Option.some(
            nu$9({
                anchorBox,
                bubble: anchorInfo.bubble,
                overrides: anchorInfo.overrides,
                layouts,
                placer: Option.none(),
            }),
        );
    };
    const MakeshiftAnchor = [
        strict$1('x'),
        strict$1('y'),
        defaulted$1('height', 0),
        defaulted$1('width', 0),
        defaulted$1('bubble', fallback()),
        defaulted$1('overrides', {}),
        schema$1(),
        output('placement', placement$1),
    ];

    const zeroWidth = function() {
        return '\uFEFF';
    };

    const create$2 = Immutable('start', 'soffset', 'finish', 'foffset');
    const SimRange = { create: create$2 };

    const adt$4 = Adt.generate([
        { before: ['element'] },
        {
            on: ['element', 'offset'],
        },
        { after: ['element'] },
    ]);
    const cata$2 = function(subject, onBefore, onOn, onAfter) {
        return subject.fold(onBefore, onOn, onAfter);
    };
    const getStart = function(situ) {
        return situ.fold(identity, identity, identity);
    };
    const before$2 = adt$4.before;
    const { on } = adt$4;
    const after$1 = adt$4.after;
    const Situ = {
        before: before$2,
        on,
        after: after$1,
        cata: cata$2,
        getStart,
    };

    const adt$5 = Adt.generate([
        { domRange: ['rng'] },
        {
            relative: ['startSitu', 'finishSitu'],
        },
        {
            exact: ['start', 'soffset', 'finish', 'foffset'],
        },
    ]);
    const exactFromRange = function(simRange) {
        return adt$5.exact(
            simRange.start(),
            simRange.soffset(),
            simRange.finish(),
            simRange.foffset(),
        );
    };
    const getStart$1 = function(selection) {
        return selection.match({
            domRange(rng) {
                return Element.fromDom(rng.startContainer);
            },
            relative(startSitu, finishSitu) {
                return Situ.getStart(startSitu);
            },
            exact(start, soffset, finish, foffset) {
                return start;
            },
        });
    };
    const { domRange } = adt$5;
    const relative$1 = adt$5.relative;
    const { exact } = adt$5;
    const getWin = function(selection) {
        const start = getStart$1(selection);
        return defaultView(start);
    };
    const range$1 = SimRange.create;
    const Selection = {
        domRange,
        relative: relative$1,
        exact,
        exactFromRange,
        getWin,
        range: range$1,
    };

    const setStart = function(rng, situ) {
        situ.fold(
            function(e) {
                rng.setStartBefore(e.dom());
            },
            function(e, o) {
                rng.setStart(e.dom(), o);
            },
            function(e) {
                rng.setStartAfter(e.dom());
            },
        );
    };
    const setFinish = function(rng, situ) {
        situ.fold(
            function(e) {
                rng.setEndBefore(e.dom());
            },
            function(e, o) {
                rng.setEnd(e.dom(), o);
            },
            function(e) {
                rng.setEndAfter(e.dom());
            },
        );
    };
    const relativeToNative = function(win, startSitu, finishSitu) {
        const range = win.document.createRange();
        setStart(range, startSitu);
        setFinish(range, finishSitu);
        return range;
    };
    const exactToNative = function(win, start, soffset, finish, foffset) {
        const rng = win.document.createRange();
        rng.setStart(start.dom(), soffset);
        rng.setEnd(finish.dom(), foffset);
        return rng;
    };
    const toRect = function(rect) {
        return {
            left: constant(rect.left),
            top: constant(rect.top),
            right: constant(rect.right),
            bottom: constant(rect.bottom),
            width: constant(rect.width),
            height: constant(rect.height),
        };
    };
    const getFirstRect = function(rng) {
        const rects = rng.getClientRects();
        const rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();
        return rect.width > 0 || rect.height > 0
            ? Option.some(rect).map(toRect)
            : Option.none();
    };

    const adt$6 = Adt.generate([
        {
            ltr: ['start', 'soffset', 'finish', 'foffset'],
        },
        {
            rtl: ['start', 'soffset', 'finish', 'foffset'],
        },
    ]);
    const fromRange = function(win, type, range) {
        return type(
            Element.fromDom(range.startContainer),
            range.startOffset,
            Element.fromDom(range.endContainer),
            range.endOffset,
        );
    };
    const getRanges = function(win, selection) {
        return selection.match({
            domRange(rng) {
                return {
                    ltr: constant(rng),
                    rtl: Option.none,
                };
            },
            relative(startSitu, finishSitu) {
                return {
                    ltr: cached(function() {
                        return relativeToNative(win, startSitu, finishSitu);
                    }),
                    rtl: cached(function() {
                        return Option.some(
                            relativeToNative(win, finishSitu, startSitu),
                        );
                    }),
                };
            },
            exact(start, soffset, finish, foffset) {
                return {
                    ltr: cached(function() {
                        return exactToNative(
                            win,
                            start,
                            soffset,
                            finish,
                            foffset,
                        );
                    }),
                    rtl: cached(function() {
                        return Option.some(
                            exactToNative(win, finish, foffset, start, soffset),
                        );
                    }),
                };
            },
        });
    };
    const doDiagnose = function(win, ranges) {
        const rng = ranges.ltr();
        if (rng.collapsed) {
            const reversed = ranges.rtl().filter(function(rev) {
                return rev.collapsed === false;
            });
            return reversed
                .map(function(rev) {
                    return adt$6.rtl(
                        Element.fromDom(rev.endContainer),
                        rev.endOffset,
                        Element.fromDom(rev.startContainer),
                        rev.startOffset,
                    );
                })
                .getOrThunk(function() {
                    return fromRange(win, adt$6.ltr, rng);
                });
        }
        return fromRange(win, adt$6.ltr, rng);
    };
    const diagnose = function(win, selection) {
        const ranges = getRanges(win, selection);
        return doDiagnose(win, ranges);
    };
    const asLtrRange = function(win, selection) {
        const diagnosis = diagnose(win, selection);
        return diagnosis.match({
            ltr(start, soffset, finish, foffset) {
                const rng = win.document.createRange();
                rng.setStart(start.dom(), soffset);
                rng.setEnd(finish.dom(), foffset);
                return rng;
            },
            rtl(start, soffset, finish, foffset) {
                const rng = win.document.createRange();
                rng.setStart(finish.dom(), foffset);
                rng.setEnd(start.dom(), soffset);
                return rng;
            },
        });
    };

    const searchForPoint = function(rectForOffset, x, y, maxX, length) {
        if (length === 0) {
            return 0;
        }
        if (x === maxX) {
            return length - 1;
        }
        let xDelta = maxX;
        for (let i = 1; i < length; i++) {
            const rect = rectForOffset(i);
            const curDeltaX = Math.abs(x - rect.left);
            if (y <= rect.bottom) {
                if (y < rect.top || curDeltaX > xDelta) {
                    return i - 1;
                }
                xDelta = curDeltaX;
            }
        }
        return 0;
    };
    const inRect = function(rect, x, y) {
        return (
            x >= rect.left &&
            x <= rect.right &&
            y >= rect.top &&
            y <= rect.bottom
        );
    };

    function NodeValue(is, name) {
        const get = function(element) {
            if (!is(element)) {
                throw new Error(`Can only get ${name} value of a ${name} node`);
            }
            return getOption(element).getOr('');
        };
        var getOption = function(element) {
            return is(element)
                ? Option.from(element.dom().nodeValue)
                : Option.none();
        };
        const set = function(element, value) {
            if (!is(element)) {
                throw new Error(
                    `Can only set raw ${name} value of a ${name} node`,
                );
            }
            element.dom().nodeValue = value;
        };
        return {
            get,
            getOption,
            set,
        };
    }

    const api$2 = NodeValue(isText, 'text');
    const get$a = function(element) {
        return api$2.get(element);
    };
    const getOption = function(element) {
        return api$2.getOption(element);
    };

    const locateOffset = function(doc, textnode, x, y, rect) {
        const rangeForOffset = function(o) {
            const r = doc.dom().createRange();
            r.setStart(textnode.dom(), o);
            r.collapse(true);
            return r;
        };
        const rectForOffset = function(o) {
            const r = rangeForOffset(o);
            return r.getBoundingClientRect();
        };
        const { length } = get$a(textnode);
        const offset = searchForPoint(rectForOffset, x, y, rect.right, length);
        return rangeForOffset(offset);
    };
    const locate = function(doc, node, x, y) {
        const r = doc.dom().createRange();
        r.selectNode(node.dom());
        const rects = r.getClientRects();
        const foundRect = findMap(rects, function(rect) {
            return inRect(rect, x, y) ? Option.some(rect) : Option.none();
        });
        return foundRect.map(function(rect) {
            return locateOffset(doc, node, x, y, rect);
        });
    };

    const searchInChildren = function(doc, node, x, y) {
        const r = doc.dom().createRange();
        const nodes = children(node);
        return findMap(nodes, function(n) {
            r.selectNode(n.dom());
            return inRect(r.getBoundingClientRect(), x, y)
                ? locateNode(doc, n, x, y)
                : Option.none();
        });
    };
    var locateNode = function(doc, node, x, y) {
        return isText(node)
            ? locate(doc, node, x, y)
            : searchInChildren(doc, node, x, y);
    };
    const locate$1 = function(doc, node, x, y) {
        const r = doc.dom().createRange();
        r.selectNode(node.dom());
        const rect = r.getBoundingClientRect();
        const boundedX = Math.max(rect.left, Math.min(rect.right, x));
        const boundedY = Math.max(rect.top, Math.min(rect.bottom, y));
        return locateNode(doc, node, boundedX, boundedY);
    };

    const getEnd = function(element) {
        return name(element) === 'img'
            ? 1
            : getOption(element).fold(
                  function() {
                      return children(element).length;
                  },
                  function(v) {
                      return v.length;
                  },
              );
    };
    const NBSP = '\xA0';
    const isTextNodeWithCursorPosition = function(el) {
        return getOption(el)
            .filter(function(text) {
                return text.trim().length !== 0 || text.indexOf(NBSP) > -1;
            })
            .isSome();
    };
    const elementsWithCursorPosition = ['img', 'br'];
    const isCursorPosition = function(elem) {
        const hasCursorPosition = isTextNodeWithCursorPosition(elem);
        return (
            hasCursorPosition ||
            contains(elementsWithCursorPosition, name(elem))
        );
    };

    const first = function(element) {
        return descendant(element, isCursorPosition);
    };
    const last$1 = function(element) {
        return descendantRtl(element, isCursorPosition);
    };
    var descendantRtl = function(scope, predicate) {
        var descend = function(element) {
            const children$1 = children(element);
            for (let i = children$1.length - 1; i >= 0; i--) {
                const child = children$1[i];
                if (predicate(child)) {
                    return Option.some(child);
                }
                const res = descend(child);
                if (res.isSome()) {
                    return res;
                }
            }
            return Option.none();
        };
        return descend(scope);
    };

    const COLLAPSE_TO_LEFT = true;
    const COLLAPSE_TO_RIGHT = false;
    const getCollapseDirection = function(rect, x) {
        return x - rect.left < rect.right - x
            ? COLLAPSE_TO_LEFT
            : COLLAPSE_TO_RIGHT;
    };
    const createCollapsedNode = function(doc, target, collapseDirection) {
        const r = doc.dom().createRange();
        r.selectNode(target.dom());
        r.collapse(collapseDirection);
        return r;
    };
    const locateInElement = function(doc, node, x) {
        const cursorRange = doc.dom().createRange();
        cursorRange.selectNode(node.dom());
        const rect = cursorRange.getBoundingClientRect();
        const collapseDirection = getCollapseDirection(rect, x);
        const f = collapseDirection === COLLAPSE_TO_LEFT ? first : last$1;
        return f(node).map(function(target) {
            return createCollapsedNode(doc, target, collapseDirection);
        });
    };
    const locateInEmpty = function(doc, node, x) {
        const rect = node.dom().getBoundingClientRect();
        const collapseDirection = getCollapseDirection(rect, x);
        return Option.some(createCollapsedNode(doc, node, collapseDirection));
    };
    const search$1 = function(doc, node, x) {
        const f = children(node).length === 0 ? locateInEmpty : locateInElement;
        return f(doc, node, x);
    };

    const caretPositionFromPoint = function(doc, x, y) {
        return Option.from(doc.dom().caretPositionFromPoint(x, y)).bind(
            function(pos) {
                if (pos.offsetNode === null) {
                    return Option.none();
                }
                const r = doc.dom().createRange();
                r.setStart(pos.offsetNode, pos.offset);
                r.collapse();
                return Option.some(r);
            },
        );
    };
    const caretRangeFromPoint = function(doc, x, y) {
        return Option.from(doc.dom().caretRangeFromPoint(x, y));
    };
    const searchTextNodes = function(doc, node, x, y) {
        const r = doc.dom().createRange();
        r.selectNode(node.dom());
        const rect = r.getBoundingClientRect();
        const boundedX = Math.max(rect.left, Math.min(rect.right, x));
        const boundedY = Math.max(rect.top, Math.min(rect.bottom, y));
        return locate$1(doc, node, boundedX, boundedY);
    };
    const searchFromPoint = function(doc, x, y) {
        return Element.fromPoint(doc, x, y).bind(function(elem) {
            const fallback = function() {
                return search$1(doc, elem, x);
            };
            return children(elem).length === 0
                ? fallback()
                : searchTextNodes(doc, elem, x, y).orThunk(fallback);
        });
    };
    const availableSearch = document.caretPositionFromPoint
        ? caretPositionFromPoint
        : document.caretRangeFromPoint
        ? caretRangeFromPoint
        : searchFromPoint;

    const descendants = function(scope, selector) {
        return all(selector, scope);
    };

    const makeRange = function(start, soffset, finish, foffset) {
        const doc = owner(start);
        const rng = doc.dom().createRange();
        rng.setStart(start.dom(), soffset);
        rng.setEnd(finish.dom(), foffset);
        return rng;
    };
    const after$2 = function(start, soffset, finish, foffset) {
        const r = makeRange(start, soffset, finish, foffset);
        const same = eq(start, finish) && soffset === foffset;
        return r.collapsed && !same;
    };

    const readRange = function(selection) {
        if (selection.rangeCount > 0) {
            const firstRng = selection.getRangeAt(0);
            const lastRng = selection.getRangeAt(selection.rangeCount - 1);
            return Option.some(
                SimRange.create(
                    Element.fromDom(firstRng.startContainer),
                    firstRng.startOffset,
                    Element.fromDom(lastRng.endContainer),
                    lastRng.endOffset,
                ),
            );
        }
        return Option.none();
    };
    const doGetExact = function(selection) {
        const anchor = Element.fromDom(selection.anchorNode);
        const focus = Element.fromDom(selection.focusNode);
        return after$2(
            anchor,
            selection.anchorOffset,
            focus,
            selection.focusOffset,
        )
            ? Option.some(
                  SimRange.create(
                      anchor,
                      selection.anchorOffset,
                      focus,
                      selection.focusOffset,
                  ),
              )
            : readRange(selection);
    };
    const getExact = function(win) {
        return Option.from(win.getSelection())
            .filter(function(sel) {
                return sel.rangeCount > 0;
            })
            .bind(doGetExact);
    };
    const getFirstRect$1 = function(win, selection) {
        const rng = asLtrRange(win, selection);
        return getFirstRect(rng);
    };

    const point = Immutable('element', 'offset');
    const descendOnce = function(element, offset) {
        const children$1 = children(element);
        if (children$1.length === 0) {
            return point(element, offset);
        }
        if (offset < children$1.length) {
            return point(children$1[offset], 0);
        }
        const last = children$1[children$1.length - 1];
        const len = isText(last) ? get$a(last).length : children(last).length;
        return point(last, len);
    };

    const adt$7 = Adt.generate([
        { screen: ['point'] },
        {
            absolute: ['point', 'scrollLeft', 'scrollTop'],
        },
    ]);
    const toFixed = function(pos) {
        return pos.fold(
            function(point) {
                return point;
            },
            function(point, scrollLeft, scrollTop) {
                return point.translate(-scrollLeft, -scrollTop);
            },
        );
    };
    const toAbsolute = function(pos) {
        return pos.fold(
            function(point) {
                return point;
            },
            function(point, scrollLeft, scrollTop) {
                return point;
            },
        );
    };
    const sum = function(points) {
        return foldl(
            points,
            function(b, a) {
                return b.translate(a.left(), a.top());
            },
            Position(0, 0),
        );
    };
    const sumAsFixed = function(positions) {
        const points = map(positions, toFixed);
        return sum(points);
    };
    const sumAsAbsolute = function(positions) {
        const points = map(positions, toAbsolute);
        return sum(points);
    };
    const { screen } = adt$7;
    const absolute$2 = adt$7.absolute;

    const getOffset = function(component, origin, anchorInfo) {
        const win = defaultView(anchorInfo.root).dom();
        const hasSameOwner = function(frame) {
            const frameOwner = owner(frame);
            const compOwner = owner(component.element());
            return eq(frameOwner, compOwner);
        };
        return Option.from(win.frameElement)
            .map(Element.fromDom)
            .filter(hasSameOwner)
            .map(absolute);
    };
    const getRootPoint = function(component, origin, anchorInfo) {
        const doc = owner(component.element());
        const outerScroll = get$8(doc);
        const offset = getOffset(component, origin, anchorInfo).getOr(
            outerScroll,
        );
        return absolute$2(offset, outerScroll.left(), outerScroll.top());
    };

    const capRect = function(left, top, width, height) {
        let newLeft = left;
        let newTop = top;
        let newWidth = width;
        let newHeight = height;
        if (left < 0) {
            newLeft = 0;
            newWidth = width + left;
        }
        if (top < 0) {
            newTop = 0;
            newHeight = height + top;
        }
        const point = screen(Position(newLeft, newTop));
        return Option.some(pointed(point, newWidth, newHeight));
    };
    const calcNewAnchor = function(
        optBox,
        rootPoint,
        anchorInfo,
        origin,
        elem,
    ) {
        return optBox.map(function(box) {
            const points = [rootPoint, box.point()];
            const topLeft = cata$1(
                origin,
                function() {
                    return sumAsAbsolute(points);
                },
                function() {
                    return sumAsAbsolute(points);
                },
                function() {
                    return sumAsFixed(points);
                },
            );
            const anchorBox = rect(
                topLeft.left(),
                topLeft.top(),
                box.width(),
                box.height(),
            );
            const layoutsLtr = function() {
                return anchorInfo.showAbove
                    ? [
                          northeast$1,
                          northwest$1,
                          southeast$1,
                          southwest$1,
                          north$1,
                          south$1,
                      ]
                    : [
                          southeast$1,
                          southwest$1,
                          northeast$1,
                          northwest$1,
                          south$1,
                          south$1,
                      ];
            };
            const layoutsRtl = function() {
                return anchorInfo.showAbove
                    ? [
                          northwest$1,
                          northeast$1,
                          southwest$1,
                          southeast$1,
                          north$1,
                          south$1,
                      ]
                    : [
                          southwest$1,
                          southeast$1,
                          northwest$1,
                          northeast$1,
                          south$1,
                          north$1,
                      ];
            };
            const layouts = get$9(elem, anchorInfo, layoutsLtr(), layoutsRtl());
            return nu$9({
                anchorBox,
                bubble: anchorInfo.bubble.getOr(fallback()),
                overrides: anchorInfo.overrides,
                layouts,
                placer: Option.none(),
            });
        });
    };
    const ContentAnchorCommon = {
        capRect,
        calcNewAnchor,
    };

    const point$1 = Immutable('element', 'offset');
    const descendOnce$1 = function(element, offset) {
        return isText(element)
            ? point$1(element, offset)
            : descendOnce(element, offset);
    };
    const getAnchorSelection = function(win, anchorInfo) {
        const getSelection = anchorInfo.getSelection.getOrThunk(function() {
            return function() {
                return getExact(win);
            };
        });
        return getSelection().map(function(sel) {
            const modStart = descendOnce$1(sel.start(), sel.soffset());
            const modFinish = descendOnce$1(sel.finish(), sel.foffset());
            return Selection.range(
                modStart.element(),
                modStart.offset(),
                modFinish.element(),
                modFinish.offset(),
            );
        });
    };
    const placement$2 = function(component, anchorInfo, origin) {
        const win = defaultView(anchorInfo.root).dom();
        const rootPoint = getRootPoint(component, origin, anchorInfo);
        const selectionBox = getAnchorSelection(win, anchorInfo).bind(function(
            sel,
        ) {
            const optRect = getFirstRect$1(
                win,
                Selection.exactFromRange(sel),
            ).orThunk(function() {
                const x = Element.fromText(zeroWidth());
                before(sel.start(), x);
                return getFirstRect$1(win, Selection.exact(x, 0, x, 1)).map(
                    function(rect) {
                        remove(x);
                        return rect;
                    },
                );
            });
            return optRect.bind(function(rawRect) {
                return ContentAnchorCommon.capRect(
                    rawRect.left(),
                    rawRect.top(),
                    rawRect.width(),
                    rawRect.height(),
                );
            });
        });
        const targetElement = getAnchorSelection(win, anchorInfo).bind(function(
            sel,
        ) {
            return isElement(sel.start())
                ? Option.some(sel.start())
                : parent(sel.start());
        });
        const elem = targetElement.getOr(component.element());
        return ContentAnchorCommon.calcNewAnchor(
            selectionBox,
            rootPoint,
            anchorInfo,
            origin,
            elem,
        );
    };
    const SelectionAnchor = [
        option('getSelection'),
        strict$1('root'),
        option('bubble'),
        schema$1(),
        defaulted$1('overrides', {}),
        defaulted$1('showAbove', false),
        output('placement', placement$2),
    ];

    const placement$3 = function(component, anchorInfo, origin) {
        const rootPoint = getRootPoint(component, origin, anchorInfo);
        return anchorInfo.node.bind(function(target) {
            const rect = target.dom().getBoundingClientRect();
            const nodeBox = ContentAnchorCommon.capRect(
                rect.left,
                rect.top,
                rect.width,
                rect.height,
            );
            const elem = anchorInfo.node.getOr(component.element());
            return ContentAnchorCommon.calcNewAnchor(
                nodeBox,
                rootPoint,
                anchorInfo,
                origin,
                elem,
            );
        });
    };
    const NodeAnchor = [
        strict$1('node'),
        strict$1('root'),
        option('bubble'),
        schema$1(),
        defaulted$1('overrides', {}),
        defaulted$1('showAbove', false),
        output('placement', placement$3),
    ];

    const eastX$1 = function(anchor) {
        return anchor.x() + anchor.width();
    };
    const westX$1 = function(anchor, element) {
        return anchor.x() - element.width();
    };
    const northY$1 = function(anchor, element) {
        return anchor.y() - element.height() + anchor.height();
    };
    const southY$1 = function(anchor) {
        return anchor.y();
    };
    const southeast$2 = function(anchor, element, bubbles) {
        return nu$7(
            eastX$1(anchor),
            southY$1(anchor),
            bubbles.southeast(),
            southeast(),
            'link-layout-se',
        );
    };
    const southwest$2 = function(anchor, element, bubbles) {
        return nu$7(
            westX$1(anchor, element),
            southY$1(anchor),
            bubbles.southwest(),
            southwest(),
            'link-layout-sw',
        );
    };
    const northeast$2 = function(anchor, element, bubbles) {
        return nu$7(
            eastX$1(anchor),
            northY$1(anchor, element),
            bubbles.northeast(),
            northeast(),
            'link-layout-ne',
        );
    };
    const northwest$2 = function(anchor, element, bubbles) {
        return nu$7(
            westX$1(anchor, element),
            northY$1(anchor, element),
            bubbles.northwest(),
            northwest(),
            'link-layout-nw',
        );
    };
    const all$3 = function() {
        return [southeast$2, southwest$2, northeast$2, northwest$2];
    };
    const allRtl$1 = function() {
        return [southwest$2, southeast$2, northwest$2, northeast$2];
    };

    const placement$4 = function(component, submenuInfo, origin) {
        const anchorBox = toBox(origin, submenuInfo.item.element());
        const layouts = get$9(
            component.element(),
            submenuInfo,
            all$3(),
            allRtl$1(),
        );
        return Option.some(
            nu$9({
                anchorBox,
                bubble: fallback(),
                overrides: submenuInfo.overrides,
                layouts,
                placer: Option.none(),
            }),
        );
    };
    const SubmenuAnchor = [
        strict$1('item'),
        schema$1(),
        defaulted$1('overrides', {}),
        output('placement', placement$4),
    ];

    const AnchorSchema = choose$1('anchor', {
        selection: SelectionAnchor,
        node: NodeAnchor,
        hotspot: HotspotAnchor,
        submenu: SubmenuAnchor,
        makeshift: MakeshiftAnchor,
    });

    const anchor = Immutable('anchorBox', 'origin');
    const box$1 = function(anchorBox, origin) {
        return anchor(anchorBox, origin);
    };

    const cycleBy = function(value, delta, min, max) {
        const r = value + delta;
        if (r > max) {
            return min;
        }
        return r < min ? max : r;
    };
    const cap = function(value, min, max) {
        if (value <= min) {
            return min;
        }
        return value >= max ? max : value;
    };

    const adt$8 = Adt.generate([
        { fit: ['reposition'] },
        {
            nofit: ['reposition', 'deltaW', 'deltaH'],
        },
    ]);
    const calcReposition = function(newX, newY, width, height, bounds) {
        const boundsX = bounds.x();
        const boundsY = bounds.y();
        const boundsWidth = bounds.width();
        const boundsHeight = bounds.height();
        const xInBounds = newX >= boundsX;
        const yInBounds = newY >= boundsY;
        const originInBounds = xInBounds && yInBounds;
        const xFit = newX + width <= boundsX + boundsWidth;
        const yFit = newY + height <= boundsY + boundsHeight;
        const sizeInBounds = xFit && yFit;
        const deltaW = Math.abs(
            Math.min(
                width,
                xInBounds
                    ? boundsX + boundsWidth - newX
                    : boundsX - (newX + width),
            ),
        );
        const deltaH = Math.abs(
            Math.min(
                height,
                yInBounds
                    ? boundsY + boundsHeight - newY
                    : boundsY - (newY + height),
            ),
        );
        const limitX = cap(newX, bounds.x(), bounds.right());
        const limitY = cap(newY, bounds.y(), bounds.bottom());
        return {
            originInBounds,
            sizeInBounds,
            limitX,
            limitY,
            deltaW,
            deltaH,
        };
    };
    const attempt = function(candidate, width, height, bounds) {
        const candidateX = candidate.x();
        const candidateY = candidate.y();
        const bubbleLeft = candidate
            .bubble()
            .offset()
            .left();
        const bubbleTop = candidate
            .bubble()
            .offset()
            .top();
        const boundsY = bounds.y();
        const boundsBottom = bounds.bottom();
        const boundsX = bounds.x();
        const boundsRight = bounds.right();
        const newX = candidateX + bubbleLeft;
        const newY = candidateY + bubbleTop;
        const _a = calcReposition(newX, newY, width, height, bounds);
        const { originInBounds } = _a;
        const { sizeInBounds } = _a;
        const { limitX } = _a;
        const { limitY } = _a;
        const { deltaW } = _a;
        const { deltaH } = _a;
        const upAvailable = constant(limitY + deltaH - boundsY);
        const downAvailable = constant(boundsBottom - limitY);
        const maxHeight = cataVertical(
            candidate.direction(),
            downAvailable,
            downAvailable,
            upAvailable,
        );
        const westAvailable = constant(limitX + deltaW - boundsX);
        const eastAvailable = constant(boundsRight - limitX);
        const maxWidth = cataHorizontal(
            candidate.direction(),
            eastAvailable,
            eastAvailable,
            westAvailable,
        );
        const reposition = decision({
            x: limitX,
            y: limitY,
            width: deltaW,
            height: deltaH,
            maxHeight,
            maxWidth,
            direction: candidate.direction(),
            classes: {
                on: candidate.bubble().classesOn(),
                off: candidate.bubble().classesOff(),
            },
            label: candidate.label(),
            candidateYforTest: newY,
        });
        return originInBounds && sizeInBounds
            ? adt$8.fit(reposition)
            : adt$8.nofit(reposition, deltaW, deltaH);
    };
    const attempts = function(
        candidates,
        anchorBox,
        elementBox,
        bubbles,
        bounds,
    ) {
        const panelWidth = elementBox.width();
        const panelHeight = elementBox.height();
        const attemptBestFit = function(layout, reposition, deltaW, deltaH) {
            const next = layout(anchorBox, elementBox, bubbles);
            const attemptLayout = attempt(
                next,
                panelWidth,
                panelHeight,
                bounds,
            );
            return attemptLayout.fold(adt$8.fit, function(
                newReposition,
                newDeltaW,
                newDeltaH,
            ) {
                const improved = newDeltaH > deltaH || newDeltaW > deltaW;
                return improved
                    ? adt$8.nofit(newReposition, newDeltaW, newDeltaH)
                    : adt$8.nofit(reposition, deltaW, deltaH);
            });
        };
        const abc = foldl(
            candidates,
            function(b, a) {
                const bestNext = curry(attemptBestFit, a);
                return b.fold(adt$8.fit, bestNext);
            },
            adt$8.nofit(
                decision({
                    x: anchorBox.x(),
                    y: anchorBox.y(),
                    width: elementBox.width(),
                    height: elementBox.height(),
                    maxHeight: elementBox.height(),
                    maxWidth: elementBox.width(),
                    direction: southeast(),
                    classes: {
                        on: [],
                        off: [],
                    },
                    label: 'none',
                    candidateYforTest: anchorBox.y(),
                }),
                -1,
                -1,
            ),
        );
        return abc.fold(identity, identity);
    };

    const elementSize = function(p) {
        return {
            width: constant(getOuter$2(p)),
            height: constant(getOuter$1(p)),
        };
    };
    const layout = function(anchorBox, element, bubbles, options) {
        remove$6(element, 'max-height');
        remove$6(element, 'max-width');
        const elementBox = elementSize(element);
        return attempts(
            options.preference(),
            anchorBox,
            elementBox,
            bubbles,
            options.bounds(),
        );
    };
    const setClasses = function(element, decision) {
        const classInfo = decision.classes();
        remove$5(element, classInfo.off);
        add$3(element, classInfo.on);
    };
    const setHeight = function(element, decision, options) {
        const maxHeightFunction = options.maxHeightFunction();
        maxHeightFunction(element, decision.maxHeight());
    };
    const setWidth = function(element, decision, options) {
        const maxWidthFunction = options.maxWidthFunction();
        maxWidthFunction(element, decision.maxWidth());
    };
    const position = function(element, decision, options) {
        const addPx = function(num) {
            return `${num}px`;
        };
        const newPosition = reposition(options.origin(), decision);
        setOptions(element, {
            position: Option.some(newPosition.position()),
            left: newPosition.left().map(addPx),
            top: newPosition.top().map(addPx),
            right: newPosition.right().map(addPx),
            bottom: newPosition.bottom().map(addPx),
        });
    };

    const setMaxHeight = function(element, maxHeight) {
        setMax(element, Math.floor(maxHeight));
    };
    const anchored = constant(function(element, available) {
        setMaxHeight(element, available);
        setAll$1(element, {
            'overflow-x': 'hidden',
            'overflow-y': 'auto',
        });
    });
    const expandable = constant(function(element, available) {
        setMaxHeight(element, available);
    });

    const reparteeOptions = MixedBag(
        [
            'bounds',
            'origin',
            'preference',
            'maxHeightFunction',
            'maxWidthFunction',
        ],
        [],
    );
    const defaultOr = function(options, key, dephault) {
        return options[key] === undefined ? dephault : options[key];
    };
    const simple = function(
        anchor,
        element,
        bubble,
        layouts,
        getBounds,
        overrideOptions,
    ) {
        const maxHeightFunction = defaultOr(
            overrideOptions,
            'maxHeightFunction',
            anchored(),
        );
        const maxWidthFunction = defaultOr(
            overrideOptions,
            'maxWidthFunction',
            noop,
        );
        const anchorBox = anchor.anchorBox();
        const origin = anchor.origin();
        const options = reparteeOptions({
            bounds: viewport$1(origin, getBounds),
            origin,
            preference: layouts,
            maxHeightFunction,
            maxWidthFunction,
        });
        go(anchorBox, element, bubble, options);
    };
    var go = function(anchorBox, element, bubble, options) {
        const decision = layout(anchorBox, element, bubble, options);
        position(element, decision, options);
        setClasses(element, decision);
        setHeight(element, decision, options);
        setWidth(element, decision, options);
    };

    const getFixedOrigin = function() {
        const html = domGlobals.document.documentElement;
        return fixed(0, 0, html.clientWidth, html.clientHeight);
    };
    const getRelativeOrigin = function(component) {
        const position = absolute(component.element());
        const bounds = component
            .element()
            .dom()
            .getBoundingClientRect();
        return relative(
            position.left(),
            position.top(),
            bounds.width,
            bounds.height,
        );
    };
    const place = function(component, origin, anchoring, getBounds, placee) {
        const anchor = box$1(anchoring.anchorBox, origin);
        simple(
            anchor,
            placee.element(),
            anchoring.bubble,
            anchoring.layouts,
            getBounds,
            anchoring.overrides,
        );
    };
    const position$1 = function(
        component,
        posConfig,
        posState,
        anchor,
        placee,
    ) {
        positionWithin(
            component,
            posConfig,
            posState,
            anchor,
            placee,
            Option.none(),
        );
    };
    var positionWithin = function(
        component,
        posConfig,
        posState,
        anchor,
        placee,
        boxElement,
    ) {
        const boundsBox = boxElement.map(box);
        return positionWithinBounds(
            component,
            posConfig,
            posState,
            anchor,
            placee,
            boundsBox,
        );
    };
    var positionWithinBounds = function(
        component,
        posConfig,
        posState,
        anchor,
        placee,
        bounds,
    ) {
        const anchorage = asRawOrDie(
            'positioning anchor.info',
            AnchorSchema,
            anchor,
        );
        preserve(function() {
            set$2(placee.element(), 'position', 'fixed');
            const oldVisibility = getRaw(placee.element(), 'visibility');
            set$2(placee.element(), 'visibility', 'hidden');
            const origin = posConfig.useFixed()
                ? getFixedOrigin()
                : getRelativeOrigin(component);
            const placer = anchorage.placement;
            const getBounds = bounds.map(constant).or(posConfig.getBounds);
            placer(component, anchorage, origin).each(function(anchoring) {
                const doPlace = anchoring.placer.getOr(place);
                doPlace(component, origin, anchoring, getBounds, placee);
            });
            oldVisibility.fold(
                function() {
                    remove$6(placee.element(), 'visibility');
                },
                function(vis) {
                    set$2(placee.element(), 'visibility', vis);
                },
            );
            if (
                getRaw(placee.element(), 'left').isNone() &&
                getRaw(placee.element(), 'top').isNone() &&
                getRaw(placee.element(), 'right').isNone() &&
                getRaw(placee.element(), 'bottom').isNone() &&
                getRaw(placee.element(), 'position').is('fixed')
            ) {
                remove$6(placee.element(), 'position');
            }
        }, placee.element());
    };
    const getMode = function(component, pConfig, pState) {
        return pConfig.useFixed() ? 'fixed' : 'absolute';
    };

    const PositionApis = /* #__PURE__ */ Object.freeze({
        position: position$1,
        positionWithin,
        positionWithinBounds,
        getMode,
    });

    const PositionSchema = [
        defaulted$1('useFixed', never),
        option('getBounds'),
    ];

    const Positioning = create$1({
        fields: PositionSchema,
        name: 'positioning',
        active: ActivePosition,
        apis: PositionApis,
    });

    var fireDetaching = function(component) {
        emit(component, detachedFromDom());
        const children = component.components();
        each(children, fireDetaching);
    };
    var fireAttaching = function(component) {
        const children = component.components();
        each(children, fireAttaching);
        emit(component, attachedToDom());
    };
    const attach = function(parent, child) {
        append(parent.element(), child.element());
    };
    const detachChildren = function(component) {
        each(component.components(), function(childComp) {
            return remove(childComp.element());
        });
        empty(component.element());
        component.syncComponents();
    };
    const replaceChildren = function(component, newChildren) {
        const subs = component.components();
        detachChildren(component);
        const deleted = difference(subs, newChildren);
        each(deleted, function(comp) {
            fireDetaching(comp);
            component.getSystem().removeFromWorld(comp);
        });
        each(newChildren, function(childComp) {
            if (!childComp.getSystem().isConnected()) {
                component.getSystem().addToWorld(childComp);
                attach(component, childComp);
                if (inBody(component.element())) {
                    fireAttaching(childComp);
                }
            } else {
                attach(component, childComp);
            }
            component.syncComponents();
        });
    };

    const attach$1 = function(parent, child) {
        attachWith(parent, child, append);
    };
    var attachWith = function(parent, child, insertion) {
        parent.getSystem().addToWorld(child);
        insertion(parent.element(), child.element());
        if (inBody(parent.element())) {
            fireAttaching(child);
        }
        parent.syncComponents();
    };
    const doDetach = function(component) {
        fireDetaching(component);
        remove(component.element());
        component.getSystem().removeFromWorld(component);
    };
    const detach = function(component) {
        const parent$1 = parent(component.element()).bind(function(p) {
            return component
                .getSystem()
                .getByDom(p)
                .toOption();
        });
        doDetach(component);
        parent$1.each(function(p) {
            p.syncComponents();
        });
    };
    const detachChildren$1 = function(component) {
        const subs = component.components();
        each(subs, doDetach);
        empty(component.element());
        component.syncComponents();
    };
    const attachSystem = function(element, guiSystem) {
        attachSystemWith(element, guiSystem, append);
    };
    const attachSystemAfter = function(element, guiSystem) {
        attachSystemWith(element, guiSystem, after);
    };
    var attachSystemWith = function(element, guiSystem, inserter) {
        inserter(element, guiSystem.element());
        const children$1 = children(guiSystem.element());
        each(children$1, function(child) {
            guiSystem.getByDom(child).each(fireAttaching);
        });
    };
    const detachSystem = function(guiSystem) {
        const children$1 = children(guiSystem.element());
        each(children$1, function(child) {
            guiSystem.getByDom(child).each(fireDetaching);
        });
        remove(guiSystem.element());
    };

    const rebuild = function(sandbox, sConfig, sState, data) {
        sState.get().each(function(data) {
            detachChildren$1(sandbox);
        });
        const point = sConfig.getAttachPoint(sandbox);
        attach$1(point, sandbox);
        const built = sandbox.getSystem().build(data);
        attach$1(sandbox, built);
        sState.set(built);
        return built;
    };
    const open = function(sandbox, sConfig, sState, data) {
        const newState = rebuild(sandbox, sConfig, sState, data);
        sConfig.onOpen(sandbox, newState);
        return newState;
    };
    const setContent = function(sandbox, sConfig, sState, data) {
        return sState.get().map(function() {
            return rebuild(sandbox, sConfig, sState, data);
        });
    };
    const openWhileCloaked = function(
        sandbox,
        sConfig,
        sState,
        data,
        transaction,
    ) {
        cloak(sandbox, sConfig);
        open(sandbox, sConfig, sState, data);
        transaction();
        decloak(sandbox, sConfig);
    };
    const close = function(sandbox, sConfig, sState) {
        sState.get().each(function(data) {
            detachChildren$1(sandbox);
            detach(sandbox);
            sConfig.onClose(sandbox, data);
            sState.clear();
        });
    };
    const isOpen = function(sandbox, sConfig, sState) {
        return sState.isOpen();
    };
    const isPartOf$1 = function(sandbox, sConfig, sState, queryElem) {
        return (
            isOpen(sandbox, sConfig, sState) &&
            sState.get().exists(function(data) {
                return sConfig.isPartOf(sandbox, data, queryElem);
            })
        );
    };
    const getState = function(sandbox, sConfig, sState) {
        return sState.get();
    };
    const store = function(sandbox, cssKey, attr, newValue) {
        getRaw(sandbox.element(), cssKey).fold(
            function() {
                remove$1(sandbox.element(), attr);
            },
            function(v) {
                set$1(sandbox.element(), attr, v);
            },
        );
        set$2(sandbox.element(), cssKey, newValue);
    };
    const restore = function(sandbox, cssKey, attr) {
        if (has$1(sandbox.element(), attr)) {
            const oldValue = get$2(sandbox.element(), attr);
            set$2(sandbox.element(), cssKey, oldValue);
        } else {
            remove$6(sandbox.element(), cssKey);
        }
    };
    var cloak = function(sandbox, sConfig, sState) {
        const sink = sConfig.getAttachPoint(sandbox);
        set$2(sandbox.element(), 'position', Positioning.getMode(sink));
        store(sandbox, 'visibility', sConfig.cloakVisibilityAttr, 'hidden');
    };
    const hasPosition = function(element) {
        return exists(['top', 'left', 'right', 'bottom'], function(pos) {
            return getRaw(element, pos).isSome();
        });
    };
    var decloak = function(sandbox, sConfig, sState) {
        if (!hasPosition(sandbox.element())) {
            remove$6(sandbox.element(), 'position');
        }
        restore(sandbox, 'visibility', sConfig.cloakVisibilityAttr);
    };

    const SandboxApis = /* #__PURE__ */ Object.freeze({
        cloak,
        decloak,
        open,
        openWhileCloaked,
        close,
        isOpen,
        isPartOf: isPartOf$1,
        getState,
        setContent,
    });

    const events$2 = function(sandboxConfig, sandboxState) {
        return derive([
            run(sandboxClose(), function(sandbox, simulatedEvent) {
                close(sandbox, sandboxConfig, sandboxState);
            }),
        ]);
    };

    const ActiveSandbox = /* #__PURE__ */ Object.freeze({
        events: events$2,
    });

    const SandboxSchema = [
        onHandler('onOpen'),
        onHandler('onClose'),
        strict$1('isPartOf'),
        strict$1('getAttachPoint'),
        defaulted$1('cloakVisibilityAttr', 'data-precloak-visibility'),
    ];

    const init = function() {
        const contents = Cell(Option.none());
        const readState = constant('not-implemented');
        const isOpen = function() {
            return contents.get().isSome();
        };
        const set = function(c) {
            contents.set(Option.some(c));
        };
        const get = function(c) {
            return contents.get();
        };
        const clear = function() {
            contents.set(Option.none());
        };
        return nu$5({
            readState,
            isOpen,
            clear,
            set,
            get,
        });
    };

    const SandboxState = /* #__PURE__ */ Object.freeze({
        init,
    });

    const Sandboxing = create$1({
        fields: SandboxSchema,
        name: 'sandboxing',
        active: ActiveSandbox,
        apis: SandboxApis,
        state: SandboxState,
    });

    const dismissPopups = constant('dismiss.popups');
    const repositionPopups = constant('reposition.popups');
    const mouseReleased = constant('mouse.released');

    const schema$2 = objOfOnly([
        defaulted$1('isExtraPart', constant(false)),
        optionObjOf('fireEventInstead', [
            defaulted$1('event', dismissRequested()),
        ]),
    ]);
    const receivingChannel = function(rawSpec) {
        let _a;
        const detail = asRawOrDie('Dismissal', schema$2, rawSpec);
        return (
            (_a = {}),
            (_a[dismissPopups()] = {
                schema: objOfOnly([strict$1('target')]),
                onReceive(sandbox, data) {
                    if (Sandboxing.isOpen(sandbox)) {
                        const isPart =
                            Sandboxing.isPartOf(sandbox, data.target) ||
                            detail.isExtraPart(sandbox, data.target);
                        if (!isPart) {
                            detail.fireEventInstead.fold(
                                function() {
                                    return Sandboxing.close(sandbox);
                                },
                                function(fe) {
                                    return emit(sandbox, fe.event);
                                },
                            );
                        }
                    }
                },
            }),
            _a
        );
    };

    const schema$3 = objOfOnly([
        defaulted$1('isExtraPart', constant(false)),
        optionObjOf('fireEventInstead', [
            defaulted$1('event', repositionRequested()),
        ]),
        strictFunction('doReposition'),
    ]);
    const receivingChannel$1 = function(rawSpec) {
        let _a;
        const detail = asRawOrDie('Reposition', schema$3, rawSpec);
        return (
            (_a = {}),
            (_a[repositionPopups()] = {
                onReceive(sandbox) {
                    if (Sandboxing.isOpen(sandbox)) {
                        detail.fireEventInstead.fold(
                            function() {
                                return detail.doReposition(sandbox);
                            },
                            function(fe) {
                                return emit(sandbox, fe.event);
                            },
                        );
                    }
                },
            }),
            _a
        );
    };

    const onLoad = function(component, repConfig, repState) {
        repConfig.store.manager.onLoad(component, repConfig, repState);
    };
    const onUnload = function(component, repConfig, repState) {
        repConfig.store.manager.onUnload(component, repConfig, repState);
    };
    const setValue = function(component, repConfig, repState, data) {
        repConfig.store.manager.setValue(component, repConfig, repState, data);
    };
    const getValue = function(component, repConfig, repState) {
        return repConfig.store.manager.getValue(component, repConfig, repState);
    };
    const getState$1 = function(component, repConfig, repState) {
        return repState;
    };

    const RepresentApis = /* #__PURE__ */ Object.freeze({
        onLoad,
        onUnload,
        setValue,
        getValue,
        getState: getState$1,
    });

    const events$3 = function(repConfig, repState) {
        const es = repConfig.resetOnDom
            ? [
                  runOnAttached(function(comp, se) {
                      onLoad(comp, repConfig, repState);
                  }),
                  runOnDetached(function(comp, se) {
                      onUnload(comp, repConfig, repState);
                  }),
              ]
            : [loadEvent(repConfig, repState, onLoad)];
        return derive(es);
    };

    const ActiveRepresenting = /* #__PURE__ */ Object.freeze({
        events: events$3,
    });

    const memory = function() {
        const data = Cell(null);
        const readState = function() {
            return {
                mode: 'memory',
                value: data.get(),
            };
        };
        const isNotSet = function() {
            return data.get() === null;
        };
        const clear = function() {
            data.set(null);
        };
        return nu$5({
            set: data.set,
            get: data.get,
            isNotSet,
            clear,
            readState,
        });
    };
    const manual = function() {
        const readState = function() {};
        return nu$5({ readState });
    };
    const dataset = function() {
        const dataByValue = Cell({});
        const dataByText = Cell({});
        const readState = function() {
            return {
                mode: 'dataset',
                dataByValue: dataByValue.get(),
                dataByText: dataByText.get(),
            };
        };
        const clear = function() {
            dataByValue.set({});
            dataByText.set({});
        };
        const lookup = function(itemString) {
            return readOptFrom$1(dataByValue.get(), itemString).orThunk(
                function() {
                    return readOptFrom$1(dataByText.get(), itemString);
                },
            );
        };
        const update = function(items) {
            const currentDataByValue = dataByValue.get();
            const currentDataByText = dataByText.get();
            const newDataByValue = {};
            const newDataByText = {};
            each(items, function(item) {
                newDataByValue[item.value] = item;
                readOptFrom$1(item, 'meta').each(function(meta) {
                    readOptFrom$1(meta, 'text').each(function(text) {
                        newDataByText[text] = item;
                    });
                });
            });
            dataByValue.set({ ...currentDataByValue, ...newDataByValue });
            dataByText.set({ ...currentDataByText, ...newDataByText });
        };
        return nu$5({
            readState,
            lookup,
            update,
            clear,
        });
    };
    const init$1 = function(spec) {
        return spec.store.manager.state(spec);
    };

    const RepresentState = /* #__PURE__ */ Object.freeze({
        memory,
        dataset,
        manual,
        init: init$1,
    });

    const setValue$1 = function(component, repConfig, repState, data) {
        const { store } = repConfig;
        repState.update([data]);
        store.setValue(component, data);
        repConfig.onSetValue(component, data);
    };
    const getValue$1 = function(component, repConfig, repState) {
        const { store } = repConfig;
        const key = store.getDataKey(component);
        return repState.lookup(key).fold(
            function() {
                return store.getFallbackEntry(key);
            },
            function(data) {
                return data;
            },
        );
    };
    const onLoad$1 = function(component, repConfig, repState) {
        const { store } = repConfig;
        store.initialValue.each(function(data) {
            setValue$1(component, repConfig, repState, data);
        });
    };
    const onUnload$1 = function(component, repConfig, repState) {
        repState.clear();
    };
    const DatasetStore = [
        option('initialValue'),
        strict$1('getFallbackEntry'),
        strict$1('getDataKey'),
        strict$1('setValue'),
        output('manager', {
            setValue: setValue$1,
            getValue: getValue$1,
            onLoad: onLoad$1,
            onUnload: onUnload$1,
            state: dataset,
        }),
    ];

    const getValue$2 = function(component, repConfig, repState) {
        return repConfig.store.getValue(component);
    };
    const setValue$2 = function(component, repConfig, repState, data) {
        repConfig.store.setValue(component, data);
        repConfig.onSetValue(component, data);
    };
    const onLoad$2 = function(component, repConfig, repState) {
        repConfig.store.initialValue.each(function(data) {
            repConfig.store.setValue(component, data);
        });
    };
    const ManualStore = [
        strict$1('getValue'),
        defaulted$1('setValue', noop),
        option('initialValue'),
        output('manager', {
            setValue: setValue$2,
            getValue: getValue$2,
            onLoad: onLoad$2,
            onUnload: noop,
            state: NoState.init,
        }),
    ];

    const setValue$3 = function(component, repConfig, repState, data) {
        repState.set(data);
        repConfig.onSetValue(component, data);
    };
    const getValue$3 = function(component, repConfig, repState) {
        return repState.get();
    };
    const onLoad$3 = function(component, repConfig, repState) {
        repConfig.store.initialValue.each(function(initVal) {
            if (repState.isNotSet()) {
                repState.set(initVal);
            }
        });
    };
    const onUnload$2 = function(component, repConfig, repState) {
        repState.clear();
    };
    const MemoryStore = [
        option('initialValue'),
        output('manager', {
            setValue: setValue$3,
            getValue: getValue$3,
            onLoad: onLoad$3,
            onUnload: onUnload$2,
            state: memory,
        }),
    ];

    const RepresentSchema = [
        defaultedOf(
            'store',
            { mode: 'memory' },
            choose$1('mode', {
                memory: MemoryStore,
                manual: ManualStore,
                dataset: DatasetStore,
            }),
        ),
        onHandler('onSetValue'),
        defaulted$1('resetOnDom', false),
    ];

    var Representing = create$1({
        fields: RepresentSchema,
        name: 'representing',
        active: ActiveRepresenting,
        apis: RepresentApis,
        extra: {
            setValueFrom(component, source) {
                const value = Representing.getValue(source);
                Representing.setValue(component, value);
            },
        },
        state: RepresentState,
    });

    const field$1 = function(name, forbidden) {
        return defaultedObjOf(
            name,
            {},
            map(forbidden, function(f) {
                return forbid(
                    f.name(),
                    `Cannot configure ${f.name()} for ${name}`,
                );
            }).concat([state$1('dump', identity)]),
        );
    };
    const get$b = function(data) {
        return data.dump;
    };
    const augment = function(data, original) {
        return { ...data.dump, ...derive$1(original) };
    };
    const SketchBehaviours = {
        field: field$1,
        augment,
        get: get$b,
    };

    const _placeholder = 'placeholder';
    const adt$9 = Adt.generate([
        {
            single: ['required', 'valueThunk'],
        },
        {
            multiple: ['required', 'valueThunks'],
        },
    ]);
    const subPlaceholder = function(owner, detail, compSpec, placeholders) {
        if (
            owner.exists(function(o) {
                return o !== compSpec.owner;
            })
        ) {
            return adt$9.single(true, constant(compSpec));
        }
        return readOptFrom$1(placeholders, compSpec.name).fold(
            function() {
                throw new Error(
                    `Unknown placeholder component: ${
                        compSpec.name
                    }\nKnown: [${keys(placeholders)}]\nNamespace: ${owner.getOr(
                        'none',
                    )}\nSpec: ${JSON.stringify(compSpec, null, 2)}`,
                );
            },
            function(newSpec) {
                return newSpec.replace();
            },
        );
    };
    const scan = function(owner, detail, compSpec, placeholders) {
        if (compSpec.uiType === _placeholder) {
            return subPlaceholder(owner, detail, compSpec, placeholders);
        }
        return adt$9.single(false, constant(compSpec));
    };
    var substitute = function(owner, detail, compSpec, placeholders) {
        const base = scan(owner, detail, compSpec, placeholders);
        return base.fold(
            function(req, valueThunk) {
                const value = valueThunk(
                    detail,
                    compSpec.config,
                    compSpec.validated,
                );
                const childSpecs = readOptFrom$1(value, 'components').getOr([]);
                const substituted = bind(childSpecs, function(c) {
                    return substitute(owner, detail, c, placeholders);
                });
                return [{ ...value, components: substituted }];
            },
            function(req, valuesThunk) {
                const values = valuesThunk(
                    detail,
                    compSpec.config,
                    compSpec.validated,
                );
                const preprocessor = compSpec.validated.preprocess.getOr(
                    identity,
                );
                return preprocessor(values);
            },
        );
    };
    const substituteAll = function(owner, detail, components, placeholders) {
        return bind(components, function(c) {
            return substitute(owner, detail, c, placeholders);
        });
    };
    const oneReplace = function(label, replacements) {
        let called = false;
        const used = function() {
            return called;
        };
        const replace = function() {
            if (called === true) {
                throw new Error(
                    `Trying to use the same placeholder more than once: ${label}`,
                );
            }
            called = true;
            return replacements;
        };
        const required = function() {
            return replacements.fold(
                function(req, _) {
                    return req;
                },
                function(req, _) {
                    return req;
                },
            );
        };
        return {
            name: constant(label),
            required,
            used,
            replace,
        };
    };
    const substitutePlaces = function(owner, detail, components, placeholders) {
        const ps = map$1(placeholders, function(ph, name) {
            return oneReplace(name, ph);
        });
        const outcome = substituteAll(owner, detail, components, ps);
        each$1(ps, function(p) {
            if (p.used() === false && p.required()) {
                throw new Error(
                    `Placeholder: ${p.name()} was not found in components list\nNamespace: ${owner.getOr(
                        'none',
                    )}\nComponents: ${JSON.stringify(
                        detail.components,
                        null,
                        2,
                    )}`,
                );
            }
        });
        return outcome;
    };
    const { single } = adt$9;
    const { multiple } = adt$9;
    const placeholder = constant(_placeholder);

    const adt$a = Adt.generate([
        { required: ['data'] },
        { external: ['data'] },
        { optional: ['data'] },
        { group: ['data'] },
    ]);
    const fFactory = defaulted$1('factory', { sketch: identity });
    const fSchema = defaulted$1('schema', []);
    const fName = strict$1('name');
    const fPname = field(
        'pname',
        'pname',
        defaultedThunk(function(typeSpec) {
            return `<alloy.${generate$1(typeSpec.name)}>`;
        }),
        anyValue$1(),
    );
    const fGroupSchema = state$1('schema', function() {
        return [option('preprocess')];
    });
    const fDefaults = defaulted$1('defaults', constant({}));
    const fOverrides = defaulted$1('overrides', constant({}));
    const requiredSpec = objOf([
        fFactory,
        fSchema,
        fName,
        fPname,
        fDefaults,
        fOverrides,
    ]);
    const externalSpec = objOf([
        fFactory,
        fSchema,
        fName,
        fDefaults,
        fOverrides,
    ]);
    const optionalSpec = objOf([
        fFactory,
        fSchema,
        fName,
        fPname,
        fDefaults,
        fOverrides,
    ]);
    const groupSpec = objOf([
        fFactory,
        fGroupSchema,
        fName,
        strict$1('unit'),
        fPname,
        fDefaults,
        fOverrides,
    ]);
    const asNamedPart = function(part) {
        return part.fold(Option.some, Option.none, Option.some, Option.some);
    };
    const name$1 = function(part) {
        const get = function(data) {
            return data.name;
        };
        return part.fold(get, get, get, get);
    };
    const asCommon = function(part) {
        return part.fold(identity, identity, identity, identity);
    };
    const convert = function(adtConstructor, partSchema) {
        return function(spec) {
            const data = asRawOrDie('Converting part type', partSchema, spec);
            return adtConstructor(data);
        };
    };
    const required = convert(adt$a.required, requiredSpec);
    const external$1 = convert(adt$a.external, externalSpec);
    const optional = convert(adt$a.optional, optionalSpec);
    const group = convert(adt$a.group, groupSpec);
    const original = constant('entirety');

    const PartType = /* #__PURE__ */ Object.freeze({
        required,
        external: external$1,
        optional,
        group,
        asNamedPart,
        name: name$1,
        asCommon,
        original,
    });

    const combine$2 = function(detail, data, partSpec, partValidated) {
        return deepMerge(
            data.defaults(detail, partSpec, partValidated),
            partSpec,
            { uid: detail.partUids[data.name] },
            data.overrides(detail, partSpec, partValidated),
        );
    };
    const subs = function(owner, detail, parts) {
        const internals = {};
        const externals = {};
        each(parts, function(part) {
            part.fold(
                function(data) {
                    internals[data.pname] = single(true, function(
                        detail,
                        partSpec,
                        partValidated,
                    ) {
                        return data.factory.sketch(
                            combine$2(detail, data, partSpec, partValidated),
                        );
                    });
                },
                function(data) {
                    const partSpec = detail.parts[data.name];
                    externals[data.name] = constant(
                        data.factory.sketch(
                            combine$2(detail, data, partSpec[original()]),
                            partSpec,
                        ),
                    );
                },
                function(data) {
                    internals[data.pname] = single(false, function(
                        detail,
                        partSpec,
                        partValidated,
                    ) {
                        return data.factory.sketch(
                            combine$2(detail, data, partSpec, partValidated),
                        );
                    });
                },
                function(data) {
                    internals[data.pname] = multiple(true, function(
                        detail,
                        _partSpec,
                        _partValidated,
                    ) {
                        const units = detail[data.name];
                        return map(units, function(u) {
                            return data.factory.sketch(
                                deepMerge(
                                    data.defaults(detail, u, _partValidated),
                                    u,
                                    data.overrides(detail, u),
                                ),
                            );
                        });
                    });
                },
            );
        });
        return {
            internals: constant(internals),
            externals: constant(externals),
        };
    };

    const generate$4 = function(owner, parts) {
        const r = {};
        each(parts, function(part) {
            asNamedPart(part).each(function(np) {
                const g = doGenerateOne(owner, np.pname);
                r[np.name] = function(config) {
                    const validated = asRawOrDie(
                        `Part: ${np.name} in ${owner}`,
                        objOf(np.schema),
                        config,
                    );
                    return { ...g, config, validated };
                };
            });
        });
        return r;
    };
    var doGenerateOne = function(owner, pname) {
        return {
            uiType: placeholder(),
            owner,
            name: pname,
        };
    };
    const generateOne = function(owner, pname, config) {
        return {
            uiType: placeholder(),
            owner,
            name: pname,
            config,
            validated: {},
        };
    };
    const schemas = function(parts) {
        return bind(parts, function(part) {
            return part
                .fold(Option.none, Option.some, Option.none, Option.none)
                .map(function(data) {
                    return strictObjOf(
                        data.name,
                        data.schema.concat([snapshot(original())]),
                    );
                })
                .toArray();
        });
    };
    const names = function(parts) {
        return map(parts, name$1);
    };
    const substitutes = function(owner, detail, parts) {
        return subs(owner, detail, parts);
    };
    const components = function(owner, detail, internals) {
        return substitutePlaces(
            Option.some(owner),
            detail,
            detail.components,
            internals,
        );
    };
    const getPart = function(component, detail, partKey) {
        const uid = detail.partUids[partKey];
        return component
            .getSystem()
            .getByUid(uid)
            .toOption();
    };
    const getPartOrDie = function(component, detail, partKey) {
        return getPart(component, detail, partKey).getOrDie(
            `Could not find part: ${partKey}`,
        );
    };
    const getParts = function(component, detail, partKeys) {
        const r = {};
        const uids = detail.partUids;
        const system = component.getSystem();
        each(partKeys, function(pk) {
            r[pk] = constant(system.getByUid(uids[pk]));
        });
        return r;
    };
    const getAllParts = function(component, detail) {
        const system = component.getSystem();
        return map$1(detail.partUids, function(pUid, k) {
            return constant(system.getByUid(pUid));
        });
    };
    const getAllPartNames = function(detail) {
        return keys(detail.partUids);
    };
    const getPartsOrDie = function(component, detail, partKeys) {
        const r = {};
        const uids = detail.partUids;
        const system = component.getSystem();
        each(partKeys, function(pk) {
            r[pk] = constant(system.getByUid(uids[pk]).getOrDie());
        });
        return r;
    };
    const defaultUids = function(baseUid, partTypes) {
        const partNames = names(partTypes);
        return wrapAll$1(
            map(partNames, function(pn) {
                return {
                    key: pn,
                    value: `${baseUid}-${pn}`,
                };
            }),
        );
    };
    const defaultUidsSchema = function(partTypes) {
        return field(
            'partUids',
            'partUids',
            mergeWithThunk(function(spec) {
                return defaultUids(spec.uid, partTypes);
            }),
            anyValue$1(),
        );
    };

    const AlloyParts = /* #__PURE__ */ Object.freeze({
        generate: generate$4,
        generateOne,
        schemas,
        names,
        substitutes,
        components,
        defaultUids,
        defaultUidsSchema,
        getAllParts,
        getAllPartNames,
        getPart,
        getPartOrDie,
        getParts,
        getPartsOrDie,
    });

    const base = function(partSchemas, partUidsSchemas) {
        const ps =
            partSchemas.length > 0 ? [strictObjOf('parts', partSchemas)] : [];
        return ps
            .concat([
                strict$1('uid'),
                defaulted$1('dom', {}),
                defaulted$1('components', []),
                snapshot('originalSpec'),
                defaulted$1('debug.sketcher', {}),
            ])
            .concat(partUidsSchemas);
    };
    const asRawOrDie$1 = function(
        label,
        schema,
        spec,
        partSchemas,
        partUidsSchemas,
    ) {
        const baseS = base(partSchemas, partUidsSchemas);
        return asRawOrDie(
            `${label} [SpecSchema]`,
            objOfOnly(baseS.concat(schema)),
            spec,
        );
    };

    const single$1 = function(owner, schema, factory, spec) {
        const specWithUid = supplyUid(spec);
        const detail = asRawOrDie$1(owner, schema, specWithUid, [], []);
        return factory(detail, specWithUid);
    };
    const composite = function(owner, schema, partTypes, factory, spec) {
        const specWithUid = supplyUid(spec);
        const partSchemas = schemas(partTypes);
        const partUidsSchema = defaultUidsSchema(partTypes);
        const detail = asRawOrDie$1(owner, schema, specWithUid, partSchemas, [
            partUidsSchema,
        ]);
        const subs = substitutes(owner, detail, partTypes);
        const components$1 = components(owner, detail, subs.internals());
        return factory(detail, components$1, specWithUid, subs.externals());
    };
    var supplyUid = function(spec) {
        return spec.hasOwnProperty('uid')
            ? spec
            : { ...spec, uid: generate$2('uid') };
    };

    function isSketchSpec(spec) {
        return spec.uid !== undefined;
    }
    const singleSchema = objOfOnly([
        strict$1('name'),
        strict$1('factory'),
        strict$1('configFields'),
        defaulted$1('apis', {}),
        defaulted$1('extraApis', {}),
    ]);
    const compositeSchema = objOfOnly([
        strict$1('name'),
        strict$1('factory'),
        strict$1('configFields'),
        strict$1('partFields'),
        defaulted$1('apis', {}),
        defaulted$1('extraApis', {}),
    ]);
    const single$2 = function(rawConfig) {
        const config = asRawOrDie(
            `Sketcher for ${rawConfig.name}`,
            singleSchema,
            rawConfig,
        );
        const sketch = function(spec) {
            return single$1(
                config.name,
                config.configFields,
                config.factory,
                spec,
            );
        };
        const apis = map$1(config.apis, makeApi);
        const extraApis = map$1(config.extraApis, function(f, k) {
            return markAsExtraApi(f, k);
        });
        return {
            name: constant(config.name),
            partFields: constant([]),
            configFields: constant(config.configFields),
            sketch,
            ...apis,
            ...extraApis,
        };
    };
    const composite$1 = function(rawConfig) {
        const config = asRawOrDie(
            `Sketcher for ${rawConfig.name}`,
            compositeSchema,
            rawConfig,
        );
        const sketch = function(spec) {
            return composite(
                config.name,
                config.configFields,
                config.partFields,
                config.factory,
                spec,
            );
        };
        const parts = generate$4(config.name, config.partFields);
        const apis = map$1(config.apis, makeApi);
        const extraApis = map$1(config.extraApis, function(f, k) {
            return markAsExtraApi(f, k);
        });
        return {
            name: constant(config.name),
            partFields: constant(config.partFields),
            configFields: constant(config.configFields),
            sketch,
            parts: constant(parts),
            ...apis,
            ...extraApis,
        };
    };

    const inside = function(target) {
        return (
            (name(target) === 'input' && get$2(target, 'type') !== 'radio') ||
            name(target) === 'textarea'
        );
    };

    const getCurrent = function(component, composeConfig, composeState) {
        return composeConfig.find(component);
    };

    const ComposeApis = /* #__PURE__ */ Object.freeze({
        getCurrent,
    });

    const ComposeSchema = [strict$1('find')];

    const Composing = create$1({
        fields: ComposeSchema,
        name: 'composing',
        apis: ComposeApis,
    });

    const dehighlightAllExcept = function(component, hConfig, hState, skip) {
        const highlighted = descendants(
            component.element(),
            `.${hConfig.highlightClass}`,
        );
        each(highlighted, function(h) {
            if (
                !exists(skip, function(skipComp) {
                    return skipComp.element() === h;
                })
            ) {
                remove$4(h, hConfig.highlightClass);
                component
                    .getSystem()
                    .getByDom(h)
                    .each(function(target) {
                        hConfig.onDehighlight(component, target);
                        emit(target, dehighlight());
                    });
            }
        });
    };
    const dehighlightAll = function(component, hConfig, hState) {
        return dehighlightAllExcept(component, hConfig, hState, []);
    };
    const dehighlight$1 = function(component, hConfig, hState, target) {
        if (isHighlighted(component, hConfig, hState, target)) {
            remove$4(target.element(), hConfig.highlightClass);
            hConfig.onDehighlight(component, target);
            emit(target, dehighlight());
        }
    };
    const highlight$1 = function(component, hConfig, hState, target) {
        dehighlightAllExcept(component, hConfig, hState, [target]);
        if (!isHighlighted(component, hConfig, hState, target)) {
            add$2(target.element(), hConfig.highlightClass);
            hConfig.onHighlight(component, target);
            emit(target, highlight());
        }
    };
    const highlightFirst = function(component, hConfig, hState) {
        getFirst(component, hConfig).each(function(firstComp) {
            highlight$1(component, hConfig, hState, firstComp);
        });
    };
    const highlightLast = function(component, hConfig, hState) {
        getLast(component, hConfig).each(function(lastComp) {
            highlight$1(component, hConfig, hState, lastComp);
        });
    };
    const highlightAt = function(component, hConfig, hState, index) {
        getByIndex(component, hConfig, hState, index).fold(
            function(err) {
                throw new Error(err);
            },
            function(firstComp) {
                highlight$1(component, hConfig, hState, firstComp);
            },
        );
    };
    const highlightBy = function(component, hConfig, hState, predicate) {
        const candidates = getCandidates(component, hConfig);
        const targetComp = find(candidates, predicate);
        targetComp.each(function(c) {
            highlight$1(component, hConfig, hState, c);
        });
    };
    var isHighlighted = function(component, hConfig, hState, queryTarget) {
        return has$2(queryTarget.element(), hConfig.highlightClass);
    };
    const getHighlighted = function(component, hConfig, hState) {
        return descendant$1(
            component.element(),
            `.${hConfig.highlightClass}`,
        ).bind(function(e) {
            return component
                .getSystem()
                .getByDom(e)
                .toOption();
        });
    };
    var getByIndex = function(component, hConfig, hState, index) {
        const items = descendants(component.element(), `.${hConfig.itemClass}`);
        return Option.from(items[index]).fold(function() {
            return Result.error(`No element found with index ${index}`);
        }, component.getSystem().getByDom);
    };
    var getFirst = function(component, hConfig, hState) {
        return descendant$1(component.element(), `.${hConfig.itemClass}`).bind(
            function(e) {
                return component
                    .getSystem()
                    .getByDom(e)
                    .toOption();
            },
        );
    };
    var getLast = function(component, hConfig, hState) {
        const items = descendants(component.element(), `.${hConfig.itemClass}`);
        const last =
            items.length > 0
                ? Option.some(items[items.length - 1])
                : Option.none();
        return last.bind(function(c) {
            return component
                .getSystem()
                .getByDom(c)
                .toOption();
        });
    };
    const getDelta = function(component, hConfig, hState, delta) {
        const items = descendants(component.element(), `.${hConfig.itemClass}`);
        const current = findIndex(items, function(item) {
            return has$2(item, hConfig.highlightClass);
        });
        return current.bind(function(selected) {
            const dest = cycleBy(selected, delta, 0, items.length - 1);
            return component
                .getSystem()
                .getByDom(items[dest])
                .toOption();
        });
    };
    const getPrevious = function(component, hConfig, hState) {
        return getDelta(component, hConfig, hState, -1);
    };
    const getNext = function(component, hConfig, hState) {
        return getDelta(component, hConfig, hState, +1);
    };
    var getCandidates = function(component, hConfig, hState) {
        const items = descendants(component.element(), `.${hConfig.itemClass}`);
        return cat(
            map(items, function(i) {
                return component
                    .getSystem()
                    .getByDom(i)
                    .toOption();
            }),
        );
    };

    const HighlightApis = /* #__PURE__ */ Object.freeze({
        dehighlightAll,
        dehighlight: dehighlight$1,
        highlight: highlight$1,
        highlightFirst,
        highlightLast,
        highlightAt,
        highlightBy,
        isHighlighted,
        getHighlighted,
        getFirst,
        getLast,
        getPrevious,
        getNext,
        getCandidates,
    });

    const HighlightSchema = [
        strict$1('highlightClass'),
        strict$1('itemClass'),
        onHandler('onHighlight'),
        onHandler('onDehighlight'),
    ];

    const Highlighting = create$1({
        fields: HighlightSchema,
        name: 'highlighting',
        apis: HighlightApis,
    });

    const BACKSPACE = function() {
        return [8];
    };
    const TAB = function() {
        return [9];
    };
    const ENTER = function() {
        return [13];
    };
    const ESCAPE = function() {
        return [27];
    };
    const SPACE = function() {
        return [32];
    };
    const LEFT = function() {
        return [37];
    };
    const UP = function() {
        return [38];
    };
    const RIGHT = function() {
        return [39];
    };
    const DOWN = function() {
        return [40];
    };

    const cyclePrev = function(values, index, predicate) {
        const before = reverse(values.slice(0, index));
        const after = reverse(values.slice(index + 1));
        return find(before.concat(after), predicate);
    };
    const tryPrev = function(values, index, predicate) {
        const before = reverse(values.slice(0, index));
        return find(before, predicate);
    };
    const cycleNext = function(values, index, predicate) {
        const before = values.slice(0, index);
        const after = values.slice(index + 1);
        return find(after.concat(before), predicate);
    };
    const tryNext = function(values, index, predicate) {
        const after = values.slice(index + 1);
        return find(after, predicate);
    };

    const inSet = function(keys) {
        return function(event) {
            const raw = event.raw();
            return contains(keys, raw.which);
        };
    };
    const and = function(preds) {
        return function(event) {
            return forall(preds, function(pred) {
                return pred(event);
            });
        };
    };
    const isShift = function(event) {
        const raw = event.raw();
        return raw.shiftKey === true;
    };
    const isControl = function(event) {
        const raw = event.raw();
        return raw.ctrlKey === true;
    };
    const isNotShift = not(isShift);

    const rule = function(matches, action) {
        return {
            matches,
            classification: action,
        };
    };
    const choose$2 = function(transitions, event) {
        const transition = find(transitions, function(t) {
            return t.matches(event);
        });
        return transition.map(function(t) {
            return t.classification;
        });
    };

    const reportFocusShifting = function(component, prevFocus, newFocus) {
        const noChange = prevFocus.exists(function(p) {
            return newFocus.exists(function(n) {
                return eq(n, p);
            });
        });
        if (!noChange) {
            emitWith(component, focusShifted(), {
                prevFocus,
                newFocus,
            });
        }
    };
    const dom = function() {
        const get = function(component) {
            return search(component.element());
        };
        const set = function(component, focusee) {
            const prevFocus = get(component);
            component.getSystem().triggerFocus(focusee, component.element());
            const newFocus = get(component);
            reportFocusShifting(component, prevFocus, newFocus);
        };
        return {
            get,
            set,
        };
    };
    const highlights = function() {
        const get = function(component) {
            return Highlighting.getHighlighted(component).map(function(item) {
                return item.element();
            });
        };
        const set = function(component, element) {
            const prevFocus = get(component);
            component
                .getSystem()
                .getByDom(element)
                .fold(noop, function(item) {
                    Highlighting.highlight(component, item);
                });
            const newFocus = get(component);
            reportFocusShifting(component, prevFocus, newFocus);
        };
        return {
            get,
            set,
        };
    };

    let FocusInsideModes;
    (function(FocusInsideModes) {
        FocusInsideModes.OnFocusMode = 'onFocus';
        FocusInsideModes.OnEnterOrSpaceMode = 'onEnterOrSpace';
        FocusInsideModes.OnApiMode = 'onApi';
    })(FocusInsideModes || (FocusInsideModes = {}));

    const typical = function(
        infoSchema,
        stateInit,
        getKeydownRules,
        getKeyupRules,
        optFocusIn,
    ) {
        const schema = function() {
            return infoSchema.concat([
                defaulted$1('focusManager', dom()),
                defaultedOf(
                    'focusInside',
                    'onFocus',
                    valueOf(function(val) {
                        return contains(
                            ['onFocus', 'onEnterOrSpace', 'onApi'],
                            val,
                        )
                            ? Result.value(val)
                            : Result.error('Invalid value for focusInside');
                    }),
                ),
                output('handler', me),
                output('state', stateInit),
                output('sendFocusIn', optFocusIn),
            ]);
        };
        const processKey = function(
            component,
            simulatedEvent,
            getRules,
            keyingConfig,
            keyingState,
        ) {
            const rules = getRules(
                component,
                simulatedEvent,
                keyingConfig,
                keyingState,
            );
            return choose$2(rules, simulatedEvent.event()).bind(function(rule) {
                return rule(
                    component,
                    simulatedEvent,
                    keyingConfig,
                    keyingState,
                );
            });
        };
        const toEvents = function(keyingConfig, keyingState) {
            const onFocusHandler =
                keyingConfig.focusInside !== FocusInsideModes.OnFocusMode
                    ? Option.none()
                    : optFocusIn(keyingConfig).map(function(focusIn) {
                          return run(focus(), function(
                              component,
                              simulatedEvent,
                          ) {
                              focusIn(component, keyingConfig, keyingState);
                              simulatedEvent.stop();
                          });
                      });
            const tryGoInsideComponent = function(component, simulatedEvent) {
                const isEnterOrSpace = inSet(SPACE().concat(ENTER()))(
                    simulatedEvent.event(),
                );
                if (
                    keyingConfig.focusInside ===
                        FocusInsideModes.OnEnterOrSpaceMode &&
                    isEnterOrSpace &&
                    isSource(component, simulatedEvent)
                ) {
                    optFocusIn(keyingConfig).each(function(focusIn) {
                        focusIn(component, keyingConfig, keyingState);
                        simulatedEvent.stop();
                    });
                }
            };
            return derive(
                onFocusHandler.toArray().concat([
                    run(keydown(), function(component, simulatedEvent) {
                        processKey(
                            component,
                            simulatedEvent,
                            getKeydownRules,
                            keyingConfig,
                            keyingState,
                        ).fold(
                            function() {
                                tryGoInsideComponent(component, simulatedEvent);
                            },
                            function(_) {
                                simulatedEvent.stop();
                            },
                        );
                    }),
                    run(keyup(), function(component, simulatedEvent) {
                        processKey(
                            component,
                            simulatedEvent,
                            getKeyupRules,
                            keyingConfig,
                            keyingState,
                        ).each(function(_) {
                            simulatedEvent.stop();
                        });
                    }),
                ]),
            );
        };
        var me = {
            schema,
            processKey,
            toEvents,
        };
        return me;
    };

    const create$3 = function(cyclicField) {
        const schema = [
            option('onEscape'),
            option('onEnter'),
            defaulted$1(
                'selector',
                '[data-alloy-tabstop="true"]:not(:disabled)',
            ),
            defaulted$1('firstTabstop', 0),
            defaulted$1('useTabstopAt', constant(true)),
            option('visibilitySelector'),
        ].concat([cyclicField]);
        const isVisible = function(tabbingConfig, element) {
            const target = tabbingConfig.visibilitySelector
                .bind(function(sel) {
                    return closest$3(element, sel);
                })
                .getOr(element);
            return get$6(target) > 0;
        };
        const findInitial = function(component, tabbingConfig) {
            const tabstops = descendants(
                component.element(),
                tabbingConfig.selector,
            );
            const visibles = filter(tabstops, function(elem) {
                return isVisible(tabbingConfig, elem);
            });
            return Option.from(visibles[tabbingConfig.firstTabstop]);
        };
        const findCurrent = function(component, tabbingConfig) {
            return tabbingConfig.focusManager
                .get(component)
                .bind(function(elem) {
                    return closest$3(elem, tabbingConfig.selector);
                });
        };
        const isTabstop = function(tabbingConfig, element) {
            return (
                isVisible(tabbingConfig, element) &&
                tabbingConfig.useTabstopAt(element)
            );
        };
        const focusIn = function(component, tabbingConfig) {
            findInitial(component, tabbingConfig).each(function(target) {
                tabbingConfig.focusManager.set(component, target);
            });
        };
        const goFromTabstop = function(
            component,
            tabstops,
            stopIndex,
            tabbingConfig,
            cycle,
        ) {
            return cycle(tabstops, stopIndex, function(elem) {
                return isTabstop(tabbingConfig, elem);
            }).fold(
                function() {
                    return tabbingConfig.cyclic
                        ? Option.some(true)
                        : Option.none();
                },
                function(target) {
                    tabbingConfig.focusManager.set(component, target);
                    return Option.some(true);
                },
            );
        };
        const go = function(component, simulatedEvent, tabbingConfig, cycle) {
            const tabstops = descendants(
                component.element(),
                tabbingConfig.selector,
            );
            return findCurrent(component, tabbingConfig).bind(function(
                tabstop,
            ) {
                const optStopIndex = findIndex(tabstops, curry(eq, tabstop));
                return optStopIndex.bind(function(stopIndex) {
                    return goFromTabstop(
                        component,
                        tabstops,
                        stopIndex,
                        tabbingConfig,
                        cycle,
                    );
                });
            });
        };
        const goBackwards = function(
            component,
            simulatedEvent,
            tabbingConfig,
            tabbingState,
        ) {
            const navigate = tabbingConfig.cyclic ? cyclePrev : tryPrev;
            return go(component, simulatedEvent, tabbingConfig, navigate);
        };
        const goForwards = function(
            component,
            simulatedEvent,
            tabbingConfig,
            tabbingState,
        ) {
            const navigate = tabbingConfig.cyclic ? cycleNext : tryNext;
            return go(component, simulatedEvent, tabbingConfig, navigate);
        };
        const execute = function(
            component,
            simulatedEvent,
            tabbingConfig,
            tabbingState,
        ) {
            return tabbingConfig.onEnter.bind(function(f) {
                return f(component, simulatedEvent);
            });
        };
        const exit = function(
            component,
            simulatedEvent,
            tabbingConfig,
            tabbingState,
        ) {
            return tabbingConfig.onEscape.bind(function(f) {
                return f(component, simulatedEvent);
            });
        };
        const getKeydownRules = constant([
            rule(and([isShift, inSet(TAB())]), goBackwards),
            rule(inSet(TAB()), goForwards),
            rule(inSet(ESCAPE()), exit),
            rule(and([isNotShift, inSet(ENTER())]), execute),
        ]);
        const getKeyupRules = constant([]);
        return typical(
            schema,
            NoState.init,
            getKeydownRules,
            getKeyupRules,
            function() {
                return Option.some(focusIn);
            },
        );
    };

    const AcyclicType = create$3(state$1('cyclic', constant(false)));

    const CyclicType = create$3(state$1('cyclic', constant(true)));

    const doDefaultExecute = function(component, simulatedEvent, focused) {
        dispatch(component, focused, execute());
        return Option.some(true);
    };
    const defaultExecute = function(component, simulatedEvent, focused) {
        return inside(focused) && inSet(SPACE())(simulatedEvent.event())
            ? Option.none()
            : doDefaultExecute(component, simulatedEvent, focused);
    };
    const stopEventForFirefox = function(component, simulatedEvent) {
        return Option.some(true);
    };

    const schema$4 = [
        defaulted$1('execute', defaultExecute),
        defaulted$1('useSpace', false),
        defaulted$1('useEnter', true),
        defaulted$1('useControlEnter', false),
        defaulted$1('useDown', false),
    ];
    const execute$1 = function(component, simulatedEvent, executeConfig) {
        return executeConfig.execute(
            component,
            simulatedEvent,
            component.element(),
        );
    };
    const getKeydownRules = function(
        component,
        simulatedEvent,
        executeConfig,
        executeState,
    ) {
        const spaceExec =
            executeConfig.useSpace && !inside(component.element())
                ? SPACE()
                : [];
        const enterExec = executeConfig.useEnter ? ENTER() : [];
        const downExec = executeConfig.useDown ? DOWN() : [];
        const execKeys = spaceExec.concat(enterExec).concat(downExec);
        return [rule(inSet(execKeys), execute$1)].concat(
            executeConfig.useControlEnter
                ? [rule(and([isControl, inSet(ENTER())]), execute$1)]
                : [],
        );
    };
    const getKeyupRules = function(
        component,
        simulatedEvent,
        executeConfig,
        executeState,
    ) {
        return executeConfig.useSpace && !inside(component.element())
            ? [rule(inSet(SPACE()), stopEventForFirefox)]
            : [];
    };
    const ExecutionType = typical(
        schema$4,
        NoState.init,
        getKeydownRules,
        getKeyupRules,
        function() {
            return Option.none();
        },
    );

    const flatgrid = function(spec) {
        const dimensions = Cell(Option.none());
        const setGridSize = function(numRows, numColumns) {
            dimensions.set(
                Option.some({
                    numRows: constant(numRows),
                    numColumns: constant(numColumns),
                }),
            );
        };
        const getNumRows = function() {
            return dimensions.get().map(function(d) {
                return d.numRows();
            });
        };
        const getNumColumns = function() {
            return dimensions.get().map(function(d) {
                return d.numColumns();
            });
        };
        return nu$5({
            readState() {
                return dimensions
                    .get()
                    .map(function(d) {
                        return {
                            numRows: d.numRows(),
                            numColumns: d.numColumns(),
                        };
                    })
                    .getOr({
                        numRows: '?',
                        numColumns: '?',
                    });
            },
            setGridSize,
            getNumRows,
            getNumColumns,
        });
    };
    const init$2 = function(spec) {
        return spec.state(spec);
    };

    const KeyingState = /* #__PURE__ */ Object.freeze({
        flatgrid,
        init: init$2,
    });

    const useH = function(movement) {
        return function(component, simulatedEvent, config, state) {
            const move = movement(component.element());
            return use(move, component, simulatedEvent, config, state);
        };
    };
    const west$2 = function(moveLeft, moveRight) {
        const movement = onDirection(moveLeft, moveRight);
        return useH(movement);
    };
    const east$2 = function(moveLeft, moveRight) {
        const movement = onDirection(moveRight, moveLeft);
        return useH(movement);
    };
    const useV = function(move) {
        return function(component, simulatedEvent, config, state) {
            return use(move, component, simulatedEvent, config, state);
        };
    };
    var use = function(move, component, simulatedEvent, config, state) {
        const outcome = config.focusManager
            .get(component)
            .bind(function(focused) {
                return move(component.element(), focused, config, state);
            });
        return outcome.map(function(newFocus) {
            config.focusManager.set(component, newFocus);
            return true;
        });
    };
    const north$2 = useV;
    const south$2 = useV;
    const move = useV;

    const isHidden = function(dom) {
        return dom.offsetWidth <= 0 && dom.offsetHeight <= 0;
    };
    const isVisible = function(element) {
        const dom = element.dom();
        return !isHidden(dom);
    };

    const indexInfo = MixedBag(['index', 'candidates'], []);
    const locate$2 = function(candidates, predicate) {
        return findIndex(candidates, predicate).map(function(index) {
            return indexInfo({
                index,
                candidates,
            });
        });
    };

    const locateVisible = function(container, current, selector) {
        const predicate = curry(eq, current);
        const candidates = descendants(container, selector);
        const visible = filter(candidates, isVisible);
        return locate$2(visible, predicate);
    };
    const findIndex$1 = function(elements, target) {
        return findIndex(elements, function(elem) {
            return eq(target, elem);
        });
    };

    const withGrid = function(values, index, numCols, f) {
        const oldRow = Math.floor(index / numCols);
        const oldColumn = index % numCols;
        return f(oldRow, oldColumn).bind(function(address) {
            const newIndex = address.row() * numCols + address.column();
            return newIndex >= 0 && newIndex < values.length
                ? Option.some(values[newIndex])
                : Option.none();
        });
    };
    const cycleHorizontal = function(values, index, numRows, numCols, delta) {
        return withGrid(values, index, numCols, function(oldRow, oldColumn) {
            const onLastRow = oldRow === numRows - 1;
            const colsInRow = onLastRow
                ? values.length - oldRow * numCols
                : numCols;
            const newColumn = cycleBy(oldColumn, delta, 0, colsInRow - 1);
            return Option.some({
                row: constant(oldRow),
                column: constant(newColumn),
            });
        });
    };
    const cycleVertical = function(values, index, numRows, numCols, delta) {
        return withGrid(values, index, numCols, function(oldRow, oldColumn) {
            const newRow = cycleBy(oldRow, delta, 0, numRows - 1);
            const onLastRow = newRow === numRows - 1;
            const colsInRow = onLastRow
                ? values.length - newRow * numCols
                : numCols;
            const newCol = cap(oldColumn, 0, colsInRow - 1);
            return Option.some({
                row: constant(newRow),
                column: constant(newCol),
            });
        });
    };
    const cycleRight = function(values, index, numRows, numCols) {
        return cycleHorizontal(values, index, numRows, numCols, +1);
    };
    const cycleLeft = function(values, index, numRows, numCols) {
        return cycleHorizontal(values, index, numRows, numCols, -1);
    };
    const cycleUp = function(values, index, numRows, numCols) {
        return cycleVertical(values, index, numRows, numCols, -1);
    };
    const cycleDown = function(values, index, numRows, numCols) {
        return cycleVertical(values, index, numRows, numCols, +1);
    };

    const schema$5 = [
        strict$1('selector'),
        defaulted$1('execute', defaultExecute),
        onKeyboardHandler('onEscape'),
        defaulted$1('captureTab', false),
        initSize(),
    ];
    const focusIn = function(component, gridConfig, gridState) {
        descendant$1(component.element(), gridConfig.selector).each(function(
            first,
        ) {
            gridConfig.focusManager.set(component, first);
        });
    };
    const findCurrent = function(component, gridConfig) {
        return gridConfig.focusManager.get(component).bind(function(elem) {
            return closest$3(elem, gridConfig.selector);
        });
    };
    const execute$2 = function(
        component,
        simulatedEvent,
        gridConfig,
        gridState,
    ) {
        return findCurrent(component, gridConfig).bind(function(focused) {
            return gridConfig.execute(component, simulatedEvent, focused);
        });
    };
    const doMove = function(cycle) {
        return function(element, focused, gridConfig, gridState) {
            return locateVisible(element, focused, gridConfig.selector).bind(
                function(identified) {
                    return cycle(
                        identified.candidates(),
                        identified.index(),
                        gridState
                            .getNumRows()
                            .getOr(gridConfig.initSize.numRows),
                        gridState
                            .getNumColumns()
                            .getOr(gridConfig.initSize.numColumns),
                    );
                },
            );
        };
    };
    const handleTab = function(
        component,
        simulatedEvent,
        gridConfig,
        gridState,
    ) {
        return gridConfig.captureTab ? Option.some(true) : Option.none();
    };
    const doEscape = function(
        component,
        simulatedEvent,
        gridConfig,
        gridState,
    ) {
        return gridConfig.onEscape(component, simulatedEvent);
    };
    const moveLeft = doMove(cycleLeft);
    const moveRight = doMove(cycleRight);
    const moveNorth = doMove(cycleUp);
    const moveSouth = doMove(cycleDown);
    const getKeydownRules$1 = constant([
        rule(inSet(LEFT()), west$2(moveLeft, moveRight)),
        rule(inSet(RIGHT()), east$2(moveLeft, moveRight)),
        rule(inSet(UP()), north$2(moveNorth)),
        rule(inSet(DOWN()), south$2(moveSouth)),
        rule(and([isShift, inSet(TAB())]), handleTab),
        rule(and([isNotShift, inSet(TAB())]), handleTab),
        rule(inSet(ESCAPE()), doEscape),
        rule(inSet(SPACE().concat(ENTER())), execute$2),
    ]);
    const getKeyupRules$1 = constant([
        rule(inSet(SPACE()), stopEventForFirefox),
    ]);
    const FlatgridType = typical(
        schema$5,
        flatgrid,
        getKeydownRules$1,
        getKeyupRules$1,
        function() {
            return Option.some(focusIn);
        },
    );

    const horizontal = function(container, selector, current, delta) {
        const isDisabledButton = function(candidate) {
            return (
                name(candidate) === 'button' &&
                get$2(candidate, 'disabled') === 'disabled'
            );
        };
        var tryCycle = function(initial, index, candidates) {
            const newIndex = cycleBy(index, delta, 0, candidates.length - 1);
            if (newIndex === initial) {
                return Option.none();
            }
            return isDisabledButton(candidates[newIndex])
                ? tryCycle(initial, newIndex, candidates)
                : Option.from(candidates[newIndex]);
        };
        return locateVisible(container, current, selector).bind(function(
            identified,
        ) {
            const index = identified.index();
            const candidates = identified.candidates();
            return tryCycle(index, index, candidates);
        });
    };

    const schema$6 = [
        strict$1('selector'),
        defaulted$1('getInitial', Option.none),
        defaulted$1('execute', defaultExecute),
        onKeyboardHandler('onEscape'),
        defaulted$1('executeOnMove', false),
        defaulted$1('allowVertical', true),
    ];
    const findCurrent$1 = function(component, flowConfig) {
        return flowConfig.focusManager.get(component).bind(function(elem) {
            return closest$3(elem, flowConfig.selector);
        });
    };
    const execute$3 = function(component, simulatedEvent, flowConfig) {
        return findCurrent$1(component, flowConfig).bind(function(focused) {
            return flowConfig.execute(component, simulatedEvent, focused);
        });
    };
    const focusIn$1 = function(component, flowConfig) {
        flowConfig
            .getInitial(component)
            .orThunk(function() {
                return descendant$1(component.element(), flowConfig.selector);
            })
            .each(function(first) {
                flowConfig.focusManager.set(component, first);
            });
    };
    const moveLeft$1 = function(element, focused, info) {
        return horizontal(element, info.selector, focused, -1);
    };
    const moveRight$1 = function(element, focused, info) {
        return horizontal(element, info.selector, focused, +1);
    };
    const doMove$1 = function(movement) {
        return function(component, simulatedEvent, flowConfig) {
            return movement(component, simulatedEvent, flowConfig).bind(
                function() {
                    return flowConfig.executeOnMove
                        ? execute$3(component, simulatedEvent, flowConfig)
                        : Option.some(true);
                },
            );
        };
    };
    const doEscape$1 = function(
        component,
        simulatedEvent,
        flowConfig,
        _flowState,
    ) {
        return flowConfig.onEscape(component, simulatedEvent);
    };
    const getKeydownRules$2 = function(
        _component,
        _se,
        flowConfig,
        _flowState,
    ) {
        const westMovers = LEFT().concat(flowConfig.allowVertical ? UP() : []);
        const eastMovers = RIGHT().concat(
            flowConfig.allowVertical ? DOWN() : [],
        );
        return [
            rule(inSet(westMovers), doMove$1(west$2(moveLeft$1, moveRight$1))),
            rule(inSet(eastMovers), doMove$1(east$2(moveLeft$1, moveRight$1))),
            rule(inSet(ENTER()), execute$3),
            rule(inSet(SPACE()), execute$3),
            rule(inSet(ESCAPE()), doEscape$1),
        ];
    };
    const getKeyupRules$2 = constant([
        rule(inSet(SPACE()), stopEventForFirefox),
    ]);
    const FlowType = typical(
        schema$6,
        NoState.init,
        getKeydownRules$2,
        getKeyupRules$2,
        function() {
            return Option.some(focusIn$1);
        },
    );

    const outcome = MixedBag(['rowIndex', 'columnIndex', 'cell'], []);
    const toCell = function(matrix, rowIndex, columnIndex) {
        return Option.from(matrix[rowIndex]).bind(function(row) {
            return Option.from(row[columnIndex]).map(function(cell) {
                return outcome({
                    rowIndex,
                    columnIndex,
                    cell,
                });
            });
        });
    };
    const cycleHorizontal$1 = function(matrix, rowIndex, startCol, deltaCol) {
        const row = matrix[rowIndex];
        const colsInRow = row.length;
        const newColIndex = cycleBy(startCol, deltaCol, 0, colsInRow - 1);
        return toCell(matrix, rowIndex, newColIndex);
    };
    const cycleVertical$1 = function(matrix, colIndex, startRow, deltaRow) {
        const nextRowIndex = cycleBy(startRow, deltaRow, 0, matrix.length - 1);
        const colsInNextRow = matrix[nextRowIndex].length;
        const nextColIndex = cap(colIndex, 0, colsInNextRow - 1);
        return toCell(matrix, nextRowIndex, nextColIndex);
    };
    const moveHorizontal = function(matrix, rowIndex, startCol, deltaCol) {
        const row = matrix[rowIndex];
        const colsInRow = row.length;
        const newColIndex = cap(startCol + deltaCol, 0, colsInRow - 1);
        return toCell(matrix, rowIndex, newColIndex);
    };
    const moveVertical = function(matrix, colIndex, startRow, deltaRow) {
        const nextRowIndex = cap(startRow + deltaRow, 0, matrix.length - 1);
        const colsInNextRow = matrix[nextRowIndex].length;
        const nextColIndex = cap(colIndex, 0, colsInNextRow - 1);
        return toCell(matrix, nextRowIndex, nextColIndex);
    };
    const cycleRight$1 = function(matrix, startRow, startCol) {
        return cycleHorizontal$1(matrix, startRow, startCol, +1);
    };
    const cycleLeft$1 = function(matrix, startRow, startCol) {
        return cycleHorizontal$1(matrix, startRow, startCol, -1);
    };
    const cycleUp$1 = function(matrix, startRow, startCol) {
        return cycleVertical$1(matrix, startCol, startRow, -1);
    };
    const cycleDown$1 = function(matrix, startRow, startCol) {
        return cycleVertical$1(matrix, startCol, startRow, +1);
    };
    const moveLeft$2 = function(matrix, startRow, startCol) {
        return moveHorizontal(matrix, startRow, startCol, -1);
    };
    const moveRight$2 = function(matrix, startRow, startCol) {
        return moveHorizontal(matrix, startRow, startCol, +1);
    };
    const moveUp = function(matrix, startRow, startCol) {
        return moveVertical(matrix, startCol, startRow, -1);
    };
    const moveDown = function(matrix, startRow, startCol) {
        return moveVertical(matrix, startCol, startRow, +1);
    };

    const schema$7 = [
        strictObjOf('selectors', [strict$1('row'), strict$1('cell')]),
        defaulted$1('cycles', true),
        defaulted$1('previousSelector', Option.none),
        defaulted$1('execute', defaultExecute),
    ];
    const focusIn$2 = function(component, matrixConfig) {
        const focused = matrixConfig
            .previousSelector(component)
            .orThunk(function() {
                const { selectors } = matrixConfig;
                return descendant$1(component.element(), selectors.cell);
            });
        focused.each(function(cell) {
            matrixConfig.focusManager.set(component, cell);
        });
    };
    const execute$4 = function(component, simulatedEvent, matrixConfig) {
        return search(component.element()).bind(function(focused) {
            return matrixConfig.execute(component, simulatedEvent, focused);
        });
    };
    const toMatrix = function(rows, matrixConfig) {
        return map(rows, function(row) {
            return descendants(row, matrixConfig.selectors.cell);
        });
    };
    const doMove$2 = function(ifCycle, ifMove) {
        return function(element, focused, matrixConfig) {
            const move = matrixConfig.cycles ? ifCycle : ifMove;
            return closest$3(focused, matrixConfig.selectors.row).bind(function(
                inRow,
            ) {
                const cellsInRow = descendants(
                    inRow,
                    matrixConfig.selectors.cell,
                );
                return findIndex$1(cellsInRow, focused).bind(function(
                    colIndex,
                ) {
                    const allRows = descendants(
                        element,
                        matrixConfig.selectors.row,
                    );
                    return findIndex$1(allRows, inRow).bind(function(rowIndex) {
                        const matrix = toMatrix(allRows, matrixConfig);
                        return move(matrix, rowIndex, colIndex).map(function(
                            next,
                        ) {
                            return next.cell();
                        });
                    });
                });
            });
        };
    };
    const moveLeft$3 = doMove$2(cycleLeft$1, moveLeft$2);
    const moveRight$3 = doMove$2(cycleRight$1, moveRight$2);
    const moveNorth$1 = doMove$2(cycleUp$1, moveUp);
    const moveSouth$1 = doMove$2(cycleDown$1, moveDown);
    const getKeydownRules$3 = constant([
        rule(inSet(LEFT()), west$2(moveLeft$3, moveRight$3)),
        rule(inSet(RIGHT()), east$2(moveLeft$3, moveRight$3)),
        rule(inSet(UP()), north$2(moveNorth$1)),
        rule(inSet(DOWN()), south$2(moveSouth$1)),
        rule(inSet(SPACE().concat(ENTER())), execute$4),
    ]);
    const getKeyupRules$3 = constant([
        rule(inSet(SPACE()), stopEventForFirefox),
    ]);
    const MatrixType = typical(
        schema$7,
        NoState.init,
        getKeydownRules$3,
        getKeyupRules$3,
        function() {
            return Option.some(focusIn$2);
        },
    );

    const schema$8 = [
        strict$1('selector'),
        defaulted$1('execute', defaultExecute),
        defaulted$1('moveOnTab', false),
    ];
    const execute$5 = function(component, simulatedEvent, menuConfig) {
        return menuConfig.focusManager.get(component).bind(function(focused) {
            return menuConfig.execute(component, simulatedEvent, focused);
        });
    };
    const focusIn$3 = function(component, menuConfig) {
        descendant$1(component.element(), menuConfig.selector).each(function(
            first,
        ) {
            menuConfig.focusManager.set(component, first);
        });
    };
    const moveUp$1 = function(element, focused, info) {
        return horizontal(element, info.selector, focused, -1);
    };
    const moveDown$1 = function(element, focused, info) {
        return horizontal(element, info.selector, focused, +1);
    };
    const fireShiftTab = function(component, simulatedEvent, menuConfig) {
        return menuConfig.moveOnTab
            ? move(moveUp$1)(component, simulatedEvent, menuConfig)
            : Option.none();
    };
    const fireTab = function(component, simulatedEvent, menuConfig) {
        return menuConfig.moveOnTab
            ? move(moveDown$1)(component, simulatedEvent, menuConfig)
            : Option.none();
    };
    const getKeydownRules$4 = constant([
        rule(inSet(UP()), move(moveUp$1)),
        rule(inSet(DOWN()), move(moveDown$1)),
        rule(and([isShift, inSet(TAB())]), fireShiftTab),
        rule(and([isNotShift, inSet(TAB())]), fireTab),
        rule(inSet(ENTER()), execute$5),
        rule(inSet(SPACE()), execute$5),
    ]);
    const getKeyupRules$4 = constant([
        rule(inSet(SPACE()), stopEventForFirefox),
    ]);
    const MenuType = typical(
        schema$8,
        NoState.init,
        getKeydownRules$4,
        getKeyupRules$4,
        function() {
            return Option.some(focusIn$3);
        },
    );

    const schema$9 = [
        onKeyboardHandler('onSpace'),
        onKeyboardHandler('onEnter'),
        onKeyboardHandler('onShiftEnter'),
        onKeyboardHandler('onLeft'),
        onKeyboardHandler('onRight'),
        onKeyboardHandler('onTab'),
        onKeyboardHandler('onShiftTab'),
        onKeyboardHandler('onUp'),
        onKeyboardHandler('onDown'),
        onKeyboardHandler('onEscape'),
        defaulted$1('stopSpaceKeyup', false),
        option('focusIn'),
    ];
    const getKeydownRules$5 = function(component, simulatedEvent, specialInfo) {
        return [
            rule(inSet(SPACE()), specialInfo.onSpace),
            rule(and([isNotShift, inSet(ENTER())]), specialInfo.onEnter),
            rule(and([isShift, inSet(ENTER())]), specialInfo.onShiftEnter),
            rule(and([isShift, inSet(TAB())]), specialInfo.onShiftTab),
            rule(and([isNotShift, inSet(TAB())]), specialInfo.onTab),
            rule(inSet(UP()), specialInfo.onUp),
            rule(inSet(DOWN()), specialInfo.onDown),
            rule(inSet(LEFT()), specialInfo.onLeft),
            rule(inSet(RIGHT()), specialInfo.onRight),
            rule(inSet(SPACE()), specialInfo.onSpace),
            rule(inSet(ESCAPE()), specialInfo.onEscape),
        ];
    };
    const getKeyupRules$5 = function(component, simulatedEvent, specialInfo) {
        return specialInfo.stopSpaceKeyup
            ? [rule(inSet(SPACE()), stopEventForFirefox)]
            : [];
    };
    const SpecialType = typical(
        schema$9,
        NoState.init,
        getKeydownRules$5,
        getKeyupRules$5,
        function(specialInfo) {
            return specialInfo.focusIn;
        },
    );

    const acyclic = AcyclicType.schema();
    const cyclic = CyclicType.schema();
    const flow = FlowType.schema();
    const flatgrid$1 = FlatgridType.schema();
    const matrix = MatrixType.schema();
    const execution = ExecutionType.schema();
    const menu = MenuType.schema();
    const special = SpecialType.schema();

    const KeyboardBranches = /* #__PURE__ */ Object.freeze({
        acyclic,
        cyclic,
        flow,
        flatgrid: flatgrid$1,
        matrix,
        execution,
        menu,
        special,
    });

    const Keying = createModes$1({
        branchKey: 'mode',
        branches: KeyboardBranches,
        name: 'keying',
        active: {
            events(keyingConfig, keyingState) {
                const { handler } = keyingConfig;
                return handler.toEvents(keyingConfig, keyingState);
            },
        },
        apis: {
            focusIn(component, keyConfig, keyState) {
                keyConfig.sendFocusIn(keyConfig).fold(
                    function() {
                        component
                            .getSystem()
                            .triggerFocus(
                                component.element(),
                                component.element(),
                            );
                    },
                    function(sendFocusIn) {
                        sendFocusIn(component, keyConfig, keyState);
                    },
                );
            },
            setGridSize(component, keyConfig, keyState, numRows, numColumns) {
                if (!hasKey$1(keyState, 'setGridSize')) {
                    domGlobals.console.error(
                        'Layout does not support setGridSize',
                    );
                } else {
                    keyState.setGridSize(numRows, numColumns);
                }
            },
        },
        state: KeyingState,
    });

    const set$5 = function(component, replaceConfig, replaceState, data) {
        preserve(function() {
            const newChildren = map(data, component.getSystem().build);
            replaceChildren(component, newChildren);
        }, component.element());
    };
    const insert = function(component, replaceConfig, insertion, childSpec) {
        const child = component.getSystem().build(childSpec);
        attachWith(component, child, insertion);
    };
    const append$2 = function(
        component,
        replaceConfig,
        replaceState,
        appendee,
    ) {
        insert(component, replaceConfig, append, appendee);
    };
    const prepend$1 = function(
        component,
        replaceConfig,
        replaceState,
        prependee,
    ) {
        insert(component, replaceConfig, prepend, prependee);
    };
    const remove$7 = function(component, replaceConfig, replaceState, removee) {
        const children = contents(component);
        const foundChild = find(children, function(child) {
            return eq(removee.element(), child.element());
        });
        foundChild.each(detach);
    };
    var contents = function(component, replaceConfig) {
        return component.components();
    };
    const replaceAt = function(
        component,
        replaceConfig,
        replaceState,
        replaceeIndex,
        replacer,
    ) {
        const children = contents(component);
        return Option.from(children[replaceeIndex]).map(function(replacee) {
            remove$7(component, replaceConfig, replaceState, replacee);
            replacer.each(function(r) {
                insert(
                    component,
                    replaceConfig,
                    function(p, c) {
                        appendAt(p, c, replaceeIndex);
                    },
                    r,
                );
            });
            return replacee;
        });
    };
    const replaceBy = function(
        component,
        replaceConfig,
        replaceState,
        replaceePred,
        replacer,
    ) {
        const children = contents(component);
        return findIndex(children, replaceePred).bind(function(replaceeIndex) {
            return replaceAt(
                component,
                replaceConfig,
                replaceState,
                replaceeIndex,
                replacer,
            );
        });
    };

    const ReplaceApis = /* #__PURE__ */ Object.freeze({
        append: append$2,
        prepend: prepend$1,
        remove: remove$7,
        replaceAt,
        replaceBy,
        set: set$5,
        contents,
    });

    const Replacing = create$1({
        fields: [],
        name: 'replacing',
        apis: ReplaceApis,
    });

    const events$4 = function(name, eventHandlers) {
        const events = derive(eventHandlers);
        return create$1({
            fields: [strict$1('enabled')],
            name,
            active: { events: constant(events) },
        });
    };
    const config = function(name, eventHandlers) {
        const me = events$4(name, eventHandlers);
        return {
            key: name,
            value: {
                config: {},
                me,
                configAsRaw: constant({}),
                initialConfig: {},
                state: NoState,
            },
        };
    };

    const focus$2 = function(component, focusConfig) {
        if (!focusConfig.ignore) {
            focus$1(component.element());
            focusConfig.onFocus(component);
        }
    };
    const blur$1 = function(component, focusConfig) {
        if (!focusConfig.ignore) {
            blur(component.element());
        }
    };
    const isFocused = function(component) {
        return hasFocus(component.element());
    };

    const FocusApis = /* #__PURE__ */ Object.freeze({
        focus: focus$2,
        blur: blur$1,
        isFocused,
    });

    const exhibit$1 = function(base, focusConfig) {
        const mod = focusConfig.ignore
            ? {}
            : { attributes: { tabindex: '-1' } };
        return nu$6(mod);
    };
    const events$5 = function(focusConfig) {
        return derive(
            [
                run(focus(), function(component, simulatedEvent) {
                    focus$2(component, focusConfig);
                    simulatedEvent.stop();
                }),
            ].concat(
                focusConfig.stopMousedown
                    ? [
                          run(mousedown(), function(_, simulatedEvent) {
                              simulatedEvent.event().prevent();
                          }),
                      ]
                    : [],
            ),
        );
    };

    const ActiveFocus = /* #__PURE__ */ Object.freeze({
        exhibit: exhibit$1,
        events: events$5,
    });

    const FocusSchema = [
        onHandler('onFocus'),
        defaulted$1('stopMousedown', false),
        defaulted$1('ignore', false),
    ];

    const Focusing = create$1({
        fields: FocusSchema,
        name: 'focusing',
        active: ActiveFocus,
        apis: FocusApis,
    });

    const updateAriaState = function(component, toggleConfig, toggleState) {
        const ariaInfo = toggleConfig.aria;
        ariaInfo.update(component, ariaInfo, toggleState.get());
    };
    const updateClass = function(component, toggleConfig, toggleState) {
        toggleConfig.toggleClass.each(function(toggleClass) {
            if (toggleState.get()) {
                add$2(component.element(), toggleClass);
            } else {
                remove$4(component.element(), toggleClass);
            }
        });
    };
    const toggle = function(component, toggleConfig, toggleState) {
        set$6(component, toggleConfig, toggleState, !toggleState.get());
    };
    const on$1 = function(component, toggleConfig, toggleState) {
        toggleState.set(true);
        updateClass(component, toggleConfig, toggleState);
        updateAriaState(component, toggleConfig, toggleState);
    };
    const off = function(component, toggleConfig, toggleState) {
        toggleState.set(false);
        updateClass(component, toggleConfig, toggleState);
        updateAriaState(component, toggleConfig, toggleState);
    };
    var set$6 = function(component, toggleConfig, toggleState, state) {
        const action = state ? on$1 : off;
        action(component, toggleConfig, toggleState);
    };
    const isOn = function(component, toggleConfig, toggleState) {
        return toggleState.get();
    };
    const onLoad$4 = function(component, toggleConfig, toggleState) {
        set$6(component, toggleConfig, toggleState, toggleConfig.selected);
    };

    const ToggleApis = /* #__PURE__ */ Object.freeze({
        onLoad: onLoad$4,
        toggle,
        isOn,
        on: on$1,
        off,
        set: set$6,
    });

    const exhibit$2 = function(base, toggleConfig, toggleState) {
        return nu$6({});
    };
    const events$6 = function(toggleConfig, toggleState) {
        const execute = executeEvent(toggleConfig, toggleState, toggle);
        const load = loadEvent(toggleConfig, toggleState, onLoad$4);
        return derive(
            flatten([toggleConfig.toggleOnExecute ? [execute] : [], [load]]),
        );
    };

    const ActiveToggle = /* #__PURE__ */ Object.freeze({
        exhibit: exhibit$2,
        events: events$6,
    });

    const SetupBehaviourCellState = function(initialState) {
        const init = function() {
            const cell = Cell(initialState);
            const get = function() {
                return cell.get();
            };
            const set = function(newState) {
                return cell.set(newState);
            };
            const clear = function() {
                return cell.set(initialState);
            };
            const readState = function() {
                return cell.get();
            };
            return {
                get,
                set,
                clear,
                readState,
            };
        };
        return { init };
    };

    const updatePressed = function(component, ariaInfo, status) {
        set$1(component.element(), 'aria-pressed', status);
        if (ariaInfo.syncWithExpanded) {
            updateExpanded(component, ariaInfo, status);
        }
    };
    const updateSelected = function(component, ariaInfo, status) {
        set$1(component.element(), 'aria-selected', status);
    };
    const updateChecked = function(component, ariaInfo, status) {
        set$1(component.element(), 'aria-checked', status);
    };
    var updateExpanded = function(component, ariaInfo, status) {
        set$1(component.element(), 'aria-expanded', status);
    };

    const ToggleSchema = [
        defaulted$1('selected', false),
        option('toggleClass'),
        defaulted$1('toggleOnExecute', true),
        defaultedOf(
            'aria',
            { mode: 'none' },
            choose$1('mode', {
                pressed: [
                    defaulted$1('syncWithExpanded', false),
                    output('update', updatePressed),
                ],
                checked: [output('update', updateChecked)],
                expanded: [output('update', updateExpanded)],
                selected: [output('update', updateSelected)],
                none: [output('update', noop)],
            }),
        ),
    ];

    const Toggling = create$1({
        fields: ToggleSchema,
        name: 'toggling',
        active: ActiveToggle,
        apis: ToggleApis,
        state: SetupBehaviourCellState(false),
    });

    const pointerEvents = function() {
        const onClick = function(component, simulatedEvent) {
            simulatedEvent.stop();
            emitExecute(component);
        };
        return [
            run(click(), onClick),
            run(tap(), onClick),
            cutter(touchstart()),
            cutter(mousedown()),
        ];
    };
    const events$7 = function(optAction) {
        const executeHandler = function(action) {
            return runOnExecute(function(component, simulatedEvent) {
                action(component);
                simulatedEvent.stop();
            });
        };
        return derive(
            flatten([optAction.map(executeHandler).toArray(), pointerEvents()]),
        );
    };

    const hoverEvent = 'alloy.item-hover';
    const focusEvent = 'alloy.item-focus';
    const onHover = function(item) {
        if (search(item.element()).isNone() || Focusing.isFocused(item)) {
            if (!Focusing.isFocused(item)) {
                Focusing.focus(item);
            }
            emitWith(item, hoverEvent, { item });
        }
    };
    const onFocus = function(item) {
        emitWith(item, focusEvent, { item });
    };
    const hover = constant(hoverEvent);
    const focus$3 = constant(focusEvent);

    const builder = function(detail) {
        return {
            dom: detail.dom,
            domModification: {
                ...detail.domModification,
                attributes: {
                    role: detail.toggling.isSome()
                        ? 'menuitemcheckbox'
                        : 'menuitem',
                    ...detail.domModification.attributes,
                    'aria-haspopup': detail.hasSubmenu,
                    ...(detail.hasSubmenu ? { 'aria-expanded': false } : {}),
                },
            },
            behaviours: SketchBehaviours.augment(detail.itemBehaviours, [
                detail.toggling.fold(Toggling.revoke, function(tConfig) {
                    return Toggling.config({
                        aria: { mode: 'checked' },
                        ...tConfig,
                    });
                }),
                Focusing.config({
                    ignore: detail.ignoreFocus,
                    stopMousedown: detail.ignoreFocus,
                    onFocus(component) {
                        onFocus(component);
                    },
                }),
                Keying.config({ mode: 'execution' }),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: detail.data,
                    },
                }),
                config(
                    'item-type-events',
                    __spreadArrays(pointerEvents(), [
                        run(mouseover(), onHover),
                        run(focusItem(), Focusing.focus),
                    ]),
                ),
            ]),
            components: detail.components,
            eventOrder: detail.eventOrder,
        };
    };
    const schema$a = [
        strict$1('data'),
        strict$1('components'),
        strict$1('dom'),
        defaulted$1('hasSubmenu', false),
        option('toggling'),
        SketchBehaviours.field('itemBehaviours', [
            Toggling,
            Focusing,
            Keying,
            Representing,
        ]),
        defaulted$1('ignoreFocus', false),
        defaulted$1('domModification', {}),
        output('builder', builder),
        defaulted$1('eventOrder', {}),
    ];

    const builder$1 = function(detail) {
        return {
            dom: detail.dom,
            components: detail.components,
            events: derive([stopper(focusItem())]),
        };
    };
    const schema$b = [
        strict$1('dom'),
        strict$1('components'),
        output('builder', builder$1),
    ];

    const owner$2 = function() {
        return 'item-widget';
    };
    const parts = constant([
        required({
            name: 'widget',
            overrides(detail) {
                return {
                    behaviours: derive$1([
                        Representing.config({
                            store: {
                                mode: 'manual',
                                getValue(component) {
                                    return detail.data;
                                },
                                setValue() {},
                            },
                        }),
                    ]),
                };
            },
        }),
    ]);

    const builder$2 = function(detail) {
        const subs = substitutes(owner$2(), detail, parts());
        const components$1 = components(owner$2(), detail, subs.internals());
        const focusWidget = function(component) {
            return getPart(component, detail, 'widget').map(function(widget) {
                Keying.focusIn(widget);
                return widget;
            });
        };
        const onHorizontalArrow = function(component, simulatedEvent) {
            return inside(simulatedEvent.event().target())
                ? Option.none()
                : (function() {
                      if (detail.autofocus) {
                          simulatedEvent.setSource(component.element());
                          return Option.none();
                      }
                      return Option.none();
                  })();
        };
        return {
            dom: detail.dom,
            components: components$1,
            domModification: detail.domModification,
            events: derive([
                runOnExecute(function(component, simulatedEvent) {
                    focusWidget(component).each(function(widget) {
                        simulatedEvent.stop();
                    });
                }),
                run(mouseover(), onHover),
                run(focusItem(), function(component, simulatedEvent) {
                    if (detail.autofocus) {
                        focusWidget(component);
                    } else {
                        Focusing.focus(component);
                    }
                }),
            ]),
            behaviours: SketchBehaviours.augment(detail.widgetBehaviours, [
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: detail.data,
                    },
                }),
                Focusing.config({
                    ignore: detail.ignoreFocus,
                    onFocus(component) {
                        onFocus(component);
                    },
                }),
                Keying.config({
                    mode: 'special',
                    focusIn: detail.autofocus
                        ? function(component) {
                              focusWidget(component);
                          }
                        : revoke(),
                    onLeft: onHorizontalArrow,
                    onRight: onHorizontalArrow,
                    onEscape(component, simulatedEvent) {
                        if (
                            !Focusing.isFocused(component) &&
                            !detail.autofocus
                        ) {
                            Focusing.focus(component);
                            return Option.some(true);
                        }
                        if (detail.autofocus) {
                            simulatedEvent.setSource(component.element());
                            return Option.none();
                        }
                        return Option.none();
                    },
                }),
            ]),
        };
    };
    const schema$c = [
        strict$1('uid'),
        strict$1('data'),
        strict$1('components'),
        strict$1('dom'),
        defaulted$1('autofocus', false),
        defaulted$1('ignoreFocus', false),
        SketchBehaviours.field('widgetBehaviours', [
            Representing,
            Focusing,
            Keying,
        ]),
        defaulted$1('domModification', {}),
        defaultUidsSchema(parts()),
        output('builder', builder$2),
    ];

    const itemSchema$1 = choose$1('type', {
        widget: schema$c,
        item: schema$a,
        separator: schema$b,
    });
    const configureGrid = function(detail, movementInfo) {
        return {
            mode: 'flatgrid',
            selector: `.${detail.markers.item}`,
            initSize: {
                numColumns: movementInfo.initSize.numColumns,
                numRows: movementInfo.initSize.numRows,
            },
            focusManager: detail.focusManager,
        };
    };
    const configureMatrix = function(detail, movementInfo) {
        return {
            mode: 'matrix',
            selectors: {
                row: movementInfo.rowSelector,
                cell: `.${detail.markers.item}`,
            },
            focusManager: detail.focusManager,
        };
    };
    const configureMenu = function(detail, movementInfo) {
        return {
            mode: 'menu',
            selector: `.${detail.markers.item}`,
            moveOnTab: movementInfo.moveOnTab,
            focusManager: detail.focusManager,
        };
    };
    const parts$1 = constant([
        group({
            factory: {
                sketch(spec) {
                    const itemInfo = asRawOrDie(
                        'menu.spec item',
                        itemSchema$1,
                        spec,
                    );
                    return itemInfo.builder(itemInfo);
                },
            },
            name: 'items',
            unit: 'item',
            defaults(detail, u) {
                return u.hasOwnProperty('uid')
                    ? u
                    : { ...u, uid: generate$2('item') };
            },
            overrides(detail, u) {
                return {
                    type: u.type,
                    ignoreFocus: detail.fakeFocus,
                    domModification: { classes: [detail.markers.item] },
                };
            },
        }),
    ]);
    const schema$d = constant([
        strict$1('value'),
        strict$1('items'),
        strict$1('dom'),
        strict$1('components'),
        defaulted$1('eventOrder', {}),
        field$1('menuBehaviours', [
            Highlighting,
            Representing,
            Composing,
            Keying,
        ]),
        defaultedOf(
            'movement',
            {
                mode: 'menu',
                moveOnTab: true,
            },
            choose$1('mode', {
                grid: [initSize(), output('config', configureGrid)],
                matrix: [
                    output('config', configureMatrix),
                    strict$1('rowSelector'),
                ],
                menu: [
                    defaulted$1('moveOnTab', true),
                    output('config', configureMenu),
                ],
            }),
        ),
        itemMarkers(),
        defaulted$1('fakeFocus', false),
        defaulted$1('focusManager', dom()),
        onHandler('onHighlight'),
    ]);

    const focus$4 = constant('alloy.menu-focus');

    const make$1 = function(detail, components, spec, externals) {
        return {
            uid: detail.uid,
            dom: detail.dom,
            markers: detail.markers,
            behaviours: augment(detail.menuBehaviours, [
                Highlighting.config({
                    highlightClass: detail.markers.selectedItem,
                    itemClass: detail.markers.item,
                    onHighlight: detail.onHighlight,
                }),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: detail.value,
                    },
                }),
                Composing.config({ find: Option.some }),
                Keying.config(detail.movement.config(detail, detail.movement)),
            ]),
            events: derive([
                run(focus$3(), function(menu, simulatedEvent) {
                    const event = simulatedEvent.event();
                    menu.getSystem()
                        .getByDom(event.target())
                        .each(function(item) {
                            Highlighting.highlight(menu, item);
                            simulatedEvent.stop();
                            emitWith(menu, focus$4(), {
                                menu,
                                item,
                            });
                        });
                }),
                run(hover(), function(menu, simulatedEvent) {
                    const item = simulatedEvent.event().item();
                    Highlighting.highlight(menu, item);
                }),
            ]),
            components,
            eventOrder: detail.eventOrder,
            domModification: { attributes: { role: 'menu' } },
        };
    };

    const Menu = composite$1({
        name: 'Menu',
        configFields: schema$d(),
        partFields: parts$1(),
        factory: make$1,
    });

    const transpose = function(obj) {
        return tupleMap(obj, function(v, k) {
            return {
                k: v,
                v: k,
            };
        });
    };
    var trace = function(items, byItem, byMenu, finish) {
        return readOptFrom$1(byMenu, finish)
            .bind(function(triggerItem) {
                return readOptFrom$1(items, triggerItem).bind(function(
                    triggerMenu,
                ) {
                    const rest = trace(items, byItem, byMenu, triggerMenu);
                    return Option.some([triggerMenu].concat(rest));
                });
            })
            .getOr([]);
    };
    const generate$5 = function(menus, expansions) {
        const items = {};
        each$1(menus, function(menuItems, menu) {
            each(menuItems, function(item) {
                items[item] = menu;
            });
        });
        const byItem = expansions;
        const byMenu = transpose(expansions);
        const menuPaths = map$1(byMenu, function(_triggerItem, submenu) {
            return [submenu].concat(trace(items, byItem, byMenu, submenu));
        });
        return map$1(items, function(menu) {
            return readOptFrom$1(menuPaths, menu).getOr([menu]);
        });
    };

    const init$3 = function() {
        const expansions = Cell({});
        const menus = Cell({});
        const paths = Cell({});
        const primary = Cell(Option.none());
        const directory = Cell({});
        const clear = function() {
            expansions.set({});
            menus.set({});
            paths.set({});
            primary.set(Option.none());
        };
        const isClear = function() {
            return primary.get().isNone();
        };
        const setMenuBuilt = function(menuName, built) {
            let _a;
            menus.set({
                ...menus.get(),
                ...((_a = {}),
                (_a[menuName] = {
                    type: 'prepared',
                    menu: built,
                }),
                _a),
            });
        };
        const setContents = function(sPrimary, sMenus, sExpansions, dir) {
            primary.set(Option.some(sPrimary));
            expansions.set(sExpansions);
            menus.set(sMenus);
            directory.set(dir);
            const sPaths = generate$5(dir, sExpansions);
            paths.set(sPaths);
        };
        const getTriggeringItem = function(menuValue) {
            return find$1(expansions.get(), function(v, k) {
                return v === menuValue;
            });
        };
        const getTriggerData = function(menuValue, getItemByValue, path) {
            return getPreparedMenu(menuValue).bind(function(menu) {
                return getTriggeringItem(menuValue).bind(function(
                    triggeringItemValue,
                ) {
                    return getItemByValue(triggeringItemValue).map(function(
                        triggeredItem,
                    ) {
                        return {
                            triggeredMenu: menu,
                            triggeringItem: triggeredItem,
                            triggeringPath: path,
                        };
                    });
                });
            });
        };
        const getTriggeringPath = function(itemValue, getItemByValue) {
            const extraPath = filter(lookupItem(itemValue).toArray(), function(
                menuValue,
            ) {
                return getPreparedMenu(menuValue).isSome();
            });
            return readOptFrom$1(paths.get(), itemValue).bind(function(path) {
                const revPath = reverse(extraPath.concat(path));
                const triggers = bind(revPath, function(menuValue, menuIndex) {
                    return getTriggerData(
                        menuValue,
                        getItemByValue,
                        revPath.slice(0, menuIndex + 1),
                    ).fold(
                        function() {
                            return primary.get().is(menuValue)
                                ? []
                                : [Option.none()];
                        },
                        function(data) {
                            return [Option.some(data)];
                        },
                    );
                });
                return sequence(triggers);
            });
        };
        const expand = function(itemValue) {
            return readOptFrom$1(expansions.get(), itemValue).map(function(
                menu,
            ) {
                const current = readOptFrom$1(paths.get(), itemValue).getOr([]);
                return [menu].concat(current);
            });
        };
        const collapse = function(itemValue) {
            return readOptFrom$1(paths.get(), itemValue).bind(function(path) {
                return path.length > 1
                    ? Option.some(path.slice(1))
                    : Option.none();
            });
        };
        const refresh = function(itemValue) {
            return readOptFrom$1(paths.get(), itemValue);
        };
        var getPreparedMenu = function(menuValue) {
            return lookupMenu(menuValue).bind(extractPreparedMenu);
        };
        var lookupMenu = function(menuValue) {
            return readOptFrom$1(menus.get(), menuValue);
        };
        var lookupItem = function(itemValue) {
            return readOptFrom$1(expansions.get(), itemValue);
        };
        const otherMenus = function(path) {
            const menuValues = directory.get();
            return difference(keys(menuValues), path);
        };
        const getPrimary = function() {
            return primary.get().bind(getPreparedMenu);
        };
        const getMenus = function() {
            return menus.get();
        };
        return {
            setMenuBuilt,
            setContents,
            expand,
            refresh,
            collapse,
            lookupMenu,
            lookupItem,
            otherMenus,
            getPrimary,
            getMenus,
            clear,
            isClear,
            getTriggeringPath,
        };
    };
    var extractPreparedMenu = function(prep) {
        return prep.type === 'prepared'
            ? Option.some(prep.menu)
            : Option.none();
    };
    const LayeredState = {
        init: init$3,
        extractPreparedMenu,
    };

    const make$2 = function(detail, rawUiSpec) {
        const submenuParentItems = Cell(Option.none());
        const buildMenus = function(container, primaryName, menus) {
            return map$1(menus, function(spec, name) {
                const makeSketch = function() {
                    return Menu.sketch({
                        dom: spec.dom,
                        ...spec,
                        value: name,
                        items: spec.items,
                        markers: detail.markers,
                        fakeFocus: detail.fakeFocus,
                        onHighlight: detail.onHighlight,
                        focusManager: detail.fakeFocus ? highlights() : dom(),
                    });
                };
                return name === primaryName
                    ? {
                          type: 'prepared',
                          menu: container.getSystem().build(makeSketch()),
                      }
                    : {
                          type: 'notbuilt',
                          nbMenu: makeSketch,
                      };
            });
        };
        const layeredState = LayeredState.init();
        const setup = function(container) {
            const componentMap = buildMenus(
                container,
                detail.data.primary,
                detail.data.menus,
            );
            const directory = toDirectory();
            layeredState.setContents(
                detail.data.primary,
                componentMap,
                detail.data.expansions,
                directory,
            );
            return layeredState.getPrimary();
        };
        const getItemValue = function(item) {
            return Representing.getValue(item).value;
        };
        const getItemByValue = function(container, menus, itemValue) {
            return findMap(menus, function(menu) {
                if (!menu.getSystem().isConnected()) {
                    return Option.none();
                }
                const candidates = Highlighting.getCandidates(menu);
                return find(candidates, function(c) {
                    return getItemValue(c) === itemValue;
                });
            });
        };
        var toDirectory = function(container) {
            return map$1(detail.data.menus, function(data, menuName) {
                return bind(data.items, function(item) {
                    return item.type === 'separator' ? [] : [item.data.value];
                });
            });
        };
        const setActiveMenu = function(container, menu) {
            Highlighting.highlight(container, menu);
            Highlighting.getHighlighted(menu)
                .orThunk(function() {
                    return Highlighting.getFirst(menu);
                })
                .each(function(item) {
                    dispatch(container, item.element(), focusItem());
                });
        };
        const getMenus = function(state, menuValues) {
            return cat(
                map(menuValues, function(mv) {
                    return state.lookupMenu(mv).bind(function(prep) {
                        return prep.type === 'prepared'
                            ? Option.some(prep.menu)
                            : Option.none();
                    });
                }),
            );
        };
        const closeOthers = function(container, state, path) {
            const others = getMenus(state, state.otherMenus(path));
            each(others, function(o) {
                remove$5(o.element(), [detail.markers.backgroundMenu]);
                if (!detail.stayInDom) {
                    Replacing.remove(container, o);
                }
            });
        };
        const getSubmenuParents = function(container) {
            return submenuParentItems.get().getOrThunk(function() {
                const r = {};
                const items = descendants(
                    container.element(),
                    `.${detail.markers.item}`,
                );
                const parentItems = filter(items, function(i) {
                    return get$2(i, 'aria-haspopup') === 'true';
                });
                each(parentItems, function(i) {
                    container
                        .getSystem()
                        .getByDom(i)
                        .each(function(itemComp) {
                            const key = getItemValue(itemComp);
                            r[key] = itemComp;
                        });
                });
                submenuParentItems.set(Option.some(r));
                return r;
            });
        };
        const updateAriaExpansions = function(container, path) {
            const parentItems = getSubmenuParents(container);
            each$1(parentItems, function(v, k) {
                const expanded = contains(path, k);
                set$1(v.element(), 'aria-expanded', expanded);
            });
        };
        const updateMenuPath = function(container, state, path) {
            return Option.from(path[0]).bind(function(latestMenuName) {
                return state
                    .lookupMenu(latestMenuName)
                    .bind(function(menuPrep) {
                        if (menuPrep.type === 'notbuilt') {
                            return Option.none();
                        }
                        const activeMenu = menuPrep.menu;
                        const rest = getMenus(state, path.slice(1));
                        each(rest, function(r) {
                            add$2(r.element(), detail.markers.backgroundMenu);
                        });
                        if (!inBody(activeMenu.element())) {
                            Replacing.append(container, premade$1(activeMenu));
                        }
                        remove$5(activeMenu.element(), [
                            detail.markers.backgroundMenu,
                        ]);
                        setActiveMenu(container, activeMenu);
                        closeOthers(container, state, path);
                        return Option.some(activeMenu);
                    });
            });
        };
        let ExpandHighlightDecision;
        (function(ExpandHighlightDecision) {
            ExpandHighlightDecision[
                (ExpandHighlightDecision.HighlightSubmenu = 0)
            ] = 'HighlightSubmenu';
            ExpandHighlightDecision[
                (ExpandHighlightDecision.HighlightParent = 1)
            ] = 'HighlightParent';
        })(ExpandHighlightDecision || (ExpandHighlightDecision = {}));
        const buildIfRequired = function(container, menuName, menuPrep) {
            if (menuPrep.type === 'notbuilt') {
                const menu = container.getSystem().build(menuPrep.nbMenu());
                layeredState.setMenuBuilt(menuName, menu);
                return menu;
            }
            return menuPrep.menu;
        };
        const expandRight = function(container, item, decision) {
            if (decision === void 0) {
                decision = ExpandHighlightDecision.HighlightSubmenu;
            }
            const value = getItemValue(item);
            return layeredState.expand(value).bind(function(path) {
                updateAriaExpansions(container, path);
                return Option.from(path[0]).bind(function(menuName) {
                    return layeredState
                        .lookupMenu(menuName)
                        .bind(function(activeMenuPrep) {
                            const activeMenu = buildIfRequired(
                                container,
                                menuName,
                                activeMenuPrep,
                            );
                            if (!inBody(activeMenu.element())) {
                                Replacing.append(
                                    container,
                                    premade$1(activeMenu),
                                );
                            }
                            detail.onOpenSubmenu(
                                container,
                                item,
                                activeMenu,
                                reverse(path),
                            );
                            if (
                                decision ===
                                ExpandHighlightDecision.HighlightSubmenu
                            ) {
                                Highlighting.highlightFirst(activeMenu);
                                return updateMenuPath(
                                    container,
                                    layeredState,
                                    path,
                                );
                            }
                            Highlighting.dehighlightAll(activeMenu);
                            return Option.some(item);
                        });
                });
            });
        };
        const collapseLeft = function(container, item) {
            const value = getItemValue(item);
            return layeredState.collapse(value).bind(function(path) {
                updateAriaExpansions(container, path);
                return updateMenuPath(container, layeredState, path).map(
                    function(activeMenu) {
                        detail.onCollapseMenu(container, item, activeMenu);
                        return activeMenu;
                    },
                );
            });
        };
        const updateView = function(container, item) {
            const value = getItemValue(item);
            return layeredState.refresh(value).bind(function(path) {
                updateAriaExpansions(container, path);
                return updateMenuPath(container, layeredState, path);
            });
        };
        const onRight = function(container, item) {
            return inside(item.element())
                ? Option.none()
                : expandRight(
                      container,
                      item,
                      ExpandHighlightDecision.HighlightSubmenu,
                  );
        };
        const onLeft = function(container, item) {
            return inside(item.element())
                ? Option.none()
                : collapseLeft(container, item);
        };
        const onEscape = function(container, item) {
            return collapseLeft(container, item).orThunk(function() {
                return detail.onEscape(container, item).map(function() {
                    return container;
                });
            });
        };
        const keyOnItem = function(f) {
            return function(container, simulatedEvent) {
                return closest$3(
                    simulatedEvent.getSource(),
                    `.${detail.markers.item}`,
                ).bind(function(target) {
                    return container
                        .getSystem()
                        .getByDom(target)
                        .toOption()
                        .bind(function(item) {
                            return f(container, item).map(function() {
                                return true;
                            });
                        });
                });
            };
        };
        const events = derive(
            [
                run(focus$4(), function(sandbox, simulatedEvent) {
                    const item = simulatedEvent.event().item();
                    layeredState
                        .lookupItem(getItemValue(item))
                        .each(function() {
                            const menu = simulatedEvent.event().menu();
                            Highlighting.highlight(sandbox, menu);
                            const value = getItemValue(
                                simulatedEvent.event().item(),
                            );
                            layeredState.refresh(value).each(function(path) {
                                return closeOthers(sandbox, layeredState, path);
                            });
                        });
                }),
                runOnExecute(function(component, simulatedEvent) {
                    const target = simulatedEvent.event().target();
                    component
                        .getSystem()
                        .getByDom(target)
                        .each(function(item) {
                            const itemValue = getItemValue(item);
                            if (itemValue.indexOf('collapse-item') === 0) {
                                collapseLeft(component, item);
                            }
                            expandRight(
                                component,
                                item,
                                ExpandHighlightDecision.HighlightSubmenu,
                            ).fold(
                                function() {
                                    detail.onExecute(component, item);
                                },
                                function() {},
                            );
                        });
                }),
                runOnAttached(function(container, simulatedEvent) {
                    setup(container).each(function(primary) {
                        Replacing.append(container, premade$1(primary));
                        detail.onOpenMenu(container, primary);
                        if (detail.highlightImmediately) {
                            setActiveMenu(container, primary);
                        }
                    });
                }),
            ].concat(
                detail.navigateOnHover
                    ? [
                          run(hover(), function(sandbox, simulatedEvent) {
                              const item = simulatedEvent.event().item();
                              updateView(sandbox, item);
                              expandRight(
                                  sandbox,
                                  item,
                                  ExpandHighlightDecision.HighlightParent,
                              );
                              detail.onHover(sandbox, item);
                          }),
                      ]
                    : [],
            ),
        );
        const getActiveItem = function(container) {
            return Highlighting.getHighlighted(container).bind(
                Highlighting.getHighlighted,
            );
        };
        const collapseMenuApi = function(container) {
            getActiveItem(container).each(function(currentItem) {
                collapseLeft(container, currentItem);
            });
        };
        const highlightPrimary = function(container) {
            layeredState.getPrimary().each(function(primary) {
                setActiveMenu(container, primary);
            });
        };
        const extractMenuFromContainer = function(container) {
            return Option.from(container.components()[0]).filter(function(
                comp,
            ) {
                return get$2(comp.element(), 'role') === 'menu';
            });
        };
        const repositionMenus = function(container) {
            const maybeActivePrimary = layeredState
                .getPrimary()
                .bind(function(primary) {
                    return getActiveItem(container)
                        .bind(function(currentItem) {
                            const itemValue = getItemValue(currentItem);
                            const allMenus = values(layeredState.getMenus());
                            const preparedMenus = cat(
                                map(allMenus, LayeredState.extractPreparedMenu),
                            );
                            return layeredState.getTriggeringPath(
                                itemValue,
                                function(v) {
                                    return getItemByValue(
                                        container,
                                        preparedMenus,
                                        v,
                                    );
                                },
                            );
                        })
                        .map(function(triggeringPath) {
                            return {
                                primary,
                                triggeringPath,
                            };
                        });
                });
            maybeActivePrimary.fold(
                function() {
                    extractMenuFromContainer(container).each(function(
                        primaryMenu,
                    ) {
                        detail.onRepositionMenu(container, primaryMenu, []);
                    });
                },
                function(_a) {
                    const { primary } = _a;
                    const { triggeringPath } = _a;
                    detail.onRepositionMenu(container, primary, triggeringPath);
                },
            );
        };
        const apis = {
            collapseMenu: collapseMenuApi,
            highlightPrimary,
            repositionMenus,
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            markers: detail.markers,
            behaviours: augment(detail.tmenuBehaviours, [
                Keying.config({
                    mode: 'special',
                    onRight: keyOnItem(onRight),
                    onLeft: keyOnItem(onLeft),
                    onEscape: keyOnItem(onEscape),
                    focusIn(container, keyInfo) {
                        layeredState.getPrimary().each(function(primary) {
                            dispatch(container, primary.element(), focusItem());
                        });
                    },
                }),
                Highlighting.config({
                    highlightClass: detail.markers.selectedMenu,
                    itemClass: detail.markers.menu,
                }),
                Composing.config({
                    find(container) {
                        return Highlighting.getHighlighted(container);
                    },
                }),
                Replacing.config({}),
            ]),
            eventOrder: detail.eventOrder,
            apis,
            events,
        };
    };
    const collapseItem = constant('collapse-item');

    const tieredData = function(primary, menus, expansions) {
        return {
            primary,
            menus,
            expansions,
        };
    };
    const singleData = function(name, menu) {
        return {
            primary: name,
            menus: wrap$1(name, menu),
            expansions: {},
        };
    };
    const collapseItem$1 = function(text) {
        return {
            value: generate$1(collapseItem()),
            meta: { text },
        };
    };
    const tieredMenu = single$2({
        name: 'TieredMenu',
        configFields: [
            onStrictKeyboardHandler('onExecute'),
            onStrictKeyboardHandler('onEscape'),
            onStrictHandler('onOpenMenu'),
            onStrictHandler('onOpenSubmenu'),
            onStrictHandler('onRepositionMenu'),
            onHandler('onCollapseMenu'),
            defaulted$1('highlightImmediately', true),
            strictObjOf('data', [
                strict$1('primary'),
                strict$1('menus'),
                strict$1('expansions'),
            ]),
            defaulted$1('fakeFocus', false),
            onHandler('onHighlight'),
            onHandler('onHover'),
            tieredMenuMarkers(),
            strict$1('dom'),
            defaulted$1('navigateOnHover', true),
            defaulted$1('stayInDom', false),
            field$1('tmenuBehaviours', [
                Keying,
                Highlighting,
                Composing,
                Replacing,
            ]),
            defaulted$1('eventOrder', {}),
        ],
        apis: {
            collapseMenu(apis, tmenu) {
                apis.collapseMenu(tmenu);
            },
            highlightPrimary(apis, tmenu) {
                apis.highlightPrimary(tmenu);
            },
            repositionMenus(apis, tmenu) {
                apis.repositionMenus(tmenu);
            },
        },
        factory: make$2,
        extraApis: {
            tieredData,
            singleData,
            collapseItem: collapseItem$1,
        },
    });

    const makeMenu = function(
        detail,
        menuSandbox,
        anchor,
        menuSpec,
        getBounds,
    ) {
        const lazySink = function() {
            return detail.lazySink(menuSandbox);
        };
        const layouts =
            menuSpec.type === 'horizontal'
                ? {
                      layouts: {
                          onLtr() {
                              return belowOrAbove();
                          },
                          onRtl() {
                              return belowOrAboveRtl();
                          },
                      },
                  }
                : {};
        const isFirstTierSubmenu = function(triggeringPaths) {
            return triggeringPaths.length === 2;
        };
        const getSubmenuLayouts = function(triggeringPaths) {
            return isFirstTierSubmenu(triggeringPaths) ? layouts : {};
        };
        return tieredMenu.sketch({
            dom: { tag: 'div' },
            data: menuSpec.data,
            markers: menuSpec.menu.markers,
            onEscape() {
                Sandboxing.close(menuSandbox);
                detail.onEscape.map(function(handler) {
                    return handler(menuSandbox);
                });
                return Option.some(true);
            },
            onExecute() {
                return Option.some(true);
            },
            onOpenMenu(tmenu, menu) {
                Positioning.positionWithinBounds(
                    lazySink().getOrDie(),
                    anchor,
                    menu,
                    getBounds(),
                );
            },
            onOpenSubmenu(tmenu, item, submenu, triggeringPaths) {
                const sink = lazySink().getOrDie();
                Positioning.position(
                    sink,
                    {
                        anchor: 'submenu',
                        item,
                        ...getSubmenuLayouts(triggeringPaths),
                    },
                    submenu,
                );
            },
            onRepositionMenu(tmenu, primaryMenu, submenuTriggers) {
                const sink = lazySink().getOrDie();
                Positioning.positionWithinBounds(
                    sink,
                    anchor,
                    primaryMenu,
                    getBounds(),
                );
                each(submenuTriggers, function(st) {
                    const submenuLayouts = getSubmenuLayouts(st.triggeringPath);
                    Positioning.position(
                        sink,
                        {
                            anchor: 'submenu',
                            item: st.triggeringItem,
                            ...submenuLayouts,
                        },
                        st.triggeredMenu,
                    );
                });
            },
        });
    };
    const factory = function(detail, spec) {
        const isPartOfRelated = function(sandbox, queryElem) {
            const related = detail.getRelated(sandbox);
            return related.exists(function(rel) {
                return isPartOf(rel, queryElem);
            });
        };
        const setContent = function(sandbox, thing) {
            Sandboxing.setContent(sandbox, thing);
        };
        const showAt = function(sandbox, anchor, thing) {
            showWithin(sandbox, anchor, thing, Option.none());
        };
        var showWithin = function(sandbox, anchor, thing, boxElement) {
            showWithinBounds(sandbox, anchor, thing, function() {
                return boxElement.map(function(elem) {
                    return box(elem);
                });
            });
        };
        var showWithinBounds = function(sandbox, anchor, thing, getBounds) {
            const sink = detail.lazySink(sandbox).getOrDie();
            Sandboxing.openWhileCloaked(sandbox, thing, function() {
                return Positioning.positionWithinBounds(
                    sink,
                    anchor,
                    sandbox,
                    getBounds(),
                );
            });
            Representing.setValue(
                sandbox,
                Option.some({
                    mode: 'position',
                    anchor,
                    getBounds,
                }),
            );
        };
        const showMenuAt = function(sandbox, anchor, menuSpec) {
            showMenuWithinBounds(sandbox, anchor, menuSpec, function() {
                return Option.none();
            });
        };
        var showMenuWithinBounds = function(
            sandbox,
            anchor,
            menuSpec,
            getBounds,
        ) {
            const menu = makeMenu(detail, sandbox, anchor, menuSpec, getBounds);
            Sandboxing.open(sandbox, menu);
            Representing.setValue(
                sandbox,
                Option.some({
                    mode: 'menu',
                    menu,
                }),
            );
        };
        const hide = function(sandbox) {
            Representing.setValue(sandbox, Option.none());
            Sandboxing.close(sandbox);
        };
        const getContent = function(sandbox) {
            return Sandboxing.getState(sandbox);
        };
        const reposition = function(sandbox) {
            if (Sandboxing.isOpen(sandbox)) {
                Representing.getValue(sandbox).each(function(state) {
                    switch (state.mode) {
                        case 'menu':
                            Sandboxing.getState(sandbox).each(function(tmenu) {
                                tieredMenu.repositionMenus(tmenu);
                            });
                            break;
                        case 'position':
                            var sink = detail.lazySink(sandbox).getOrDie();
                            Positioning.positionWithinBounds(
                                sink,
                                state.anchor,
                                sandbox,
                                state.getBounds(),
                            );
                            break;
                    }
                });
            }
        };
        const apis = {
            setContent,
            showAt,
            showWithin,
            showWithinBounds,
            showMenuAt,
            showMenuWithinBounds,
            hide,
            getContent,
            reposition,
            isOpen: Sandboxing.isOpen,
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            behaviours: augment(detail.inlineBehaviours, [
                Sandboxing.config({
                    isPartOf(sandbox, data, queryElem) {
                        return (
                            isPartOf(data, queryElem) ||
                            isPartOfRelated(sandbox, queryElem)
                        );
                    },
                    getAttachPoint(sandbox) {
                        return detail.lazySink(sandbox).getOrDie();
                    },
                    onOpen(sandbox) {
                        detail.onShow(sandbox);
                    },
                    onClose(sandbox) {
                        detail.onHide(sandbox);
                    },
                }),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: Option.none(),
                    },
                }),
                Receiving.config({
                    channels: {
                        ...receivingChannel({
                            isExtraPart: constant(false),
                            ...detail.fireDismissalEventInstead
                                .map(function(fe) {
                                    return {
                                        fireEventInstead: {
                                            event: fe.event,
                                        },
                                    };
                                })
                                .getOr({}),
                        }),
                        ...receivingChannel$1({
                            isExtraPart: constant(false),
                            ...detail.fireRepositionEventInstead
                                .map(function(fe) {
                                    return {
                                        fireEventInstead: {
                                            event: fe.event,
                                        },
                                    };
                                })
                                .getOr({}),
                            doReposition: reposition,
                        }),
                    },
                }),
            ]),
            eventOrder: detail.eventOrder,
            apis,
        };
    };
    const InlineView = single$2({
        name: 'InlineView',
        configFields: [
            strict$1('lazySink'),
            onHandler('onShow'),
            onHandler('onHide'),
            optionFunction('onEscape'),
            field$1('inlineBehaviours', [Sandboxing, Representing, Receiving]),
            optionObjOf('fireDismissalEventInstead', [
                defaulted$1('event', dismissRequested()),
            ]),
            optionObjOf('fireRepositionEventInstead', [
                defaulted$1('event', repositionRequested()),
            ]),
            defaulted$1('getRelated', Option.none),
            defaulted$1('eventOrder', Option.none),
        ],
        factory,
        apis: {
            showAt(apis, component, anchor, thing) {
                apis.showAt(component, anchor, thing);
            },
            showWithin(apis, component, anchor, thing, boxElement) {
                apis.showWithin(component, anchor, thing, boxElement);
            },
            showWithinBounds(apis, component, anchor, thing, bounds) {
                apis.showWithinBounds(component, anchor, thing, bounds);
            },
            showMenuAt(apis, component, anchor, menuSpec) {
                apis.showMenuAt(component, anchor, menuSpec);
            },
            showMenuWithinBounds(apis, component, anchor, menuSpec, bounds) {
                apis.showMenuWithinBounds(component, anchor, menuSpec, bounds);
            },
            hide(apis, component) {
                apis.hide(component);
            },
            isOpen(apis, component) {
                return apis.isOpen(component);
            },
            getContent(apis, component) {
                return apis.getContent(component);
            },
            setContent(apis, component, thing) {
                apis.setContent(component, thing);
            },
            reposition(apis, component) {
                apis.reposition(component);
            },
        },
    });

    const westEdgeX$1 = function(anchor) {
        return anchor.x();
    };
    const middleX$1 = function(anchor, element) {
        return anchor.x() + anchor.width() / 2 - element.width() / 2;
    };
    const eastEdgeX$1 = function(anchor, element) {
        return anchor.x() + anchor.width() - element.width();
    };
    const northY$2 = function(anchor) {
        return anchor.y();
    };
    const southY$2 = function(anchor, element) {
        return anchor.y() + anchor.height() - element.height();
    };
    const southeast$3 = function(anchor, element, bubbles) {
        return nu$7(
            westEdgeX$1(anchor),
            southY$2(anchor, element),
            bubbles.innerSoutheast(),
            southeast(),
            'layout-se',
        );
    };
    const southwest$3 = function(anchor, element, bubbles) {
        return nu$7(
            eastEdgeX$1(anchor, element),
            southY$2(anchor, element),
            bubbles.innerSouthwest(),
            southwest(),
            'layout-sw',
        );
    };
    const northeast$3 = function(anchor, element, bubbles) {
        return nu$7(
            westEdgeX$1(anchor),
            northY$2(anchor),
            bubbles.innerNortheast(),
            northeast(),
            'layout-ne',
        );
    };
    const northwest$3 = function(anchor, element, bubbles) {
        return nu$7(
            eastEdgeX$1(anchor, element),
            northY$2(anchor),
            bubbles.innerNorthwest(),
            northwest(),
            'layout-nw',
        );
    };
    const north$3 = function(anchor, element, bubbles) {
        return nu$7(
            middleX$1(anchor, element),
            northY$2(anchor),
            bubbles.innerNorth(),
            north(),
            'layout-n',
        );
    };
    const south$3 = function(anchor, element, bubbles) {
        return nu$7(
            middleX$1(anchor, element),
            southY$2(anchor, element),
            bubbles.innerSouth(),
            south(),
            'layout-s',
        );
    };

    const factory$1 = function(detail) {
        const events = events$7(detail.action);
        const { tag } = detail.dom;
        const lookupAttr = function(attr) {
            return readOptFrom$1(detail.dom, 'attributes').bind(function(
                attrs,
            ) {
                return readOptFrom$1(attrs, attr);
            });
        };
        const getModAttributes = function() {
            if (tag === 'button') {
                const type = lookupAttr('type').getOr('button');
                const roleAttrs = lookupAttr('role')
                    .map(function(role) {
                        return { role };
                    })
                    .getOr({});
                return { type, ...roleAttrs };
            }
            const role = lookupAttr('role').getOr('button');
            return { role };
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components: detail.components,
            events,
            behaviours: SketchBehaviours.augment(detail.buttonBehaviours, [
                Focusing.config({}),
                Keying.config({
                    mode: 'execution',
                    useSpace: true,
                    useEnter: true,
                }),
            ]),
            domModification: { attributes: getModAttributes() },
            eventOrder: detail.eventOrder,
        };
    };
    const Button = single$2({
        name: 'Button',
        factory: factory$1,
        configFields: [
            defaulted$1('uid', undefined),
            strict$1('dom'),
            defaulted$1('components', []),
            SketchBehaviours.field('buttonBehaviours', [Focusing, Keying]),
            option('action'),
            option('role'),
            defaulted$1('eventOrder', {}),
        ],
    });

    const record = function(spec) {
        const uid =
            isSketchSpec(spec) && hasKey$1(spec, 'uid')
                ? spec.uid
                : generate$2('memento');
        const get = function(anyInSystem) {
            return anyInSystem
                .getSystem()
                .getByUid(uid)
                .getOrDie();
        };
        const getOpt = function(anyInSystem) {
            return anyInSystem
                .getSystem()
                .getByUid(uid)
                .toOption();
        };
        const asSpec = function() {
            return { ...spec, uid };
        };
        return {
            get,
            getOpt,
            asSpec,
        };
    };

    const defaultIcon = function(icons) {
        return Option.from(icons()['temporary-placeholder']).getOr(
            '!not found!',
        );
    };
    const get$c = function(name, icons) {
        return Option.from(icons()[name]).getOrThunk(function() {
            return defaultIcon(icons);
        });
    };
    const getOr = function(name, icons, fallback) {
        return Option.from(icons()[name])
            .or(fallback)
            .getOrThunk(function() {
                return defaultIcon(icons);
            });
    };
    const getFirst$1 = function(names, icons) {
        return findMap(names, function(name) {
            return Option.from(icons()[name]);
        }).getOrThunk(function() {
            return defaultIcon(icons);
        });
    };

    const notificationIconMap = {
        success: 'checkmark',
        error: 'warning',
        err: 'error',
        warning: 'warning',
        warn: 'warning',
        info: 'info',
    };
    const factory$2 = function(detail) {
        const memBannerText = record({
            dom: {
                tag: 'p',
                innerHtml: detail.translationProvider(detail.text),
            },
            behaviours: derive$1([Replacing.config({})]),
        });
        const renderPercentBar = function(percent) {
            return {
                dom: {
                    tag: 'div',
                    classes: ['tox-bar'],
                    attributes: { style: `width: ${percent}%` },
                },
            };
        };
        const renderPercentText = function(percent) {
            return {
                dom: {
                    tag: 'div',
                    classes: ['tox-text'],
                    innerHtml: `${percent}%`,
                },
            };
        };
        const memBannerProgress = record({
            dom: {
                tag: 'div',
                classes: detail.progress
                    ? ['tox-progress-bar', 'tox-progress-indicator']
                    : ['tox-progress-bar'],
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-bar-container'],
                    },
                    components: [renderPercentBar(0)],
                },
                renderPercentText(0),
            ],
            behaviours: derive$1([Replacing.config({})]),
        });
        const updateProgress = function(comp, percent) {
            if (comp.getSystem().isConnected()) {
                memBannerProgress.getOpt(comp).each(function(progress) {
                    Replacing.set(progress, [
                        {
                            dom: {
                                tag: 'div',
                                classes: ['tox-bar-container'],
                            },
                            components: [renderPercentBar(percent)],
                        },
                        renderPercentText(percent),
                    ]);
                });
            }
        };
        const updateText = function(comp, text$1) {
            if (comp.getSystem().isConnected()) {
                const banner = memBannerText.get(comp);
                Replacing.set(banner, [text(text$1)]);
            }
        };
        const apis = {
            updateProgress,
            updateText,
        };
        const iconChoices = flatten([
            detail.icon.toArray(),
            detail.level.toArray(),
            detail.level
                .bind(function(level) {
                    return Option.from(notificationIconMap[level]);
                })
                .toArray(),
        ]);
        return {
            uid: detail.uid,
            dom: {
                tag: 'div',
                attributes: { role: 'alert' },
                classes: detail.level
                    .map(function(level) {
                        return [
                            'tox-notification',
                            'tox-notification--in',
                            `tox-notification--${level}`,
                        ];
                    })
                    .getOr(['tox-notification', 'tox-notification--in']),
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-notification__icon'],
                        innerHtml: getFirst$1(iconChoices, detail.iconProvider),
                    },
                },
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-notification__body'],
                    },
                    components: [memBannerText.asSpec()],
                    behaviours: derive$1([Replacing.config({})]),
                },
            ]
                .concat(detail.progress ? [memBannerProgress.asSpec()] : [])
                .concat(
                    Button.sketch({
                        dom: {
                            tag: 'button',
                            classes: [
                                'tox-notification__dismiss',
                                'tox-button',
                                'tox-button--naked',
                                'tox-button--icon',
                            ],
                        },
                        components: [
                            {
                                dom: {
                                    tag: 'div',
                                    classes: ['tox-icon'],
                                    innerHtml: get$c(
                                        'close',
                                        detail.iconProvider,
                                    ),
                                    attributes: {
                                        'aria-label': detail.translationProvider(
                                            'Close',
                                        ),
                                    },
                                },
                            },
                        ],
                        action(comp) {
                            detail.onAction(comp);
                        },
                    }),
                ),
            apis,
        };
    };
    const Notification = single$2({
        name: 'Notification',
        factory: factory$2,
        configFields: [
            option('level'),
            strict$1('progress'),
            strict$1('icon'),
            strict$1('onAction'),
            strict$1('text'),
            strict$1('iconProvider'),
            strict$1('translationProvider'),
        ],
        apis: {
            updateProgress(apis, comp, percent) {
                apis.updateProgress(comp, percent);
            },
            updateText(apis, comp, text) {
                apis.updateText(comp, text);
            },
        },
    });

    const global$2 = tinymce.util.Tools.resolve('tinymce.util.Delay');

    function NotificationManagerImpl(editor, extras, uiMothership) {
        const { backstage } = extras;
        const getLayoutDirection = function(rel) {
            switch (rel) {
                case 'bc-bc':
                    return south$3;
                case 'tc-tc':
                    return north$3;
                case 'tc-bc':
                    return north$1;
                case 'bc-tc':
                default:
                    return south$1;
            }
        };
        const prePositionNotifications = function(notifications) {
            each(notifications, function(notification) {
                return notification.moveTo(0, 0);
            });
        };
        const positionNotifications = function(notifications) {
            if (notifications.length > 0) {
                head(notifications).each(function(firstItem) {
                    return firstItem.moveRel(null, 'banner');
                });
                each(notifications, function(notification, index) {
                    if (index > 0) {
                        notification.moveRel(
                            notifications[index - 1].getEl(),
                            'bc-tc',
                        );
                    }
                });
            }
        };
        const reposition = function(notifications) {
            prePositionNotifications(notifications);
            positionNotifications(notifications);
        };
        const open = function(settings, closeCallback) {
            const close = function() {
                closeCallback();
                InlineView.hide(notificationWrapper);
            };
            const notification = build$1(
                Notification.sketch({
                    text: settings.text,
                    level: contains(
                        ['success', 'error', 'warning', 'warn', 'info'],
                        settings.type,
                    )
                        ? settings.type
                        : undefined,
                    progress: settings.progressBar === true,
                    icon: Option.from(settings.icon),
                    onAction: close,
                    iconProvider: backstage.shared.providers.icons,
                    translationProvider: backstage.shared.providers.translate,
                }),
            );
            var notificationWrapper = build$1(
                InlineView.sketch({
                    dom: {
                        tag: 'div',
                        classes: ['tox-notifications-container'],
                    },
                    lazySink: extras.backstage.shared.getSink,
                    fireDismissalEventInstead: {},
                }),
            );
            uiMothership.add(notificationWrapper);
            if (settings.timeout > 0) {
                global$2.setTimeout(function() {
                    close();
                }, settings.timeout);
            }
            return {
                close,
                moveTo(x, y) {
                    InlineView.showAt(
                        notificationWrapper,
                        {
                            anchor: 'makeshift',
                            x,
                            y,
                        },
                        premade$1(notification),
                    );
                },
                moveRel(element, rel) {
                    if (rel !== 'banner') {
                        const layoutDirection_1 = getLayoutDirection(rel);
                        const nodeAnchor = {
                            anchor: 'node',
                            root: body(),
                            node: Option.some(Element.fromDom(element)),
                            layouts: {
                                onRtl() {
                                    return [layoutDirection_1];
                                },
                                onLtr() {
                                    return [layoutDirection_1];
                                },
                            },
                        };
                        InlineView.showAt(
                            notificationWrapper,
                            nodeAnchor,
                            premade$1(notification),
                        );
                    } else {
                        InlineView.showAt(
                            notificationWrapper,
                            extras.backstage.shared.anchors.banner(),
                            premade$1(notification),
                        );
                    }
                },
                text(nuText) {
                    Notification.updateText(notification, nuText);
                },
                settings,
                getEl() {
                    return notification.element().dom();
                },
                progressBar: {
                    value(percent) {
                        Notification.updateProgress(notification, percent);
                    },
                },
            };
        };
        const close = function(notification) {
            notification.close();
        };
        const getArgs = function(notification) {
            return notification.settings;
        };
        return {
            open,
            close,
            reposition,
            getArgs,
        };
    }

    const first$1 = function(fn, rate) {
        let timer = null;
        const cancel = function() {
            if (timer !== null) {
                domGlobals.clearTimeout(timer);
                timer = null;
            }
        };
        const throttle = function() {
            const args = [];
            for (let _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (timer === null) {
                timer = domGlobals.setTimeout(function() {
                    fn.apply(null, args);
                    timer = null;
                }, rate);
            }
        };
        return {
            cancel,
            throttle,
        };
    };
    const last$2 = function(fn, rate) {
        let timer = null;
        const cancel = function() {
            if (timer !== null) {
                domGlobals.clearTimeout(timer);
                timer = null;
            }
        };
        const throttle = function() {
            const args = [];
            for (let _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (timer !== null) {
                domGlobals.clearTimeout(timer);
            }
            timer = domGlobals.setTimeout(function() {
                fn.apply(null, args);
                timer = null;
            }, rate);
        };
        return {
            cancel,
            throttle,
        };
    };

    const global$3 = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');

    const isText$1 = function(node) {
        return node.nodeType === domGlobals.Node.TEXT_NODE;
    };
    const isBoundary = function(dom, node) {
        return (
            dom.isBlock(node) ||
            contains(['BR', 'IMG', 'HR', 'INPUT'], node.nodeName) ||
            dom.getContentEditable(node) === 'false'
        );
    };
    const outcome$1 = Adt.generate([
        { aborted: [] },
        { edge: ['element'] },
        { success: ['info'] },
    ]);
    const phase = Adt.generate([
        { abort: [] },
        { kontinue: [] },
        { finish: ['info'] },
    ]);
    var repeat = function(dom, node, offset, process, walker, recent) {
        const terminate = function() {
            return recent.fold(outcome$1.aborted, outcome$1.edge);
        };
        const recurse = function() {
            const next = walker();
            if (next) {
                return repeat(
                    dom,
                    next,
                    Option.none(),
                    process,
                    walker,
                    Option.some(node),
                );
            }
            return terminate();
        };
        if (isBoundary(dom, node)) {
            return terminate();
        }
        if (!isText$1(node)) {
            return recurse();
        }
        const text = node.textContent;
        return process(phase, node, text, offset).fold(
            outcome$1.aborted,
            function() {
                return recurse();
            },
            outcome$1.success,
        );
    };
    const repeatLeft = function(dom, node, offset, process, rootNode) {
        const walker = new global$3(node, rootNode || dom.getRoot());
        return repeat(
            dom,
            node,
            Option.some(offset),
            process,
            walker.prev,
            Option.none(),
        );
    };

    const autocompleteSelector = '[data-mce-autocompleter]';
    const create$4 = function(editor, range) {
        return detect$4(Element.fromDom(editor.selection.getNode())).getOrThunk(
            function() {
                const wrapper = Element.fromHtml(
                    '<span data-mce-autocompleter="1" data-mce-bogus="1"></span>',
                    editor.getDoc(),
                );
                append(wrapper, Element.fromDom(range.extractContents()));
                range.insertNode(wrapper.dom());
                parent(wrapper).each(function(elm) {
                    return elm.dom().normalize();
                });
                last$1(wrapper).map(function(last) {
                    editor.selection.setCursorLocation(
                        last.dom(),
                        getEnd(last),
                    );
                });
                return wrapper;
            },
        );
    };
    var detect$4 = function(elm) {
        return closest$3(elm, autocompleteSelector);
    };

    const isValidTextRange = function(rng) {
        return rng.collapsed && rng.startContainer.nodeType === 3;
    };
    const whiteSpace = /[\u00a0 \t\r\n]/;
    const parse = function(text, index, ch, minChars) {
        let i;
        for (i = index - 1; i >= 0; i--) {
            const char = text.charAt(i);
            if (whiteSpace.test(char)) {
                return Option.none();
            }
            if (char === ch) {
                break;
            }
        }
        if (i === -1 || index - i < minChars) {
            return Option.none();
        }
        return Option.some(text.substring(i + 1, index));
    };
    const getText = function(rng, ch) {
        const text = rng.toString().substring(ch.length);
        return text.replace(/\u00A0/g, ' ').replace(/\uFEFF/g, '');
    };
    const findStart = function(dom, initRange, ch, minChars) {
        if (minChars === void 0) {
            minChars = 0;
        }
        if (!isValidTextRange(initRange)) {
            return Option.none();
        }
        const findTriggerCh = function(phase, element, text, optOffset) {
            const index = optOffset.getOr(text.length);
            return parse(text, index, ch, 1).fold(
                function() {
                    return text.match(whiteSpace)
                        ? phase.abort()
                        : phase.kontinue();
                },
                function(newText) {
                    const range = initRange.cloneRange();
                    range.setStart(element, index - newText.length - 1);
                    range.setEnd(initRange.endContainer, initRange.endOffset);
                    return text.length < minChars
                        ? phase.abort()
                        : phase.finish({
                              text: getText(range, ch),
                              range,
                              triggerChar: ch,
                          });
                },
            );
        };
        return repeatLeft(
            dom,
            initRange.startContainer,
            initRange.startOffset,
            findTriggerCh,
        ).fold(Option.none, Option.none, Option.some);
    };
    const getContext = function(dom, initRange, ch, minChars) {
        if (minChars === void 0) {
            minChars = 0;
        }
        return detect$4(Element.fromDom(initRange.startContainer)).fold(
            function() {
                return findStart(dom, initRange, ch, minChars);
            },
            function(elm) {
                const range = dom.createRng();
                range.selectNode(elm.dom());
                return Option.some({
                    range,
                    text: getText(range, ch),
                    triggerChar: ch,
                });
            },
        );
    };

    const setup = function(api, editor) {
        editor.on('keypress compositionend', api.onKeypress.throttle);
        editor.on('remove', api.onKeypress.cancel);
        const redirectKeyToItem = function(item, e) {
            emitWith(item, keydown(), { raw: e });
        };
        editor.on('keydown', function(e) {
            const getItem = function() {
                return api.getView().bind(Highlighting.getHighlighted);
            };
            if (e.which === 8) {
                api.onKeypress.throttle(e);
            }
            if (api.isActive()) {
                if (e.which === 27) {
                    api.cancelIfNecessary();
                }
                if (api.isMenuOpen()) {
                    if (e.which === 13) {
                        getItem().each(emitExecute);
                        e.preventDefault();
                    } else if (e.which === 40) {
                        getItem().fold(
                            function() {
                                api.getView().each(Highlighting.highlightFirst);
                            },
                            function(item) {
                                redirectKeyToItem(item, e);
                            },
                        );
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    } else if (
                        e.which === 37 ||
                        e.which === 38 ||
                        e.which === 39
                    ) {
                        getItem().each(function(item) {
                            redirectKeyToItem(item, e);
                            e.preventDefault();
                            e.stopImmediatePropagation();
                        });
                    }
                } else if (e.which === 13 || e.which === 38 || e.which === 40) {
                    api.cancelIfNecessary();
                }
            }
        });
        editor.on('NodeChange', function(e) {
            if (
                api.isActive() &&
                !api.isProcessingAction() &&
                detect$4(Element.fromDom(e.element)).isNone()
            ) {
                api.cancelIfNecessary();
            }
        });
    };
    const AutocompleterEditorEvents = { setup };

    const global$4 = tinymce.util.Tools.resolve('tinymce.util.Promise');

    const point$2 = function(element, offset) {
        return {
            element,
            offset,
        };
    };

    const isText$2 = function(node) {
        return node.nodeType === domGlobals.Node.TEXT_NODE;
    };
    const isElement$1 = function(node) {
        return node.nodeType === domGlobals.Node.ELEMENT_NODE;
    };
    var toLast = function(node) {
        if (isText$2(node)) {
            return point$2(node, node.data.length);
        }
        const children = node.childNodes;
        return children.length > 0
            ? toLast(children[children.length - 1])
            : point$2(node, children.length);
    };
    var toLeaf = function(node, offset) {
        const children = node.childNodes;
        if (children.length > 0 && offset < children.length) {
            return toLeaf(children[offset], 0);
        }
        if (
            children.length > 0 &&
            isElement$1(node) &&
            children.length === offset
        ) {
            return toLast(children[children.length - 1]);
        }
        return point$2(node, offset);
    };

    const isStartOfWord = function(dom) {
        const process = function(phase, element, text, optOffset) {
            const index = optOffset.getOr(text.length);
            return index === 0
                ? phase.kontinue()
                : phase.finish(/\s/.test(text.charAt(index - 1)));
        };
        return function(rng) {
            const leaf = toLeaf(rng.startContainer, rng.startOffset);
            return repeatLeft(dom, leaf.element, leaf.offset, process).fold(
                constant(true),
                constant(true),
                identity,
            );
        };
    };
    const getTriggerContext = function(dom, initRange, database) {
        return findMap(database.triggerChars, function(ch) {
            return getContext(dom, initRange, ch);
        });
    };
    const lookup = function(editor, getDatabase) {
        const database = getDatabase();
        const rng = editor.selection.getRng();
        return getTriggerContext(editor.dom, rng, database).bind(function(
            context,
        ) {
            return lookupWithContext(editor, getDatabase, context);
        });
    };
    var lookupWithContext = function(
        editor,
        getDatabase,
        context,
        fetchOptions,
    ) {
        if (fetchOptions === void 0) {
            fetchOptions = {};
        }
        const database = getDatabase();
        const rng = editor.selection.getRng();
        const startText = rng.startContainer.nodeValue;
        const autocompleters = filter(
            database.lookupByChar(context.triggerChar),
            function(autocompleter) {
                return (
                    context.text.length >= autocompleter.minChars &&
                    autocompleter.matches.getOrThunk(function() {
                        return isStartOfWord(editor.dom);
                    })(context.range, startText, context.text)
                );
            },
        );
        if (autocompleters.length === 0) {
            return Option.none();
        }
        const lookupData = global$4.all(
            map(autocompleters, function(ac) {
                const fetchResult = ac.fetch(
                    context.text,
                    ac.maxResults,
                    fetchOptions,
                );
                return fetchResult.then(function(results) {
                    return {
                        matchText: context.text,
                        items: results,
                        columns: ac.columns,
                        onAction: ac.onAction,
                    };
                });
            }),
        );
        return Option.some({
            lookupData,
            context,
        });
    };

    const separatorMenuItemSchema = objOf([
        strictString('type'),
        optionString('text'),
    ]);
    const createSeparatorMenuItem = function(spec) {
        return asRaw('separatormenuitem', separatorMenuItemSchema, spec);
    };

    const autocompleterItemSchema = objOf([
        state$1('type', function() {
            return 'autocompleteitem';
        }),
        state$1('active', function() {
            return false;
        }),
        state$1('disabled', function() {
            return false;
        }),
        defaulted$1('meta', {}),
        strictString('value'),
        optionString('text'),
        optionString('icon'),
    ]);
    const autocompleterSchema = objOf([
        strictString('type'),
        strictString('ch'),
        defaultedNumber('minChars', 1),
        defaulted$1('columns', 1),
        defaultedNumber('maxResults', 10),
        optionFunction('matches'),
        strictFunction('fetch'),
        strictFunction('onAction'),
    ]);
    const createSeparatorItem = function(spec) {
        return asRaw('Autocompleter.Separator', separatorMenuItemSchema, spec);
    };
    const createAutocompleterItem = function(spec) {
        return asRaw('Autocompleter.Item', autocompleterItemSchema, spec);
    };
    const createAutocompleter = function(spec) {
        return asRaw('Autocompleter', autocompleterSchema, spec);
    };

    const stringArray = function(a) {
        const all = {};
        each(a, function(key) {
            all[key] = {};
        });
        return keys(all);
    };

    const register = function(editor) {
        const { popups } = editor.ui.registry.getAll();
        const dataset = map$1(popups, function(popup) {
            return createAutocompleter(popup).fold(
                function(err) {
                    throw new Error(formatError(err));
                },
                function(x) {
                    return x;
                },
            );
        });
        const triggerChars = stringArray(
            mapToArray(dataset, function(v) {
                return v.ch;
            }),
        );
        const datasetValues = values(dataset);
        const lookupByChar = function(ch) {
            return filter(datasetValues, function(dv) {
                return dv.ch === ch;
            });
        };
        return {
            dataset,
            triggerChars,
            lookupByChar,
        };
    };

    const commonMenuItemFields = [
        defaultedBoolean('disabled', false),
        optionString('text'),
        optionString('shortcut'),
        field(
            'value',
            'value',
            defaultedThunk(function() {
                return generate$1('menuitem-value');
            }),
            anyValue$1(),
        ),
        defaulted$1('meta', {}),
    ];

    const menuItemSchema = objOf(
        [
            strictString('type'),
            defaultedFunction('onSetup', function() {
                return noop;
            }),
            defaultedFunction('onAction', noop),
            optionString('icon'),
        ].concat(commonMenuItemFields),
    );
    const createMenuItem = function(spec) {
        return asRaw('menuitem', menuItemSchema, spec);
    };

    const nestedMenuItemSchema = objOf(
        [
            strictString('type'),
            strictFunction('getSubmenuItems'),
            defaultedFunction('onSetup', function() {
                return noop;
            }),
            optionString('icon'),
        ].concat(commonMenuItemFields),
    );
    const createNestedMenuItem = function(spec) {
        return asRaw('nestedmenuitem', nestedMenuItemSchema, spec);
    };

    const toggleMenuItemSchema = objOf(
        [
            strictString('type'),
            defaultedBoolean('active', false),
            defaultedFunction('onSetup', function() {
                return noop;
            }),
            strictFunction('onAction'),
        ].concat(commonMenuItemFields),
    );
    const createToggleMenuItem = function(spec) {
        return asRaw('togglemenuitem', toggleMenuItemSchema, spec);
    };

    const choiceMenuItemSchema = objOf(
        [
            strictString('type'),
            defaultedBoolean('active', false),
            optionString('icon'),
        ].concat(commonMenuItemFields),
    );
    const createChoiceMenuItem = function(spec) {
        return asRaw('choicemenuitem', choiceMenuItemSchema, spec);
    };

    const fancyTypes = ['inserttable', 'colorswatch'];
    const fancyMenuItemSchema = objOf([
        strictString('type'),
        strictStringEnum('fancytype', fancyTypes),
        defaultedFunction('onAction', noop),
    ]);
    const createFancyMenuItem = function(spec) {
        return asRaw('fancymenuitem', fancyMenuItemSchema, spec);
    };

    const detectSize = function(comp, margin, selectorClass) {
        const descendants$1 = descendants(comp.element(), `.${selectorClass}`);
        if (descendants$1.length > 0) {
            const columnLength = findIndex(descendants$1, function(c) {
                const thisTop = c.dom().getBoundingClientRect().top;
                const cTop = descendants$1[0].dom().getBoundingClientRect().top;
                return Math.abs(thisTop - cTop) > margin;
            }).getOr(descendants$1.length);
            return Option.some({
                numColumns: columnLength,
                numRows: Math.ceil(descendants$1.length / columnLength),
            });
        }
        return Option.none();
    };

    const namedEvents = function(name, handlers) {
        return derive$1([config(name, handlers)]);
    };
    const unnamedEvents = function(handlers) {
        return namedEvents(generate$1('unnamed-events'), handlers);
    };
    const SimpleBehaviours = {
        namedEvents,
        unnamedEvents,
    };

    const TooltippingSchema = [
        strict$1('lazySink'),
        strict$1('tooltipDom'),
        defaulted$1('exclusive', true),
        defaulted$1('tooltipComponents', []),
        defaulted$1('delay', 300),
        defaultedStringEnum('mode', 'normal', ['normal', 'follow-highlight']),
        defaulted$1('anchor', function(comp) {
            return {
                anchor: 'hotspot',
                hotspot: comp,
                layouts: {
                    onLtr: constant([
                        south$1,
                        north$1,
                        southeast$1,
                        northeast$1,
                        southwest$1,
                        northwest$1,
                    ]),
                    onRtl: constant([
                        south$1,
                        north$1,
                        southeast$1,
                        northeast$1,
                        southwest$1,
                        northwest$1,
                    ]),
                },
            };
        }),
        onHandler('onHide'),
        onHandler('onShow'),
    ];

    const init$4 = function() {
        const timer = Cell(Option.none());
        const popup = Cell(Option.none());
        const getTooltip = function() {
            return popup.get();
        };
        const setTooltip = function(s) {
            popup.set(Option.some(s));
        };
        const clearTooltip = function() {
            popup.set(Option.none());
        };
        const clearTimer = function() {
            timer.get().each(function(t) {
                domGlobals.clearTimeout(t);
            });
        };
        const resetTimer = function(f, delay) {
            clearTimer();
            timer.set(
                Option.some(
                    domGlobals.setTimeout(function() {
                        f();
                    }, delay),
                ),
            );
        };
        const isShowing = function() {
            return popup.get().isSome();
        };
        const readState = constant('not-implemented');
        return nu$5({
            getTooltip,
            isShowing,
            setTooltip,
            clearTooltip,
            clearTimer,
            resetTimer,
            readState,
        });
    };

    const TooltippingState = /* #__PURE__ */ Object.freeze({
        init: init$4,
    });

    const ExclusivityChannel = generate$1('tooltip.exclusive');
    const ShowTooltipEvent = generate$1('tooltip.show');
    const HideTooltipEvent = generate$1('tooltip.hide');

    const hideAllExclusive = function(component, tConfig, tState) {
        component.getSystem().broadcastOn([ExclusivityChannel], {});
    };
    const setComponents = function(component, tConfig, tState, specs) {
        tState.getTooltip().each(function(tooltip) {
            if (tooltip.getSystem().isConnected()) {
                Replacing.set(tooltip, specs);
            }
        });
    };

    const TooltippingApis = /* #__PURE__ */ Object.freeze({
        hideAllExclusive,
        setComponents,
    });

    const events$8 = function(tooltipConfig, state) {
        const hide = function(comp) {
            state.getTooltip().each(function(p) {
                detach(p);
                tooltipConfig.onHide(comp, p);
                state.clearTooltip();
            });
            state.clearTimer();
        };
        const show = function(comp) {
            if (!state.isShowing()) {
                hideAllExclusive(comp);
                const sink = tooltipConfig.lazySink(comp).getOrDie();
                const popup = comp.getSystem().build({
                    dom: tooltipConfig.tooltipDom,
                    components: tooltipConfig.tooltipComponents,
                    events: derive(
                        tooltipConfig.mode === 'normal'
                            ? [
                                  run(mouseover(), function(_) {
                                      emit(comp, ShowTooltipEvent);
                                  }),
                                  run(mouseout(), function(_) {
                                      emit(comp, HideTooltipEvent);
                                  }),
                              ]
                            : [],
                    ),
                    behaviours: derive$1([Replacing.config({})]),
                });
                state.setTooltip(popup);
                attach$1(sink, popup);
                tooltipConfig.onShow(comp, popup);
                Positioning.position(sink, tooltipConfig.anchor(comp), popup);
            }
        };
        return derive(
            flatten([
                [
                    run(ShowTooltipEvent, function(comp) {
                        state.resetTimer(function() {
                            show(comp);
                        }, tooltipConfig.delay);
                    }),
                    run(HideTooltipEvent, function(comp) {
                        state.resetTimer(function() {
                            hide(comp);
                        }, tooltipConfig.delay);
                    }),
                    run(receive(), function(comp, message) {
                        const receivingData = message;
                        if (
                            contains(
                                receivingData.channels(),
                                ExclusivityChannel,
                            )
                        ) {
                            hide(comp);
                        }
                    }),
                    runOnDetached(function(comp) {
                        hide(comp);
                    }),
                ],
                tooltipConfig.mode === 'normal'
                    ? [
                          run(focusin(), function(comp) {
                              emit(comp, ShowTooltipEvent);
                          }),
                          run(postBlur(), function(comp) {
                              emit(comp, HideTooltipEvent);
                          }),
                          run(mouseover(), function(comp) {
                              emit(comp, ShowTooltipEvent);
                          }),
                          run(mouseout(), function(comp) {
                              emit(comp, HideTooltipEvent);
                          }),
                      ]
                    : [
                          run(highlight(), function(comp, se) {
                              emit(comp, ShowTooltipEvent);
                          }),
                          run(dehighlight(), function(comp) {
                              emit(comp, HideTooltipEvent);
                          }),
                      ],
            ]),
        );
    };

    const ActiveTooltipping = /* #__PURE__ */ Object.freeze({
        events: events$8,
    });

    const Tooltipping = create$1({
        fields: TooltippingSchema,
        name: 'tooltipping',
        active: ActiveTooltipping,
        state: TooltippingState,
        apis: TooltippingApis,
    });

    const getAttrs = function(elem) {
        const attributes =
            elem.dom().attributes !== undefined ? elem.dom().attributes : [];
        return foldl(
            attributes,
            function(b, attr) {
                let _a;
                if (attr.name === 'class') {
                    return b;
                }
                return {
                    ...b,
                    ...((_a = {}), (_a[attr.name] = attr.value), _a),
                };
            },
            {},
        );
    };
    const getClasses = function(elem) {
        return Array.prototype.slice.call(elem.dom().classList, 0);
    };
    const fromHtml$2 = function(html) {
        const elem = Element.fromHtml(html);
        const children$1 = children(elem);
        const attrs = getAttrs(elem);
        const classes = getClasses(elem);
        const contents =
            children$1.length === 0 ? {} : { innerHtml: get$1(elem) };
        return {
            tag: name(elem),
            classes,
            attributes: attrs,
            ...contents,
        };
    };

    const global$5 = tinymce.util.Tools.resolve('tinymce.util.I18n');

    const navClass = 'tox-menu-nav__js';
    const selectableClass = 'tox-collection__item';
    const colorClass = 'tox-swatch';
    const presetClasses = {
        normal: navClass,
        color: colorClass,
    };
    const tickedClass = 'tox-collection__item--enabled';
    const groupHeadingClass = 'tox-collection__group-heading';
    const iconClass = 'tox-collection__item-icon';
    const textClass = 'tox-collection__item-label';
    const accessoryClass = 'tox-collection__item-accessory';
    const caretClass = 'tox-collection__item-caret';
    const checkmarkClass = 'tox-collection__item-checkmark';
    const activeClass = 'tox-collection__item--active';
    const iconClassRtl = 'tox-collection__item-icon-rtl';
    const classForPreset = function(presets) {
        return readOptFrom$1(presetClasses, presets).getOr(navClass);
    };

    const global$6 = tinymce.util.Tools.resolve('tinymce.Env');

    const convertText = function(source) {
        const mac = {
            alt: '&#x2325;',
            ctrl: '&#x2303;',
            shift: '&#x21E7;',
            meta: '&#x2318;',
            access: '&#x2303;&#x2325;',
        };
        const other = {
            meta: 'Ctrl',
            access: 'Shift+Alt',
        };
        const replace = global$6.mac ? mac : other;
        const shortcut = source.split('+');
        const updated = map(shortcut, function(segment) {
            const search = segment.toLowerCase().trim();
            return has(replace, search) ? replace[search] : segment;
        });
        return global$6.mac ? updated.join('') : updated.join('+');
    };
    const ConvertShortcut = { convertText };

    const renderIcon = function(iconHtml) {
        return {
            dom: {
                tag: 'div',
                classes: [iconClass],
                innerHtml: iconHtml,
            },
        };
    };
    const renderText = function(text$1) {
        return {
            dom: {
                tag: 'div',
                classes: [textClass],
            },
            components: [text(global$5.translate(text$1))],
        };
    };
    const renderHtml = function(html) {
        return {
            dom: {
                tag: 'div',
                classes: [textClass],
                innerHtml: html,
            },
        };
    };
    const renderStyledText = function(style, text$1) {
        return {
            dom: {
                tag: 'div',
                classes: [textClass],
            },
            components: [
                {
                    dom: {
                        tag: style.tag,
                        attributes: { style: style.styleAttr },
                    },
                    components: [text(global$5.translate(text$1))],
                },
            ],
        };
    };
    const renderShortcut = function(shortcut) {
        return {
            dom: {
                tag: 'div',
                classes: [accessoryClass],
                innerHtml: ConvertShortcut.convertText(shortcut),
            },
        };
    };
    const renderCheckmark = function(icons) {
        return {
            dom: {
                tag: 'div',
                classes: [iconClass, checkmarkClass],
                innerHtml: get$c('checkmark', icons),
            },
        };
    };
    const renderSubmenuCaret = function(icons) {
        return {
            dom: {
                tag: 'div',
                classes: [caretClass],
                innerHtml: get$c('chevron-right', icons),
            },
        };
    };
    const renderDownwardsCaret = function(icons) {
        return {
            dom: {
                tag: 'div',
                classes: [caretClass],
                innerHtml: get$c('chevron-down', icons),
            },
        };
    };

    const renderColorStructure = function(
        itemText,
        itemValue,
        iconSvg,
        providerBackstage,
    ) {
        const colorPickerCommand = 'custom';
        const removeColorCommand = 'remove';
        const getDom = function() {
            const common = colorClass;
            const icon = iconSvg.getOr('');
            const title = itemText
                .map(function(text) {
                    return ` title="${providerBackstage.translate(text)}"`;
                })
                .getOr('');
            if (itemValue === colorPickerCommand) {
                return fromHtml$2(
                    `<button class="${common} tox-swatches__picker-btn"${title}>${icon}</button>`,
                );
            }
            if (itemValue === removeColorCommand) {
                return fromHtml$2(
                    `<div class="${common} tox-swatch--remove"${title}>${icon}</div>`,
                );
            }
            return fromHtml$2(
                `<div class="${common}" style="background-color: ${itemValue}" data-mce-color="${itemValue}"${title}></div>`,
            );
        };
        return {
            dom: getDom(),
            optComponents: [],
        };
    };
    const renderNormalItemStructure = function(
        info,
        icon,
        renderIcons,
        textRender,
        rtlClass,
    ) {
        const leftIcon = renderIcons
            ? info.checkMark.orThunk(function() {
                  return icon.or(Option.some('')).map(renderIcon);
              })
            : Option.none();
        const domTitle = info.ariaLabel
            .map(function(label) {
                return { attributes: { title: global$5.translate(label) } };
            })
            .getOr({});
        const dom = merge(
            {
                tag: 'div',
                classes: [navClass, selectableClass].concat(
                    rtlClass ? [iconClassRtl] : [],
                ),
            },
            domTitle,
        );
        const content = info.htmlContent.fold(
            function() {
                return info.textContent.map(textRender);
            },
            function(html) {
                return Option.some(renderHtml(html));
            },
        );
        const menuItem = {
            dom,
            optComponents: [
                leftIcon,
                content,
                info.shortcutContent.map(renderShortcut),
                info.caret,
            ],
        };
        return menuItem;
    };
    const rtlIcon = [
        'list-num-default',
        'list-num-lower-alpha',
        'list-num-lower-greek',
        'list-num-lower-roman',
        'list-num-upper-alpha',
        'list-num-upper-roman',
    ];
    const rtlTransform = [
        'list-bull-circle',
        'list-bull-default',
        'list-bull-square',
    ];
    const renderItemStructure = function(
        info,
        providersBackstage,
        renderIcons,
        fallbackIcon,
    ) {
        if (fallbackIcon === void 0) {
            fallbackIcon = Option.none();
        }
        const getIconName = function(iconName) {
            return iconName.map(function(name) {
                return global$5.isRtl() && contains(rtlIcon, name)
                    ? `${name}-rtl`
                    : name;
            });
        };
        const needRtlClass =
            global$5.isRtl() &&
            info.iconContent.exists(function(name) {
                return contains(rtlTransform, name);
            });
        const icon = getIconName(info.iconContent).map(function(iconName) {
            return getOr(iconName, providersBackstage.icons, fallbackIcon);
        });
        const textRender = Option.from(info.meta).fold(
            function() {
                return renderText;
            },
            function(meta) {
                return has(meta, 'style')
                    ? curry(renderStyledText, meta.style)
                    : renderText;
            },
        );
        if (info.presets === 'color') {
            return renderColorStructure(
                info.ariaLabel,
                info.value,
                icon,
                providersBackstage,
            );
        }
        return renderNormalItemStructure(
            info,
            icon,
            renderIcons,
            textRender,
            needRtlClass,
        );
    };

    const nativeDisabled = ['input', 'button', 'textarea', 'select'];
    const onLoad$5 = function(component, disableConfig, disableState) {
        if (disableConfig.disabled) {
            disable(component, disableConfig);
        }
    };
    const hasNative = function(component, config) {
        return (
            config.useNative === true &&
            contains(nativeDisabled, name(component.element()))
        );
    };
    const nativeIsDisabled = function(component) {
        return has$1(component.element(), 'disabled');
    };
    const nativeDisable = function(component) {
        set$1(component.element(), 'disabled', 'disabled');
    };
    const nativeEnable = function(component) {
        remove$1(component.element(), 'disabled');
    };
    const ariaIsDisabled = function(component) {
        return get$2(component.element(), 'aria-disabled') === 'true';
    };
    const ariaDisable = function(component) {
        set$1(component.element(), 'aria-disabled', 'true');
    };
    const ariaEnable = function(component) {
        set$1(component.element(), 'aria-disabled', 'false');
    };
    var disable = function(component, disableConfig, disableState) {
        disableConfig.disableClass.each(function(disableClass) {
            add$2(component.element(), disableClass);
        });
        const f = hasNative(component, disableConfig)
            ? nativeDisable
            : ariaDisable;
        f(component);
        disableConfig.onDisabled(component);
    };
    const enable = function(component, disableConfig, disableState) {
        disableConfig.disableClass.each(function(disableClass) {
            remove$4(component.element(), disableClass);
        });
        const f = hasNative(component, disableConfig)
            ? nativeEnable
            : ariaEnable;
        f(component);
        disableConfig.onEnabled(component);
    };
    const isDisabled = function(component, disableConfig) {
        return hasNative(component, disableConfig)
            ? nativeIsDisabled(component)
            : ariaIsDisabled(component);
    };
    const set$7 = function(component, disableConfig, disableState, disabled) {
        const f = disabled ? disable : enable;
        f(component, disableConfig, disableState);
    };

    const DisableApis = /* #__PURE__ */ Object.freeze({
        enable,
        disable,
        isDisabled,
        onLoad: onLoad$5,
        set: set$7,
    });

    const exhibit$3 = function(base, disableConfig, disableState) {
        return nu$6({
            classes: disableConfig.disabled
                ? disableConfig.disableClass.map(pure).getOr([])
                : [],
        });
    };
    const events$9 = function(disableConfig, disableState) {
        return derive([
            abort(execute(), function(component, simulatedEvent) {
                return isDisabled(component, disableConfig);
            }),
            loadEvent(disableConfig, disableState, onLoad$5),
        ]);
    };

    const ActiveDisable = /* #__PURE__ */ Object.freeze({
        exhibit: exhibit$3,
        events: events$9,
    });

    const DisableSchema = [
        defaulted$1('disabled', false),
        defaulted$1('useNative', true),
        option('disableClass'),
        onHandler('onDisabled'),
        onHandler('onEnabled'),
    ];

    const Disabling = create$1({
        fields: DisableSchema,
        name: 'disabling',
        active: ActiveDisable,
        apis: DisableApis,
    });

    const item = function(disabled) {
        return Disabling.config({
            disabled,
            disableClass: 'tox-collection__item--state-disabled',
        });
    };
    const button = function(disabled) {
        return Disabling.config({ disabled });
    };
    const splitButton = function(disabled) {
        return Disabling.config({
            disabled,
            disableClass: 'tox-tbtn--disabled',
        });
    };
    const toolbarButton = function(disabled) {
        return Disabling.config({
            disabled,
            disableClass: 'tox-tbtn--disabled',
            useNative: false,
        });
    };
    const DisablingConfigs = {
        item,
        button,
        splitButton,
        toolbarButton,
    };

    const runWithApi = function(info, comp) {
        const api = info.getApi(comp);
        return function(f) {
            f(api);
        };
    };
    const onControlAttached = function(info, editorOffCell) {
        return runOnAttached(function(comp) {
            const run = runWithApi(info, comp);
            run(function(api) {
                const onDestroy = info.onSetup(api);
                if (onDestroy !== null && onDestroy !== undefined) {
                    editorOffCell.set(onDestroy);
                }
            });
        });
    };
    const onControlDetached = function(getApi, editorOffCell) {
        return runOnDetached(function(comp) {
            return runWithApi(getApi, comp)(editorOffCell.get());
        });
    };

    let ItemResponse;
    (function(ItemResponse) {
        ItemResponse[(ItemResponse.CLOSE_ON_EXECUTE = 0)] = 'CLOSE_ON_EXECUTE';
        ItemResponse[(ItemResponse.BUBBLE_TO_SANDBOX = 1)] =
            'BUBBLE_TO_SANDBOX';
    })(ItemResponse || (ItemResponse = {}));
    const ItemResponse$1 = ItemResponse;

    const onMenuItemExecute = function(info, itemResponse) {
        return runOnExecute(function(comp, simulatedEvent) {
            runWithApi(info, comp)(info.onAction);
            if (
                !info.triggersSubmenu &&
                itemResponse === ItemResponse$1.CLOSE_ON_EXECUTE
            ) {
                emit(comp, sandboxClose());
                simulatedEvent.stop();
            }
        });
    };
    const menuItemEventOrder = {
        'alloy.execute': [
            'disabling',
            'alloy.base.behaviour',
            'toggling',
            'item-events',
        ],
    };

    const componentRenderPipeline = function(xs) {
        return bind(xs, function(o) {
            return o.toArray();
        });
    };
    const renderCommonItem = function(spec, structure, itemResponse) {
        const editorOffCell = Cell(noop);
        return {
            type: 'item',
            dom: structure.dom,
            components: componentRenderPipeline(structure.optComponents),
            data: spec.data,
            eventOrder: menuItemEventOrder,
            hasSubmenu: spec.triggersSubmenu,
            itemBehaviours: derive$1(
                [
                    config('item-events', [
                        onMenuItemExecute(spec, itemResponse),
                        onControlAttached(spec, editorOffCell),
                        onControlDetached(spec, editorOffCell),
                    ]),
                    DisablingConfigs.item(spec.disabled),
                    Replacing.config({}),
                ].concat(spec.itemBehaviours),
            ),
        };
    };
    const buildData = function(source) {
        return {
            value: source.value,
            meta: merge({ text: source.text.getOr('') }, source.meta),
        };
    };

    const global$7 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');

    const tooltipBehaviour = function(meta, sharedBackstage) {
        return get(meta, 'tooltipWorker')
            .map(function(tooltipWorker) {
                return [
                    Tooltipping.config({
                        lazySink: sharedBackstage.getSink,
                        tooltipDom: {
                            tag: 'div',
                            classes: ['tox-tooltip-worker-container'],
                        },
                        tooltipComponents: [],
                        anchor(comp) {
                            return {
                                anchor: 'submenu',
                                item: comp,
                                overrides: { maxHeightFunction: expandable },
                            };
                        },
                        mode: 'follow-highlight',
                        onShow(component, _tooltip) {
                            tooltipWorker(function(elm) {
                                Tooltipping.setComponents(component, [
                                    external({ element: Element.fromDom(elm) }),
                                ]);
                            });
                        },
                    }),
                ];
            })
            .getOr([]);
    };
    const escapeRegExp = function(text) {
        return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    };
    const encodeText = function(text) {
        return global$7.DOM.encode(text);
    };
    const replaceText = function(text, matchText) {
        const translated = global$5.translate(text);
        const encoded = encodeText(translated);
        if (matchText.length > 0) {
            const escapedMatchRegex = new RegExp(escapeRegExp(matchText), 'gi');
            return encoded.replace(escapedMatchRegex, function(match) {
                return `<span class="tox-autocompleter-highlight">${match}</span>`;
            });
        }
        return encoded;
    };
    const renderAutocompleteItem = function(
        spec,
        matchText,
        useText,
        presets,
        onItemValueHandler,
        itemResponse,
        sharedBackstage,
        renderIcons,
    ) {
        if (renderIcons === void 0) {
            renderIcons = true;
        }
        const structure = renderItemStructure(
            {
                presets,
                textContent: Option.none(),
                htmlContent: useText
                    ? spec.text.map(function(text) {
                          return replaceText(text, matchText);
                      })
                    : Option.none(),
                ariaLabel: spec.text,
                iconContent: spec.icon,
                shortcutContent: Option.none(),
                checkMark: Option.none(),
                caret: Option.none(),
                value: spec.value,
            },
            sharedBackstage.providers,
            renderIcons,
            spec.icon,
        );
        return renderCommonItem(
            {
                data: buildData(spec),
                disabled: spec.disabled,
                getApi() {
                    return {};
                },
                onAction(_api) {
                    return onItemValueHandler(spec.value, spec.meta);
                },
                onSetup() {
                    return function() {};
                },
                triggersSubmenu: false,
                itemBehaviours: tooltipBehaviour(spec.meta, sharedBackstage),
            },
            structure,
            itemResponse,
        );
    };

    const renderChoiceItem = function(
        spec,
        useText,
        presets,
        onItemValueHandler,
        isSelected,
        itemResponse,
        providersBackstage,
    ) {
        const getApi = function(component) {
            return {
                setActive(state) {
                    Toggling.set(component, state);
                },
                isActive() {
                    return Toggling.isOn(component);
                },
                isDisabled() {
                    return Disabling.isDisabled(component);
                },
                setDisabled(state) {
                    return Disabling.set(component, state);
                },
            };
        };
        const structure = renderItemStructure(
            {
                presets,
                textContent: useText ? spec.text : Option.none(),
                htmlContent: Option.none(),
                ariaLabel: spec.text,
                iconContent: spec.icon,
                shortcutContent: useText ? spec.shortcut : Option.none(),
                checkMark: useText
                    ? Option.some(renderCheckmark(providersBackstage.icons))
                    : Option.none(),
                caret: Option.none(),
                value: spec.value,
            },
            providersBackstage,
            true,
        );
        return deepMerge(
            renderCommonItem(
                {
                    data: buildData(spec),
                    disabled: spec.disabled,
                    getApi,
                    onAction(_api) {
                        return onItemValueHandler(spec.value);
                    },
                    onSetup(api) {
                        api.setActive(isSelected);
                        return function() {};
                    },
                    triggersSubmenu: false,
                    itemBehaviours: [],
                },
                structure,
                itemResponse,
            ),
            {
                toggling: {
                    toggleClass: tickedClass,
                    toggleOnExecute: false,
                    selected: spec.active,
                },
            },
        );
    };

    const parts$2 = constant(generate$4(owner$2(), parts()));

    const cellOverEvent = generate$1('cell-over');
    const cellExecuteEvent = generate$1('cell-execute');
    const makeCell = function(row, col, labelId) {
        let _a;
        const emitCellOver = function(c) {
            return emitWith(c, cellOverEvent, {
                row,
                col,
            });
        };
        const emitExecute = function(c) {
            return emitWith(c, cellExecuteEvent, {
                row,
                col,
            });
        };
        const onClick = function(c, se) {
            se.stop();
            emitExecute(c);
        };
        return build$1({
            dom: {
                tag: 'div',
                attributes:
                    ((_a = { role: 'button' }),
                    (_a['aria-labelledby'] = labelId),
                    _a),
            },
            behaviours: derive$1([
                config('insert-table-picker-cell', [
                    run(mouseover(), Focusing.focus),
                    run(execute(), emitExecute),
                    run(click(), onClick),
                    run(tap(), onClick),
                ]),
                Toggling.config({
                    toggleClass: 'tox-insert-table-picker__selected',
                    toggleOnExecute: false,
                }),
                Focusing.config({ onFocus: emitCellOver }),
            ]),
        });
    };
    const makeCells = function(labelId, numRows, numCols) {
        const cells = [];
        for (let i = 0; i < numRows; i++) {
            const row = [];
            for (let j = 0; j < numCols; j++) {
                row.push(makeCell(i, j, labelId));
            }
            cells.push(row);
        }
        return cells;
    };
    const selectCells = function(
        cells,
        selectedRow,
        selectedColumn,
        numRows,
        numColumns,
    ) {
        for (let i = 0; i < numRows; i++) {
            for (let j = 0; j < numColumns; j++) {
                Toggling.set(
                    cells[i][j],
                    i <= selectedRow && j <= selectedColumn,
                );
            }
        }
    };
    const makeComponents = function(cells) {
        return bind(cells, function(cellRow) {
            return map(cellRow, premade$1);
        });
    };
    const makeLabelText = function(row, col) {
        return text(`${col + 1}x${row + 1}`);
    };
    function renderInsertTableMenuItem(spec) {
        const numRows = 10;
        const numColumns = 10;
        const sizeLabelId = generate$1('size-label');
        const cells = makeCells(sizeLabelId, numRows, numColumns);
        const memLabel = record({
            dom: {
                tag: 'span',
                classes: ['tox-insert-table-picker__label'],
                attributes: { id: sizeLabelId },
            },
            components: [text('0x0')],
            behaviours: derive$1([Replacing.config({})]),
        });
        return {
            type: 'widget',
            data: { value: generate$1('widget-id') },
            dom: {
                tag: 'div',
                classes: ['tox-fancymenuitem'],
            },
            autofocus: true,
            components: [
                parts$2().widget({
                    dom: {
                        tag: 'div',
                        classes: ['tox-insert-table-picker'],
                    },
                    components: makeComponents(cells).concat(memLabel.asSpec()),
                    behaviours: derive$1([
                        config('insert-table-picker', [
                            runWithTarget(cellOverEvent, function(c, t, e) {
                                const row = e.event().row();
                                const col = e.event().col();
                                selectCells(
                                    cells,
                                    row,
                                    col,
                                    numRows,
                                    numColumns,
                                );
                                Replacing.set(memLabel.get(c), [
                                    makeLabelText(row, col),
                                ]);
                            }),
                            runWithTarget(cellExecuteEvent, function(c, _, e) {
                                spec.onAction({
                                    numRows: e.event().row() + 1,
                                    numColumns: e.event().col() + 1,
                                });
                                emit(c, sandboxClose());
                            }),
                        ]),
                        Keying.config({
                            initSize: {
                                numRows,
                                numColumns,
                            },
                            mode: 'flatgrid',
                            selector: '[role="button"]',
                        }),
                    ]),
                }),
            ],
        };
    }

    const hexColour = function(hexString) {
        return { value: constant(hexString) };
    };
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    const longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
    const isHexString = function(hex) {
        return shorthandRegex.test(hex) || longformRegex.test(hex);
    };
    const getLongForm = function(hex) {
        const hexString = hex
            .value()
            .replace(shorthandRegex, function(m, r, g, b) {
                return r + r + g + g + b + b;
            });
        return { value: constant(hexString) };
    };
    const extractValues = function(hex) {
        const longForm = getLongForm(hex);
        const splitForm = longformRegex.exec(longForm.value());
        return splitForm === null ? ['FFFFFF', 'FF', 'FF', 'FF'] : splitForm;
    };
    const toHex = function(component) {
        const hex = component.toString(16);
        return hex.length === 1 ? `0${hex}` : hex;
    };
    const fromRgba = function(rgbaColour) {
        const value =
            toHex(rgbaColour.red()) +
            toHex(rgbaColour.green()) +
            toHex(rgbaColour.blue());
        return hexColour(value);
    };

    const { min } = Math;
    const { max } = Math;
    const { round } = Math;
    const rgbRegex = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)/;
    const rgbaRegex = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d?(?:\.\d+)?)\)/;
    const rgbaColour = function(red, green, blue, alpha) {
        return {
            red: constant(red),
            green: constant(green),
            blue: constant(blue),
            alpha: constant(alpha),
        };
    };
    const isRgbaComponent = function(value) {
        const num = parseInt(value, 10);
        return num.toString() === value && num >= 0 && num <= 255;
    };
    const fromHsv = function(hsv) {
        let r;
        let g;
        let b;
        const hue = (hsv.hue() || 0) % 360;
        let saturation = hsv.saturation() / 100;
        let brightness = hsv.value() / 100;
        saturation = max(0, min(saturation, 1));
        brightness = max(0, min(brightness, 1));
        if (saturation === 0) {
            r = g = b = round(255 * brightness);
            return rgbaColour(r, g, b, 1);
        }
        const side = hue / 60;
        const chroma = brightness * saturation;
        const x = chroma * (1 - Math.abs((side % 2) - 1));
        const match = brightness - chroma;
        switch (Math.floor(side)) {
            case 0:
                r = chroma;
                g = x;
                b = 0;
                break;
            case 1:
                r = x;
                g = chroma;
                b = 0;
                break;
            case 2:
                r = 0;
                g = chroma;
                b = x;
                break;
            case 3:
                r = 0;
                g = x;
                b = chroma;
                break;
            case 4:
                r = x;
                g = 0;
                b = chroma;
                break;
            case 5:
                r = chroma;
                g = 0;
                b = x;
                break;
            default:
                r = g = b = 0;
        }
        r = round(255 * (r + match));
        g = round(255 * (g + match));
        b = round(255 * (b + match));
        return rgbaColour(r, g, b, 1);
    };
    const fromHex = function(hexColour) {
        const result = extractValues(hexColour);
        const red = parseInt(result[1], 16);
        const green = parseInt(result[2], 16);
        const blue = parseInt(result[3], 16);
        return rgbaColour(red, green, blue, 1);
    };
    const fromStringValues = function(red, green, blue, alpha) {
        const r = parseInt(red, 10);
        const g = parseInt(green, 10);
        const b = parseInt(blue, 10);
        const a = parseFloat(alpha);
        return rgbaColour(r, g, b, a);
    };
    const fromString = function(rgbaString) {
        if (rgbaString === 'transparent') {
            return Option.some(rgbaColour(0, 0, 0, 0));
        }
        const rgbMatch = rgbRegex.exec(rgbaString);
        if (rgbMatch !== null) {
            return Option.some(
                fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'),
            );
        }
        const rgbaMatch = rgbaRegex.exec(rgbaString);
        if (rgbaMatch !== null) {
            return Option.some(
                fromStringValues(
                    rgbaMatch[1],
                    rgbaMatch[2],
                    rgbaMatch[3],
                    rgbaMatch[4],
                ),
            );
        }
        return Option.none();
    };
    const toString = function(rgba) {
        return `rgba(${rgba.red()},${rgba.green()},${rgba.blue()},${rgba.alpha()})`;
    };
    const redColour = constant(rgbaColour(255, 0, 0, 1));

    const global$8 = tinymce.util.Tools.resolve('tinymce.util.LocalStorage');

    const storageName = 'tinymce-custom-colors';
    function ColorCache(max) {
        if (max === void 0) {
            max = 10;
        }
        const storageString = global$8.getItem(storageName);
        const localstorage = isString(storageString)
            ? JSON.parse(storageString)
            : [];
        const prune = function(list) {
            const diff = max - list.length;
            return diff < 0 ? list.slice(0, max) : list;
        };
        const cache = prune(localstorage);
        const add = function(key) {
            indexOf(cache, key).each(remove);
            cache.unshift(key);
            if (cache.length > max) {
                cache.pop();
            }
            global$8.setItem(storageName, JSON.stringify(cache));
        };
        var remove = function(idx) {
            cache.splice(idx, 1);
        };
        const state = function() {
            return cache.slice(0);
        };
        return {
            add,
            state,
        };
    }

    const choiceItem = 'choiceitem';
    const defaultColors = [
        {
            type: choiceItem,
            text: 'Light Green',
            value: '#BFEDD2',
        },
        {
            type: choiceItem,
            text: 'Light Yellow',
            value: '#FBEEB8',
        },
        {
            type: choiceItem,
            text: 'Light Red',
            value: '#F8CAC6',
        },
        {
            type: choiceItem,
            text: 'Light Purple',
            value: '#ECCAFA',
        },
        {
            type: choiceItem,
            text: 'Light Blue',
            value: '#C2E0F4',
        },
        {
            type: choiceItem,
            text: 'Green',
            value: '#2DC26B',
        },
        {
            type: choiceItem,
            text: 'Yellow',
            value: '#F1C40F',
        },
        {
            type: choiceItem,
            text: 'Red',
            value: '#E03E2D',
        },
        {
            type: choiceItem,
            text: 'Purple',
            value: '#B96AD9',
        },
        {
            type: choiceItem,
            text: 'Blue',
            value: '#3598DB',
        },
        {
            type: choiceItem,
            text: 'Dark Turquoise',
            value: '#169179',
        },
        {
            type: choiceItem,
            text: 'Orange',
            value: '#E67E23',
        },
        {
            type: choiceItem,
            text: 'Dark Red',
            value: '#BA372A',
        },
        {
            type: choiceItem,
            text: 'Dark Purple',
            value: '#843FA1',
        },
        {
            type: choiceItem,
            text: 'Dark Blue',
            value: '#236FA1',
        },
        {
            type: choiceItem,
            text: 'Light Gray',
            value: '#ECF0F1',
        },
        {
            type: choiceItem,
            text: 'Medium Gray',
            value: '#CED4D9',
        },
        {
            type: choiceItem,
            text: 'Gray',
            value: '#95A5A6',
        },
        {
            type: choiceItem,
            text: 'Dark Gray',
            value: '#7E8C8D',
        },
        {
            type: choiceItem,
            text: 'Navy Blue',
            value: '#34495E',
        },
        {
            type: choiceItem,
            text: 'Black',
            value: '#000000',
        },
        {
            type: choiceItem,
            text: 'White',
            value: '#ffffff',
        },
    ];
    const colorCache = ColorCache(10);
    const mapColors = function(colorMap) {
        const colors = [];
        const canvas = domGlobals.document.createElement('canvas');
        canvas.height = 1;
        canvas.width = 1;
        const ctx = canvas.getContext('2d');
        const byteAsHex = function(colorByte, alphaByte) {
            const bg = 255;
            const alpha = alphaByte / 255;
            const colorByteWithWhiteBg = Math.round(
                colorByte * alpha + bg * (1 - alpha),
            );
            return `0${colorByteWithWhiteBg.toString(16)}`
                .slice(-2)
                .toUpperCase();
        };
        const asHexColor = function(color) {
            if (/^[0-9A-Fa-f]{6}$/.test(color)) {
                return `#${color.toUpperCase()}`;
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#FFFFFF';
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 1, 1);
            const rgba = ctx.getImageData(0, 0, 1, 1).data;
            const r = rgba[0];
            const g = rgba[1];
            const b = rgba[2];
            const a = rgba[3];
            return `#${byteAsHex(r, a)}${byteAsHex(g, a)}${byteAsHex(b, a)}`;
        };
        for (let i = 0; i < colorMap.length; i += 2) {
            colors.push({
                text: colorMap[i + 1],
                value: asHexColor(colorMap[i]),
                type: 'choiceitem',
            });
        }
        return colors;
    };
    const getColorCols = function(editor, defaultCols) {
        return editor.getParam('color_cols', defaultCols, 'number');
    };
    const hasCustomColors = function(editor) {
        return editor.getParam('custom_colors') !== false;
    };
    const getColorMap = function(editor) {
        return editor.getParam('color_map');
    };
    const getColors = function(editor) {
        const unmapped = getColorMap(editor);
        return unmapped !== undefined ? mapColors(unmapped) : defaultColors;
    };
    const getCurrentColors = function() {
        return map(colorCache.state(), function(color) {
            return {
                type: choiceItem,
                text: color,
                value: color,
            };
        });
    };
    const addColor = function(color) {
        colorCache.add(color);
    };
    const Settings = {
        mapColors,
        getColorCols,
        hasCustomColors,
        getColorMap,
        getColors,
        getCurrentColors,
        addColor,
    };

    const fireSkinLoaded = function(editor) {
        return editor.fire('SkinLoaded');
    };
    const fireResizeEditor = function(editor) {
        return editor.fire('ResizeEditor');
    };
    const fireBeforeRenderUI = function(editor) {
        return editor.fire('BeforeRenderUI');
    };
    const fireResizeContent = function(editor, e) {
        return editor.fire('ResizeContent', e);
    };
    const fireScrollContent = function(editor, e) {
        return editor.fire('ScrollContent', e);
    };
    const fireTextColorChange = function(editor, data) {
        return editor.fire('TextColorChange', data);
    };
    const Events = {
        fireSkinLoaded,
        fireResizeEditor,
        fireScrollContent,
        fireBeforeRenderUI,
        fireResizeContent,
        fireTextColorChange,
    };

    const getCurrentColor = function(editor, format) {
        let color;
        editor.dom.getParents(editor.selection.getStart(), function(elm) {
            let value;
            if (
                (value =
                    elm.style[
                        format === 'forecolor' ? 'color' : 'background-color'
                    ])
            ) {
                color = color || value;
            }
        });
        return color;
    };
    const applyFormat = function(editor, format, value) {
        editor.undoManager.transact(function() {
            editor.focus();
            editor.formatter.apply(format, { value });
            editor.nodeChanged();
        });
    };
    const removeFormat = function(editor, format) {
        editor.undoManager.transact(function() {
            editor.focus();
            editor.formatter.remove(format, { value: null }, null, true);
            editor.nodeChanged();
        });
    };
    const registerCommands = function(editor) {
        editor.addCommand('mceApplyTextcolor', function(format, value) {
            applyFormat(editor, format, value);
        });
        editor.addCommand('mceRemoveTextcolor', function(format) {
            removeFormat(editor, format);
        });
    };
    const calcCols = function(colors) {
        return Math.max(5, Math.ceil(Math.sqrt(colors)));
    };
    const getColorCols$1 = function(editor) {
        const colors = Settings.getColors(editor);
        const defaultCols = calcCols(colors.length);
        return Settings.getColorCols(editor, defaultCols);
    };
    const getAdditionalColors = function(hasCustom) {
        const type = 'choiceitem';
        const remove = {
            type,
            text: 'Remove color',
            icon: 'color-swatch-remove-color',
            value: 'remove',
        };
        const custom = {
            type,
            text: 'Custom color',
            icon: 'color-picker',
            value: 'custom',
        };
        return hasCustom ? [remove, custom] : [remove];
    };
    const applyColor = function(editor, format, value, onChoice) {
        if (value === 'custom') {
            const dialog = colorPickerDialog(editor);
            dialog(function(colorOpt) {
                colorOpt.each(function(color) {
                    Settings.addColor(color);
                    editor.execCommand('mceApplyTextcolor', format, color);
                    onChoice(color);
                });
            }, '#000000');
        } else if (value === 'remove') {
            onChoice('');
            editor.execCommand('mceRemoveTextcolor', format);
        } else {
            onChoice(value);
            editor.execCommand('mceApplyTextcolor', format, value);
        }
    };
    const getMenuColors = function(colors, hasCustom) {
        return colors.concat(
            Settings.getCurrentColors().concat(getAdditionalColors(hasCustom)),
        );
    };
    const getFetch = function(colors, hasCustom) {
        return function(callback) {
            callback(getMenuColors(colors, hasCustom));
        };
    };
    const setIconColor = function(splitButtonApi, name, newColor) {
        const setIconFillAndStroke = function(pathId, color) {
            splitButtonApi.setIconFill(pathId, color);
            splitButtonApi.setIconStroke(pathId, color);
        };
        const id =
            name === 'forecolor'
                ? 'tox-icon-text-color__color'
                : 'tox-icon-highlight-bg-color__color';
        setIconFillAndStroke(id, newColor);
    };
    const registerTextColorButton = function(
        editor,
        name,
        format,
        tooltip,
        lastColor,
    ) {
        editor.ui.registry.addSplitButton(name, {
            tooltip,
            presets: 'color',
            icon: name === 'forecolor' ? 'text-color' : 'highlight-bg-color',
            select(value) {
                const optCurrentRgb = Option.from(
                    getCurrentColor(editor, format),
                );
                return optCurrentRgb
                    .bind(function(currentRgb) {
                        return fromString(currentRgb).map(function(rgba) {
                            const currentHex = fromRgba(rgba).value();
                            return contains$1(value.toLowerCase(), currentHex);
                        });
                    })
                    .getOr(false);
            },
            columns: getColorCols$1(editor),
            fetch: getFetch(
                Settings.getColors(editor),
                Settings.hasCustomColors(editor),
            ),
            onAction(splitButtonApi) {
                if (lastColor.get() !== null) {
                    applyColor(editor, format, lastColor.get(), function() {});
                }
            },
            onItemAction(splitButtonApi, value) {
                applyColor(editor, format, value, function(newColor) {
                    lastColor.set(newColor);
                    Events.fireTextColorChange(editor, {
                        name,
                        color: newColor,
                    });
                });
            },
            onSetup(splitButtonApi) {
                if (lastColor.get() !== null) {
                    setIconColor(splitButtonApi, name, lastColor.get());
                }
                const handler = function(e) {
                    if (e.name === name) {
                        setIconColor(splitButtonApi, e.name, e.color);
                    }
                };
                editor.on('TextColorChange', handler);
                return function() {
                    editor.off('TextColorChange', handler);
                };
            },
        });
    };
    const registerTextColorMenuItem = function(editor, name, format, text) {
        editor.ui.registry.addNestedMenuItem(name, {
            text,
            icon: name === 'forecolor' ? 'text-color' : 'highlight-bg-color',
            getSubmenuItems() {
                return [
                    {
                        type: 'fancymenuitem',
                        fancytype: 'colorswatch',
                        onAction(data) {
                            applyColor(editor, format, data.value, noop);
                        },
                    },
                ];
            },
        });
    };
    var colorPickerDialog = function(editor) {
        return function(callback, value) {
            const getOnSubmit = function(callback) {
                return function(api) {
                    const data = api.getData();
                    callback(Option.from(data.colorpicker));
                    api.close();
                };
            };
            const onAction = function(api, details) {
                if (details.name === 'hex-valid') {
                    if (details.value) {
                        api.enable('ok');
                    } else {
                        api.disable('ok');
                    }
                }
            };
            const initialData = { colorpicker: value };
            const submit = getOnSubmit(callback);
            editor.windowManager.open({
                title: 'Color Picker',
                size: 'normal',
                body: {
                    type: 'panel',
                    items: [
                        {
                            type: 'colorpicker',
                            name: 'colorpicker',
                            label: 'Color',
                        },
                    ],
                },
                buttons: [
                    {
                        type: 'cancel',
                        name: 'cancel',
                        text: 'Cancel',
                    },
                    {
                        type: 'submit',
                        name: 'save',
                        text: 'Save',
                        primary: true,
                    },
                ],
                initialData,
                onAction,
                onSubmit: submit,
                onClose() {},
                onCancel() {
                    callback(Option.none());
                },
            });
        };
    };
    const register$1 = function(editor) {
        registerCommands(editor);
        const lastForeColor = Cell(null);
        const lastBackColor = Cell(null);
        registerTextColorButton(
            editor,
            'forecolor',
            'forecolor',
            'Text color',
            lastForeColor,
        );
        registerTextColorButton(
            editor,
            'backcolor',
            'hilitecolor',
            'Background color',
            lastBackColor,
        );
        registerTextColorMenuItem(
            editor,
            'forecolor',
            'forecolor',
            'Text color',
        );
        registerTextColorMenuItem(
            editor,
            'backcolor',
            'hilitecolor',
            'Background color',
        );
    };
    const ColorSwatch = {
        register: register$1,
        getColors: getMenuColors,
        getFetch,
        colorPickerDialog,
        getCurrentColor,
        getColorCols: getColorCols$1,
        calcCols,
    };

    const chunk$1 = function(rowDom, numColumns) {
        return function(items) {
            const chunks = chunk(items, numColumns);
            return map(chunks, function(c) {
                return {
                    dom: rowDom,
                    components: c,
                };
            });
        };
    };
    const forSwatch = function(columns) {
        return {
            dom: {
                tag: 'div',
                classes: ['tox-menu', 'tox-swatches-menu'],
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-swatches'],
                    },
                    components: [
                        Menu.parts().items({
                            preprocess:
                                columns !== 'auto'
                                    ? chunk$1(
                                          {
                                              tag: 'div',
                                              classes: ['tox-swatches__row'],
                                          },
                                          columns,
                                      )
                                    : identity,
                        }),
                    ],
                },
            ],
        };
    };
    const forToolbar = function(columns) {
        return {
            dom: {
                tag: 'div',
                classes: [
                    'tox-menu',
                    'tox-collection',
                    'tox-collection--toolbar',
                    'tox-collection--toolbar-lg',
                ],
            },
            components: [
                Menu.parts().items({
                    preprocess: chunk$1(
                        {
                            tag: 'div',
                            classes: ['tox-collection__group'],
                        },
                        columns,
                    ),
                }),
            ],
        };
    };
    const preprocessCollection = function(items, isSeparator) {
        const allSplits = [];
        let currentSplit = [];
        each(items, function(item, i) {
            if (isSeparator(item, i)) {
                if (currentSplit.length > 0) {
                    allSplits.push(currentSplit);
                }
                currentSplit = [];
                if (has(item.dom, 'innerHtml')) {
                    currentSplit.push(item);
                }
            } else {
                currentSplit.push(item);
            }
        });
        if (currentSplit.length > 0) {
            allSplits.push(currentSplit);
        }
        return map(allSplits, function(s) {
            return {
                dom: {
                    tag: 'div',
                    classes: ['tox-collection__group'],
                },
                components: s,
            };
        });
    };
    const forCollection = function(columns, initItems, _hasIcons) {
        return {
            dom: {
                tag: 'div',
                classes: ['tox-menu', 'tox-collection'].concat(
                    columns === 1
                        ? ['tox-collection--list']
                        : ['tox-collection--grid'],
                ),
            },
            components: [
                Menu.parts().items({
                    preprocess(items) {
                        if (columns !== 'auto' && columns > 1) {
                            return chunk$1(
                                {
                                    tag: 'div',
                                    classes: ['tox-collection__group'],
                                },
                                columns,
                            )(items);
                        }
                        return preprocessCollection(items, function(_item, i) {
                            return initItems[i].type === 'separator';
                        });
                    },
                }),
            ],
        };
    };
    const forHorizontalCollection = function(initItems, _hasIcons) {
        return {
            dom: {
                tag: 'div',
                classes: ['tox-collection', 'tox-collection--horizontal'],
            },
            components: [
                Menu.parts().items({
                    preprocess(items) {
                        return preprocessCollection(items, function(_item, i) {
                            return initItems[i].type === 'separator';
                        });
                    },
                }),
            ],
        };
    };

    const forMenu = function(presets) {
        if (presets === 'color') {
            return 'tox-swatches';
        }
        return 'tox-menu';
    };
    const classes = function(presets) {
        return {
            backgroundMenu: 'tox-background-menu',
            selectedMenu: 'tox-selected-menu',
            selectedItem: 'tox-collection__item--active',
            hasIcons: 'tox-menu--has-icons',
            menu: forMenu(presets),
            tieredMenu: 'tox-tiered-menu',
        };
    };

    const markers$1 = function(presets) {
        const menuClasses = classes(presets);
        return {
            backgroundMenu: menuClasses.backgroundMenu,
            selectedMenu: menuClasses.selectedMenu,
            menu: menuClasses.menu,
            selectedItem: menuClasses.selectedItem,
            item: classForPreset(presets),
        };
    };
    const dom$1 = function(hasIcons, columns, presets) {
        const menuClasses = classes(presets);
        return {
            tag: 'div',
            classes: flatten([
                [menuClasses.menu, `tox-menu-${columns}-column`],
                hasIcons ? [menuClasses.hasIcons] : [],
            ]),
        };
    };
    const components$1 = [Menu.parts().items({})];
    const part = function(hasIcons, columns, presets) {
        const menuClasses = classes(presets);
        const d = {
            tag: 'div',
            classes: flatten([[menuClasses.tieredMenu]]),
        };
        return {
            dom: d,
            markers: markers$1(presets),
        };
    };

    const hasIcon = function(item) {
        return (
            item.icon !== undefined ||
            item.type === 'togglemenuitem' ||
            item.type === 'choicemenuitem'
        );
    };
    const menuHasIcons = function(xs) {
        return exists(xs, hasIcon);
    };
    const handleError = function(error) {
        domGlobals.console.error(formatError(error));
        domGlobals.console.log(error);
        return Option.none();
    };
    const createHorizontalPartialMenuWithAlloyItems = function(
        value,
        _hasIcons,
        items,
        _columns,
        _presets,
    ) {
        const structure = forHorizontalCollection(items);
        return {
            value,
            dom: structure.dom,
            components: structure.components,
            items,
        };
    };
    const createPartialMenuWithAlloyItems = function(
        value,
        hasIcons,
        items,
        columns,
        presets,
    ) {
        if (presets === 'color') {
            var structure = forSwatch(columns);
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items,
            };
        }
        if (presets === 'normal' && columns === 'auto') {
            var structure = forCollection(columns, items);
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items,
            };
        }
        if (presets === 'normal' && columns === 1) {
            var structure = forCollection(1, items);
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items,
            };
        }
        if (presets === 'normal') {
            var structure = forCollection(columns, items);
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items,
            };
        }
        if (presets === 'listpreview' && columns !== 'auto') {
            var structure = forToolbar(columns);
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items,
            };
        }
        return {
            value,
            dom: dom$1(hasIcons, columns, presets),
            components: components$1,
            items,
        };
    };

    const createPartialChoiceMenu = function(
        value,
        items,
        onItemValueHandler,
        columns,
        presets,
        itemResponse,
        select,
        providersBackstage,
    ) {
        const hasIcons = menuHasIcons(items);
        const presetItemTypes = presets !== 'color' ? 'normal' : 'color';
        const alloyItems = createChoiceItems(
            items,
            onItemValueHandler,
            columns,
            presetItemTypes,
            itemResponse,
            select,
            providersBackstage,
        );
        return createPartialMenuWithAlloyItems(
            value,
            hasIcons,
            alloyItems,
            columns,
            presets,
        );
    };
    var createChoiceItems = function(
        items,
        onItemValueHandler,
        columns,
        itemPresets,
        itemResponse,
        select,
        providersBackstage,
    ) {
        return cat(
            map(items, function(item) {
                if (item.type === 'choiceitem') {
                    return createChoiceMenuItem(item).fold(
                        handleError,
                        function(d) {
                            return Option.some(
                                renderChoiceItem(
                                    d,
                                    columns === 1,
                                    itemPresets,
                                    onItemValueHandler,
                                    select(item.value),
                                    itemResponse,
                                    providersBackstage,
                                ),
                            );
                        },
                    );
                }
                return Option.none();
            }),
        );
    };

    const deriveMenuMovement = function(columns, presets) {
        const menuMarkers = markers$1(presets);
        if (columns === 1) {
            return {
                mode: 'menu',
                moveOnTab: true,
            };
        }
        if (columns === 'auto') {
            return {
                mode: 'grid',
                selector: `.${menuMarkers.item}`,
                initSize: {
                    numColumns: 1,
                    numRows: 1,
                },
            };
        }
        const rowClass =
            presets === 'color' ? 'tox-swatches__row' : 'tox-collection__group';
        return {
            mode: 'matrix',
            rowSelector: `.${rowClass}`,
        };
    };
    const deriveCollectionMovement = function(columns, presets) {
        if (columns === 1) {
            return {
                mode: 'menu',
                moveOnTab: false,
                selector: '.tox-collection__item',
            };
        }
        if (columns === 'auto') {
            return {
                mode: 'flatgrid',
                selector: '.' + 'tox-collection__item',
                initSize: {
                    numColumns: 1,
                    numRows: 1,
                },
            };
        }
        return {
            mode: 'matrix',
            selectors: {
                row:
                    presets === 'color'
                        ? '.tox-swatches__row'
                        : '.tox-collection__group',
                cell:
                    presets === 'color'
                        ? `.${colorClass}`
                        : `.${selectableClass}`,
            },
        };
    };

    function renderColorSwatchItem(spec, backstage) {
        const items = ColorSwatch.getColors(
            backstage.colorinput.getColors(),
            backstage.colorinput.hasCustomColors(),
        );
        const columns = backstage.colorinput.getColorCols();
        const presets = 'color';
        const menuSpec = createPartialChoiceMenu(
            generate$1('menu-value'),
            items,
            function(value) {
                spec.onAction({ value });
            },
            columns,
            presets,
            ItemResponse$1.CLOSE_ON_EXECUTE,
            function() {
                return false;
            },
            backstage.shared.providers,
        );
        const widgetSpec = deepMerge({
            ...menuSpec,
            markers: markers$1(presets),
            movement: deriveMenuMovement(columns, presets),
        });
        return {
            type: 'widget',
            data: { value: generate$1('widget-id') },
            dom: {
                tag: 'div',
                classes: ['tox-fancymenuitem'],
            },
            autofocus: true,
            components: [parts$2().widget(Menu.sketch(widgetSpec))],
        };
    }

    const fancyMenuItems = {
        inserttable: renderInsertTableMenuItem,
        colorswatch: renderColorSwatchItem,
    };
    const valueOpt = function(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key)
            ? Option.some(obj[key])
            : Option.none();
    };
    const renderFancyMenuItem = function(spec, backstage) {
        return valueOpt(fancyMenuItems, spec.fancytype).map(function(render) {
            return render(spec, backstage);
        });
    };

    const renderNormalItem = function(
        spec,
        itemResponse,
        providersBackstage,
        renderIcons,
    ) {
        if (renderIcons === void 0) {
            renderIcons = true;
        }
        const getApi = function(component) {
            return {
                isDisabled() {
                    return Disabling.isDisabled(component);
                },
                setDisabled(state) {
                    return Disabling.set(component, state);
                },
            };
        };
        const structure = renderItemStructure(
            {
                presets: 'normal',
                iconContent: spec.icon,
                textContent: spec.text,
                htmlContent: Option.none(),
                ariaLabel: spec.text,
                caret: Option.none(),
                checkMark: Option.none(),
                shortcutContent: spec.shortcut,
            },
            providersBackstage,
            renderIcons,
        );
        return renderCommonItem(
            {
                data: buildData(spec),
                getApi,
                disabled: spec.disabled,
                onAction: spec.onAction,
                onSetup: spec.onSetup,
                triggersSubmenu: false,
                itemBehaviours: [],
            },
            structure,
            itemResponse,
        );
    };

    const renderNestedItem = function(
        spec,
        itemResponse,
        providersBackstage,
        renderIcons,
        downwardsCaret,
    ) {
        if (renderIcons === void 0) {
            renderIcons = true;
        }
        if (downwardsCaret === void 0) {
            downwardsCaret = false;
        }
        const caret = downwardsCaret
            ? renderDownwardsCaret(providersBackstage.icons)
            : renderSubmenuCaret(providersBackstage.icons);
        const getApi = function(component) {
            return {
                isDisabled() {
                    return Disabling.isDisabled(component);
                },
                setDisabled(state) {
                    return Disabling.set(component, state);
                },
            };
        };
        const structure = renderItemStructure(
            {
                presets: 'normal',
                iconContent: spec.icon,
                textContent: spec.text,
                htmlContent: Option.none(),
                ariaLabel: spec.text,
                caret: Option.some(caret),
                checkMark: Option.none(),
                shortcutContent: spec.shortcut,
            },
            providersBackstage,
            renderIcons,
        );
        return renderCommonItem(
            {
                data: buildData(spec),
                getApi,
                disabled: spec.disabled,
                onAction: noop,
                onSetup: spec.onSetup,
                triggersSubmenu: true,
                itemBehaviours: [],
            },
            structure,
            itemResponse,
        );
    };

    const renderSeparatorItem = function(spec) {
        const innerHtml = spec.text.fold(
            function() {
                return {};
            },
            function(text) {
                return { innerHtml: text };
            },
        );
        return {
            type: 'separator',
            dom: {
                tag: 'div',
                classes: [selectableClass, groupHeadingClass],
                ...innerHtml,
            },
            components: [],
        };
    };

    const renderToggleMenuItem = function(
        spec,
        itemResponse,
        providersBackstage,
    ) {
        const getApi = function(component) {
            return {
                setActive(state) {
                    Toggling.set(component, state);
                },
                isActive() {
                    return Toggling.isOn(component);
                },
                isDisabled() {
                    return Disabling.isDisabled(component);
                },
                setDisabled(state) {
                    return Disabling.set(component, state);
                },
            };
        };
        const structure = renderItemStructure(
            {
                iconContent: Option.none(),
                textContent: spec.text,
                htmlContent: Option.none(),
                ariaLabel: spec.text,
                checkMark: Option.some(
                    renderCheckmark(providersBackstage.icons),
                ),
                caret: Option.none(),
                shortcutContent: spec.shortcut,
                presets: 'normal',
                meta: spec.meta,
            },
            providersBackstage,
            true,
        );
        return deepMerge(
            renderCommonItem(
                {
                    data: buildData(spec),
                    disabled: spec.disabled,
                    getApi,
                    onAction: spec.onAction,
                    onSetup: spec.onSetup,
                    triggersSubmenu: false,
                    itemBehaviours: [],
                },
                structure,
                itemResponse,
            ),
            {
                toggling: {
                    toggleClass: tickedClass,
                    toggleOnExecute: false,
                    selected: spec.active,
                },
            },
        );
    };

    const autocomplete = renderAutocompleteItem;
    const separator = renderSeparatorItem;
    const normal = renderNormalItem;
    const nested = renderNestedItem;
    const toggle$1 = renderToggleMenuItem;
    const fancy = renderFancyMenuItem;

    let FocusMode;
    (function(FocusMode) {
        FocusMode[(FocusMode.ContentFocus = 0)] = 'ContentFocus';
        FocusMode[(FocusMode.UiFocus = 1)] = 'UiFocus';
    })(FocusMode || (FocusMode = {}));
    const hasIcon$1 = function(item) {
        return (
            item.icon !== undefined ||
            item.type === 'togglemenuitem' ||
            item.type === 'choicemenuitem'
        );
    };
    const menuHasIcons$1 = function(xs) {
        return exists(xs, hasIcon$1);
    };
    const createMenuItemFromBridge = function(
        item,
        itemResponse,
        backstage,
        menuHasIcons,
        isHorizontalMenu,
    ) {
        const providersBackstage = backstage.shared.providers;
        const parseForHorizontalMenu = function(menuitem) {
            return !isHorizontalMenu
                ? menuitem
                : {
                      ...menuitem,
                      shortcut: Option.none(),
                      icon: menuitem.text.isSome()
                          ? Option.none()
                          : menuitem.icon,
                  };
        };
        switch (item.type) {
            case 'menuitem':
                return createMenuItem(item).fold(handleError, function(d) {
                    return Option.some(
                        normal(
                            parseForHorizontalMenu(d),
                            itemResponse,
                            providersBackstage,
                            menuHasIcons,
                        ),
                    );
                });
            case 'nestedmenuitem':
                return createNestedMenuItem(item).fold(handleError, function(
                    d,
                ) {
                    return Option.some(
                        nested(
                            parseForHorizontalMenu(d),
                            itemResponse,
                            providersBackstage,
                            menuHasIcons,
                            isHorizontalMenu,
                        ),
                    );
                });
            case 'togglemenuitem':
                return createToggleMenuItem(item).fold(handleError, function(
                    d,
                ) {
                    return Option.some(
                        toggle$1(
                            parseForHorizontalMenu(d),
                            itemResponse,
                            providersBackstage,
                        ),
                    );
                });
            case 'separator':
                return createSeparatorMenuItem(item).fold(handleError, function(
                    d,
                ) {
                    return Option.some(separator(d));
                });
            case 'fancymenuitem':
                return createFancyMenuItem(item).fold(handleError, function(d) {
                    return fancy(parseForHorizontalMenu(d), backstage);
                });
            default: {
                domGlobals.console.error('Unknown item in general menu', item);
                return Option.none();
            }
        }
    };
    const createAutocompleteItems = function(
        items,
        matchText,
        onItemValueHandler,
        columns,
        itemResponse,
        sharedBackstage,
    ) {
        const renderText = columns === 1;
        const renderIcons = !renderText || menuHasIcons$1(items);
        return cat(
            map(items, function(item) {
                if (item.type === 'separator') {
                    return createSeparatorItem(item).fold(handleError, function(
                        d,
                    ) {
                        return Option.some(separator(d));
                    });
                }
                return createAutocompleterItem(item).fold(handleError, function(
                    d,
                ) {
                    return Option.some(
                        autocomplete(
                            d,
                            matchText,
                            renderText,
                            'normal',
                            onItemValueHandler,
                            itemResponse,
                            sharedBackstage,
                            renderIcons,
                        ),
                    );
                });
            }),
        );
    };
    const createPartialMenu = function(
        value,
        items,
        itemResponse,
        backstage,
        isHorizontalMenu,
    ) {
        const hasIcons = menuHasIcons$1(items);
        const alloyItems = cat(
            map(items, function(item) {
                const itemHasIcon = function(i) {
                    return isHorizontalMenu
                        ? !i.hasOwnProperty('text')
                        : hasIcons;
                };
                const createItem = function(i) {
                    return createMenuItemFromBridge(
                        i,
                        itemResponse,
                        backstage,
                        itemHasIcon(i),
                        isHorizontalMenu,
                    );
                };
                if (
                    item.type === 'nestedmenuitem' &&
                    item.getSubmenuItems().length <= 0
                ) {
                    return createItem(merge(item, { disabled: true }));
                }
                return createItem(item);
            }),
        );
        const createPartial = isHorizontalMenu
            ? createHorizontalPartialMenuWithAlloyItems
            : createPartialMenuWithAlloyItems;
        return createPartial(value, hasIcons, alloyItems, 1, 'normal');
    };
    const createTieredDataFrom = function(partialMenu) {
        return tieredMenu.singleData(partialMenu.value, partialMenu);
    };
    const createMenuFrom = function(partialMenu, columns, focusMode, presets) {
        const focusManager =
            focusMode === FocusMode.ContentFocus ? highlights() : dom();
        const movement = deriveMenuMovement(columns, presets);
        const menuMarkers = markers$1(presets);
        return {
            dom: partialMenu.dom,
            components: partialMenu.components,
            items: partialMenu.items,
            value: partialMenu.value,
            markers: {
                selectedItem: menuMarkers.selectedItem,
                item: menuMarkers.item,
            },
            movement,
            fakeFocus: focusMode === FocusMode.ContentFocus,
            focusManager,
            menuBehaviours: SimpleBehaviours.unnamedEvents(
                columns !== 'auto'
                    ? []
                    : [
                          runOnAttached(function(comp, se) {
                              detectSize(comp, 4, menuMarkers.item).each(
                                  function(_a) {
                                      const { numColumns } = _a;
                                      const { numRows } = _a;
                                      Keying.setGridSize(
                                          comp,
                                          numRows,
                                          numColumns,
                                      );
                                  },
                              );
                          }),
                      ],
            ),
        };
    };

    const register$2 = function(editor, sharedBackstage) {
        const activeAutocompleter = Cell(Option.none());
        const processingAction = Cell(false);
        const autocompleter = build$1(
            InlineView.sketch({
                dom: {
                    tag: 'div',
                    classes: ['tox-autocompleter'],
                },
                components: [],
                fireDismissalEventInstead: {},
                inlineBehaviours: derive$1([
                    config('dismissAutocompleter', [
                        run(dismissRequested(), function() {
                            return cancelIfNecessary();
                        }),
                    ]),
                ]),
                lazySink: sharedBackstage.getSink,
            }),
        );
        const isMenuOpen = function() {
            return InlineView.isOpen(autocompleter);
        };
        const isActive = function() {
            return activeAutocompleter.get().isSome();
        };
        const hideIfNecessary = function() {
            if (isActive()) {
                InlineView.hide(autocompleter);
            }
        };
        var cancelIfNecessary = function() {
            if (isActive()) {
                const lastElement = activeAutocompleter.get().map(function(ac) {
                    return ac.element;
                });
                detect$4(
                    lastElement.getOr(
                        Element.fromDom(editor.selection.getNode()),
                    ),
                ).each(unwrap);
                hideIfNecessary();
                activeAutocompleter.set(Option.none());
                processingAction.set(false);
            }
        };
        const getAutocompleters = cached(function() {
            return register(editor);
        });
        const getCombinedItems = function(triggerChar, matches) {
            const columns = findMap(matches, function(m) {
                return Option.from(m.columns);
            }).getOr(1);
            return bind(matches, function(match) {
                const choices = match.items;
                return createAutocompleteItems(
                    choices,
                    match.matchText,
                    function(itemValue, itemMeta) {
                        const nr = editor.selection.getRng();
                        getContext(editor.dom, nr, triggerChar).fold(
                            function() {
                                return domGlobals.console.error(
                                    'Lost context. Cursor probably moved',
                                );
                            },
                            function(_a) {
                                const { range } = _a;
                                const autocompleterApi = {
                                    hide() {
                                        cancelIfNecessary();
                                    },
                                    reload(fetchOptions) {
                                        hideIfNecessary();
                                        load(fetchOptions);
                                    },
                                };
                                processingAction.set(true);
                                match.onAction(
                                    autocompleterApi,
                                    range,
                                    itemValue,
                                    itemMeta,
                                );
                                processingAction.set(false);
                            },
                        );
                    },
                    columns,
                    ItemResponse$1.BUBBLE_TO_SANDBOX,
                    sharedBackstage,
                );
            });
        };
        const commenceIfNecessary = function(context) {
            if (!isActive()) {
                const wrapper = create$4(editor, context.range);
                activeAutocompleter.set(
                    Option.some({
                        triggerChar: context.triggerChar,
                        element: wrapper,
                        matchLength: context.text.length,
                    }),
                );
                processingAction.set(false);
            }
        };
        const display = function(ac, context, lookupData, items) {
            ac.matchLength = context.text.length;
            const columns = findMap(lookupData, function(ld) {
                return Option.from(ld.columns);
            }).getOr(1);
            InlineView.showAt(
                autocompleter,
                {
                    anchor: 'node',
                    root: Element.fromDom(editor.getBody()),
                    node: Option.from(ac.element),
                },
                Menu.sketch(
                    createMenuFrom(
                        createPartialMenuWithAlloyItems(
                            'autocompleter-value',
                            true,
                            items,
                            columns,
                            'normal',
                        ),
                        columns,
                        FocusMode.ContentFocus,
                        'normal',
                    ),
                ),
            );
            InlineView.getContent(autocompleter).each(
                Highlighting.highlightFirst,
            );
        };
        const doLookup = function(fetchOptions) {
            return activeAutocompleter
                .get()
                .map(function(ac) {
                    return getContext(
                        editor.dom,
                        editor.selection.getRng(),
                        ac.triggerChar,
                    ).bind(function(newContext) {
                        return lookupWithContext(
                            editor,
                            getAutocompleters,
                            newContext,
                            fetchOptions,
                        );
                    });
                })
                .getOrThunk(function() {
                    return lookup(editor, getAutocompleters);
                });
        };
        var load = function(fetchOptions) {
            doLookup(fetchOptions).fold(cancelIfNecessary, function(
                lookupInfo,
            ) {
                commenceIfNecessary(lookupInfo.context);
                lookupInfo.lookupData.then(function(lookupData) {
                    activeAutocompleter.get().map(function(ac) {
                        const { context } = lookupInfo;
                        if (ac.triggerChar === context.triggerChar) {
                            const combinedItems = getCombinedItems(
                                context.triggerChar,
                                lookupData,
                            );
                            if (combinedItems.length > 0) {
                                display(ac, context, lookupData, combinedItems);
                            } else if (
                                context.text.length - ac.matchLength >=
                                10
                            ) {
                                cancelIfNecessary();
                            } else {
                                hideIfNecessary();
                            }
                        }
                    });
                });
            });
        };
        const onKeypress = last$2(function(e) {
            if (e.which === 27) {
                return;
            }
            load();
        }, 50);
        const autocompleterUiApi = {
            onKeypress,
            cancelIfNecessary,
            isMenuOpen,
            isActive,
            isProcessingAction: processingAction.get,
            getView() {
                return InlineView.getContent(autocompleter);
            },
        };
        AutocompleterEditorEvents.setup(autocompleterUiApi, editor);
    };
    const Autocompleter = { register: register$2 };

    const mkEvent = function(target, x, y, stop, prevent, kill, raw) {
        return {
            target: constant(target),
            x: constant(x),
            y: constant(y),
            stop,
            prevent,
            kill,
            raw: constant(raw),
        };
    };
    const fromRawEvent = function(rawEvent) {
        const target = Element.fromDom(rawEvent.target);
        const stop = function() {
            rawEvent.stopPropagation();
        };
        const prevent = function() {
            rawEvent.preventDefault();
        };
        const kill = compose(prevent, stop);
        return mkEvent(
            target,
            rawEvent.clientX,
            rawEvent.clientY,
            stop,
            prevent,
            kill,
            rawEvent,
        );
    };
    const handle = function(filter, handler) {
        return function(rawEvent) {
            if (!filter(rawEvent)) {
                return;
            }
            handler(fromRawEvent(rawEvent));
        };
    };
    const binder = function(element, event, filter, handler, useCapture) {
        const wrapped = handle(filter, handler);
        element.dom().addEventListener(event, wrapped, useCapture);
        return { unbind: curry(unbind, element, event, wrapped, useCapture) };
    };
    const bind$2 = function(element, event, filter, handler) {
        return binder(element, event, filter, handler, false);
    };
    const capture = function(element, event, filter, handler) {
        return binder(element, event, filter, handler, true);
    };
    var unbind = function(element, event, handler, useCapture) {
        element.dom().removeEventListener(event, handler, useCapture);
    };

    const filter$1 = constant(true);
    const bind$3 = function(element, event, handler) {
        return bind$2(element, event, filter$1, handler);
    };
    const capture$1 = function(element, event, handler) {
        return capture(element, event, filter$1, handler);
    };
    const fromRawEvent$1 = fromRawEvent;

    const closest$4 = function(scope, selector, isRoot) {
        return closest$3(scope, selector, isRoot).isSome();
    };

    function DelayedFunction(fun, delay) {
        let ref = null;
        const schedule = function() {
            const args = [];
            for (let _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            ref = domGlobals.setTimeout(function() {
                fun.apply(null, args);
                ref = null;
            }, delay);
        };
        const cancel = function() {
            if (ref !== null) {
                domGlobals.clearTimeout(ref);
                ref = null;
            }
        };
        return {
            cancel,
            schedule,
        };
    }

    const SIGNIFICANT_MOVE = 5;
    const LONGPRESS_DELAY = 400;
    const getTouch = function(event) {
        const raw = event.raw();
        if (raw.touches === undefined || raw.touches.length !== 1) {
            return Option.none();
        }
        return Option.some(raw.touches[0]);
    };
    const isFarEnough = function(touch, data) {
        const distX = Math.abs(touch.clientX - data.x());
        const distY = Math.abs(touch.clientY - data.y());
        return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
    };
    const monitor = function(settings) {
        const startData = Cell(Option.none());
        const longpressFired = Cell(false);
        const longpress$1 = DelayedFunction(function(event) {
            settings.triggerEvent(longpress(), event);
            longpressFired.set(true);
        }, LONGPRESS_DELAY);
        const handleTouchstart = function(event) {
            getTouch(event).each(function(touch) {
                longpress$1.cancel();
                const data = {
                    x: constant(touch.clientX),
                    y: constant(touch.clientY),
                    target: event.target,
                };
                longpress$1.schedule(event);
                longpressFired.set(false);
                startData.set(Option.some(data));
            });
            return Option.none();
        };
        const handleTouchmove = function(event) {
            longpress$1.cancel();
            getTouch(event).each(function(touch) {
                startData.get().each(function(data) {
                    if (isFarEnough(touch, data)) {
                        startData.set(Option.none());
                    }
                });
            });
            return Option.none();
        };
        const handleTouchend = function(event) {
            longpress$1.cancel();
            const isSame = function(data) {
                return eq(data.target(), event.target());
            };
            return startData
                .get()
                .filter(isSame)
                .map(function(data) {
                    if (longpressFired.get()) {
                        event.prevent();
                        return false;
                    }
                    return settings.triggerEvent(tap(), event);
                });
        };
        const handlers = wrapAll$1([
            {
                key: touchstart(),
                value: handleTouchstart,
            },
            {
                key: touchmove(),
                value: handleTouchmove,
            },
            {
                key: touchend(),
                value: handleTouchend,
            },
        ]);
        const fireIfReady = function(event, type) {
            return readOptFrom$1(handlers, type).bind(function(handler) {
                return handler(event);
            });
        };
        return { fireIfReady };
    };

    const isDangerous = function(event) {
        const keyEv = event.raw();
        return (
            keyEv.which === BACKSPACE()[0] &&
            !contains(['input', 'textarea'], name(event.target())) &&
            !closest$4(event.target(), '[contenteditable="true"]')
        );
    };
    const isFirefox = detect$3().browser.isFirefox();
    const settingsSchema = objOfOnly([
        strictFunction('triggerEvent'),
        defaulted$1('stopBackspace', true),
    ]);
    const bindFocus = function(container, handler) {
        if (isFirefox) {
            return capture$1(container, 'focus', handler);
        }
        return bind$3(container, 'focusin', handler);
    };
    const bindBlur = function(container, handler) {
        if (isFirefox) {
            return capture$1(container, 'blur', handler);
        }
        return bind$3(container, 'focusout', handler);
    };
    const setup$1 = function(container, rawSettings) {
        const settings = asRawOrDie(
            'Getting GUI events settings',
            settingsSchema,
            rawSettings,
        );
        const pointerEvents = [
            'touchstart',
            'touchmove',
            'touchend',
            'touchcancel',
            'gesturestart',
            'mousedown',
            'mouseup',
            'mouseover',
            'mousemove',
            'mouseout',
            'click',
        ];
        const tapEvent = monitor(settings);
        const simpleEvents = map(
            pointerEvents.concat([
                'selectstart',
                'input',
                'contextmenu',
                'change',
                'transitionend',
                'drag',
                'dragstart',
                'dragend',
                'dragenter',
                'dragleave',
                'dragover',
                'drop',
                'keyup',
            ]),
            function(type) {
                return bind$3(container, type, function(event) {
                    tapEvent
                        .fireIfReady(event, type)
                        .each(function(tapStopped) {
                            if (tapStopped) {
                                event.kill();
                            }
                        });
                    const stopped = settings.triggerEvent(type, event);
                    if (stopped) {
                        event.kill();
                    }
                });
            },
        );
        const pasteTimeout = Cell(Option.none());
        const onPaste = bind$3(container, 'paste', function(event) {
            tapEvent.fireIfReady(event, 'paste').each(function(tapStopped) {
                if (tapStopped) {
                    event.kill();
                }
            });
            const stopped = settings.triggerEvent('paste', event);
            if (stopped) {
                event.kill();
            }
            pasteTimeout.set(
                Option.some(
                    domGlobals.setTimeout(function() {
                        settings.triggerEvent(postPaste(), event);
                    }, 0),
                ),
            );
        });
        const onKeydown = bind$3(container, 'keydown', function(event) {
            const stopped = settings.triggerEvent('keydown', event);
            if (stopped) {
                event.kill();
            } else if (settings.stopBackspace === true && isDangerous(event)) {
                event.prevent();
            }
        });
        const onFocusIn = bindFocus(container, function(event) {
            const stopped = settings.triggerEvent('focusin', event);
            if (stopped) {
                event.kill();
            }
        });
        const focusoutTimeout = Cell(Option.none());
        const onFocusOut = bindBlur(container, function(event) {
            const stopped = settings.triggerEvent('focusout', event);
            if (stopped) {
                event.kill();
            }
            focusoutTimeout.set(
                Option.some(
                    domGlobals.setTimeout(function() {
                        settings.triggerEvent(postBlur(), event);
                    }, 0),
                ),
            );
        });
        const unbind = function() {
            each(simpleEvents, function(e) {
                e.unbind();
            });
            onKeydown.unbind();
            onFocusIn.unbind();
            onFocusOut.unbind();
            onPaste.unbind();
            pasteTimeout.get().each(domGlobals.clearTimeout);
            focusoutTimeout.get().each(domGlobals.clearTimeout);
        };
        return { unbind };
    };

    const derive$2 = function(rawEvent, rawTarget) {
        const source = readOptFrom$1(rawEvent, 'target')
            .map(function(getTarget) {
                return getTarget();
            })
            .getOr(rawTarget);
        return Cell(source);
    };

    const fromSource = function(event, source) {
        const stopper = Cell(false);
        const cutter = Cell(false);
        const stop = function() {
            stopper.set(true);
        };
        const cut = function() {
            cutter.set(true);
        };
        return {
            stop,
            cut,
            isStopped: stopper.get,
            isCut: cutter.get,
            event: constant(event),
            setSource: source.set,
            getSource: source.get,
        };
    };
    const fromExternal = function(event) {
        const stopper = Cell(false);
        const stop = function() {
            stopper.set(true);
        };
        return {
            stop,
            cut: noop,
            isStopped: stopper.get,
            isCut: constant(false),
            event: constant(event),
            setSource: die('Cannot set source of a broadcasted event'),
            getSource: die('Cannot get source of a broadcasted event'),
        };
    };

    const adt$b = Adt.generate([
        { stopped: [] },
        { resume: ['element'] },
        { complete: [] },
    ]);
    const doTriggerHandler = function(
        lookup,
        eventType,
        rawEvent,
        target,
        source,
        logger,
    ) {
        const handler = lookup(eventType, target);
        const simulatedEvent = fromSource(rawEvent, source);
        return handler.fold(
            function() {
                logger.logEventNoHandlers(eventType, target);
                return adt$b.complete();
            },
            function(handlerInfo) {
                const descHandler = handlerInfo.descHandler();
                const eventHandler = getCurried(descHandler);
                eventHandler(simulatedEvent);
                if (simulatedEvent.isStopped()) {
                    logger.logEventStopped(
                        eventType,
                        handlerInfo.element(),
                        descHandler.purpose(),
                    );
                    return adt$b.stopped();
                }
                if (simulatedEvent.isCut()) {
                    logger.logEventCut(
                        eventType,
                        handlerInfo.element(),
                        descHandler.purpose(),
                    );
                    return adt$b.complete();
                }
                return parent(handlerInfo.element()).fold(
                    function() {
                        logger.logNoParent(
                            eventType,
                            handlerInfo.element(),
                            descHandler.purpose(),
                        );
                        return adt$b.complete();
                    },
                    function(parent) {
                        logger.logEventResponse(
                            eventType,
                            handlerInfo.element(),
                            descHandler.purpose(),
                        );
                        return adt$b.resume(parent);
                    },
                );
            },
        );
    };
    var doTriggerOnUntilStopped = function(
        lookup,
        eventType,
        rawEvent,
        rawTarget,
        source,
        logger,
    ) {
        return doTriggerHandler(
            lookup,
            eventType,
            rawEvent,
            rawTarget,
            source,
            logger,
        ).fold(
            function() {
                return true;
            },
            function(parent) {
                return doTriggerOnUntilStopped(
                    lookup,
                    eventType,
                    rawEvent,
                    parent,
                    source,
                    logger,
                );
            },
            function() {
                return false;
            },
        );
    };
    const triggerHandler = function(
        lookup,
        eventType,
        rawEvent,
        target,
        logger,
    ) {
        const source = derive$2(rawEvent, target);
        return doTriggerHandler(
            lookup,
            eventType,
            rawEvent,
            target,
            source,
            logger,
        );
    };
    const broadcast = function(listeners, rawEvent, logger) {
        const simulatedEvent = fromExternal(rawEvent);
        each(listeners, function(listener) {
            const descHandler = listener.descHandler();
            const handler = getCurried(descHandler);
            handler(simulatedEvent);
        });
        return simulatedEvent.isStopped();
    };
    const triggerUntilStopped = function(lookup, eventType, rawEvent, logger) {
        const rawTarget = rawEvent.target();
        return triggerOnUntilStopped(
            lookup,
            eventType,
            rawEvent,
            rawTarget,
            logger,
        );
    };
    var triggerOnUntilStopped = function(
        lookup,
        eventType,
        rawEvent,
        rawTarget,
        logger,
    ) {
        const source = derive$2(rawEvent, rawTarget);
        return doTriggerOnUntilStopped(
            lookup,
            eventType,
            rawEvent,
            rawTarget,
            source,
            logger,
        );
    };

    const eventHandler = Immutable('element', 'descHandler');
    const broadcastHandler = function(id, handler) {
        return {
            id: constant(id),
            descHandler: constant(handler),
        };
    };
    function EventRegistry() {
        const registry = {};
        const registerId = function(extraArgs, id, events) {
            each$1(events, function(v, k) {
                const handlers = registry[k] !== undefined ? registry[k] : {};
                handlers[id] = curryArgs(v, extraArgs);
                registry[k] = handlers;
            });
        };
        const findHandler = function(handlers, elem) {
            return read$1(elem).fold(
                function() {
                    return Option.none();
                },
                function(id) {
                    const reader = readOpt$1(id);
                    return handlers.bind(reader).map(function(descHandler) {
                        return eventHandler(elem, descHandler);
                    });
                },
            );
        };
        const filterByType = function(type) {
            return readOptFrom$1(registry, type)
                .map(function(handlers) {
                    return mapToArray(handlers, function(f, id) {
                        return broadcastHandler(id, f);
                    });
                })
                .getOr([]);
        };
        const find = function(isAboveRoot, type, target) {
            const readType = readOpt$1(type);
            const handlers = readType(registry);
            return closest$1(
                target,
                function(elem) {
                    return findHandler(handlers, elem);
                },
                isAboveRoot,
            );
        };
        const unregisterId = function(id) {
            each$1(registry, function(handlersById, eventName) {
                if (handlersById.hasOwnProperty(id)) {
                    delete handlersById[id];
                }
            });
        };
        return {
            registerId,
            unregisterId,
            filterByType,
            find,
        };
    }

    function Registry() {
        const events = EventRegistry();
        const components = {};
        const readOrTag = function(component) {
            const elem = component.element();
            return read$1(elem).fold(
                function() {
                    return write('uid-', component.element());
                },
                function(uid) {
                    return uid;
                },
            );
        };
        const failOnDuplicate = function(component, tagId) {
            const conflict = components[tagId];
            if (conflict === component) {
                unregister(component);
            } else {
                throw new Error(
                    `The tagId "${tagId}" is already used by: ${element(
                        conflict.element(),
                    )}\nCannot use it for: ${element(component.element())}\n` +
                        `The conflicting element is${
                            inBody(conflict.element()) ? ' ' : ' not '
                        }already in the DOM`,
                );
            }
        };
        const register = function(component) {
            const tagId = readOrTag(component);
            if (hasKey$1(components, tagId)) {
                failOnDuplicate(component, tagId);
            }
            const extraArgs = [component];
            events.registerId(extraArgs, tagId, component.events());
            components[tagId] = component;
        };
        var unregister = function(component) {
            read$1(component.element()).each(function(tagId) {
                delete components[tagId];
                events.unregisterId(tagId);
            });
        };
        const filter = function(type) {
            return events.filterByType(type);
        };
        const find = function(isAboveRoot, type, target) {
            return events.find(isAboveRoot, type, target);
        };
        const getById = function(id) {
            return readOpt$1(id)(components);
        };
        return {
            find,
            filter,
            register,
            unregister,
            getById,
        };
    }

    const factory$3 = function(detail) {
        const _a = detail.dom;
        const { attributes } = _a;
        const domWithoutAttributes = __rest(_a, ['attributes']);
        return {
            uid: detail.uid,
            dom: {
                tag: 'div',
                attributes: { role: 'presentation', ...attributes },
                ...domWithoutAttributes,
            },
            components: detail.components,
            behaviours: get$b(detail.containerBehaviours),
            events: detail.events,
            domModification: detail.domModification,
            eventOrder: detail.eventOrder,
        };
    };
    const Container = single$2({
        name: 'Container',
        factory: factory$3,
        configFields: [
            defaulted$1('components', []),
            field$1('containerBehaviours', []),
            defaulted$1('events', {}),
            defaulted$1('domModification', {}),
            defaulted$1('eventOrder', {}),
        ],
    });

    const takeover = function(root) {
        const isAboveRoot = function(el) {
            return parent(root.element()).fold(
                function() {
                    return true;
                },
                function(parent) {
                    return eq(el, parent);
                },
            );
        };
        const registry = Registry();
        const lookup = function(eventName, target) {
            return registry.find(isAboveRoot, eventName, target);
        };
        const domEvents = setup$1(root.element(), {
            triggerEvent(eventName, event) {
                return monitorEvent(eventName, event.target(), function(
                    logger,
                ) {
                    return triggerUntilStopped(
                        lookup,
                        eventName,
                        event,
                        logger,
                    );
                });
            },
        });
        var systemApi = {
            debugInfo: constant('real'),
            triggerEvent(eventName, target, data) {
                monitorEvent(eventName, target, function(logger) {
                    triggerOnUntilStopped(
                        lookup,
                        eventName,
                        data,
                        target,
                        logger,
                    );
                });
            },
            triggerFocus(target, originator) {
                read$1(target).fold(
                    function() {
                        focus$1(target);
                    },
                    function(_alloyId) {
                        monitorEvent(focus(), target, function(logger) {
                            triggerHandler(
                                lookup,
                                focus(),
                                {
                                    originator: constant(originator),
                                    kill: noop,
                                    prevent: noop,
                                    target: constant(target),
                                },
                                target,
                                logger,
                            );
                        });
                    },
                );
            },
            triggerEscape(comp, simulatedEvent) {
                systemApi.triggerEvent(
                    'keydown',
                    comp.element(),
                    simulatedEvent.event(),
                );
            },
            getByUid(uid) {
                return getByUid(uid);
            },
            getByDom(elem) {
                return getByDom(elem);
            },
            build: build$1,
            addToGui(c) {
                add(c);
            },
            removeFromGui(c) {
                remove$1(c);
            },
            addToWorld(c) {
                addToWorld(c);
            },
            removeFromWorld(c) {
                removeFromWorld(c);
            },
            broadcast(message) {
                broadcast$1(message);
            },
            broadcastOn(channels, message) {
                broadcastOn(channels, message);
            },
            broadcastEvent(eventName, event) {
                broadcastEvent(eventName, event);
            },
            isConnected: constant(true),
        };
        var addToWorld = function(component) {
            component.connect(systemApi);
            if (!isText(component.element())) {
                registry.register(component);
                each(component.components(), addToWorld);
                systemApi.triggerEvent(systemInit(), component.element(), {
                    target: constant(component.element()),
                });
            }
        };
        var removeFromWorld = function(component) {
            if (!isText(component.element())) {
                each(component.components(), removeFromWorld);
                registry.unregister(component);
            }
            component.disconnect();
        };
        var add = function(component) {
            attach$1(root, component);
        };
        var remove$1 = function(component) {
            detach(component);
        };
        const destroy = function() {
            domEvents.unbind();
            remove(root.element());
        };
        const broadcastData = function(data) {
            const receivers = registry.filter(receive());
            each(receivers, function(receiver) {
                const descHandler = receiver.descHandler();
                const handler = getCurried(descHandler);
                handler(data);
            });
        };
        var broadcast$1 = function(message) {
            broadcastData({
                universal: constant(true),
                data: constant(message),
            });
        };
        var broadcastOn = function(channels, message) {
            broadcastData({
                universal: constant(false),
                channels: constant(channels),
                data: constant(message),
            });
        };
        var broadcastEvent = function(eventName, event) {
            const listeners = registry.filter(eventName);
            return broadcast(listeners, event);
        };
        var getByUid = function(uid) {
            return registry.getById(uid).fold(function() {
                return Result.error(
                    new Error(
                        `Could not find component with uid: "${uid}" in system.`,
                    ),
                );
            }, Result.value);
        };
        var getByDom = function(elem) {
            const uid = read$1(elem).getOr('not found');
            return getByUid(uid);
        };
        addToWorld(root);
        return {
            root: constant(root),
            element: root.element,
            destroy,
            add,
            remove: remove$1,
            getByUid,
            getByDom,
            addToWorld,
            removeFromWorld,
            broadcast: broadcast$1,
            broadcastOn,
            broadcastEvent,
        };
    };

    const global$9 = tinymce.util.Tools.resolve('tinymce.EditorManager');

    const getSkinUrl = function(editor) {
        const { settings } = editor;
        const { skin } = settings;
        let skinUrl = settings.skin_url;
        if (skin !== false) {
            const skinName = skin || 'oxide';
            if (skinUrl) {
                skinUrl = editor.documentBaseURI.toAbsolute(skinUrl);
            } else {
                skinUrl = `${global$9.baseURL}/skins/ui/${skinName}`;
            }
        }
        return skinUrl;
    };
    const isReadOnly = function(editor) {
        return editor.getParam('readonly', false, 'boolean');
    };
    const isSkinDisabled = function(editor) {
        return editor.getParam('skin') === false;
    };
    const getHeightSetting = function(editor) {
        return editor.getParam(
            'height',
            Math.max(editor.getElement().offsetHeight, 200),
        );
    };
    const getWidthSetting = function(editor) {
        return editor.getParam(
            'width',
            global$7.DOM.getStyle(editor.getElement(), 'width'),
        );
    };
    const getMinWidthSetting = function(editor) {
        return Option.from(editor.settings.min_width).filter(isNumber);
    };
    const getMinHeightSetting = function(editor) {
        return Option.from(editor.settings.min_height).filter(isNumber);
    };
    const getMaxWidthSetting = function(editor) {
        return Option.from(editor.getParam('max_width')).filter(isNumber);
    };
    const getMaxHeightSetting = function(editor) {
        return Option.from(editor.getParam('max_height')).filter(isNumber);
    };
    const getUserStyleFormats = function(editor) {
        return Option.from(editor.getParam('style_formats')).filter(isArray);
    };
    const isMergeStyleFormats = function(editor) {
        return editor.getParam('style_formats_merge', false, 'boolean');
    };
    const getRemovedMenuItems = function(editor) {
        return editor.getParam('removed_menuitems', '');
    };
    const isMenubarEnabled = function(editor) {
        return editor.getParam('menubar', true, 'boolean') !== false;
    };
    const isToolbarEnabled = function(editor) {
        const toolbar = editor.getParam('toolbar', true);
        const isToolbarTrue = toolbar === true;
        const isToolbarString = isString(toolbar);
        const isToolbarObjectArray = isArray(toolbar) && toolbar.length > 0;
        return (
            !isMultipleToolbars(editor) &&
            (isToolbarObjectArray || isToolbarString || isToolbarTrue)
        );
    };
    const getMultipleToolbarsSetting = function(editor) {
        const keys$1 = keys(editor.settings);
        const toolbarKeys = filter(keys$1, function(key) {
            return /^toolbar([1-9])$/.test(key);
        });
        const toolbars = map(toolbarKeys, function(key) {
            return editor.getParam(key, false, 'string');
        });
        const toolbarArray = filter(toolbars, function(toolbar) {
            return typeof toolbar === 'string';
        });
        return toolbarArray.length > 0
            ? Option.some(toolbarArray)
            : Option.none();
    };
    var isMultipleToolbars = function(editor) {
        return getMultipleToolbarsSetting(editor).fold(
            function() {
                const toolbar = editor.getParam('toolbar', [], 'string[]');
                return toolbar.length > 0;
            },
            function() {
                return true;
            },
        );
    };
    let ToolbarDrawer;
    (function(ToolbarDrawer) {
        ToolbarDrawer.default = '';
        ToolbarDrawer.floating = 'floating';
        ToolbarDrawer.sliding = 'sliding';
        ToolbarDrawer.scrolling = 'scrolling';
    })(ToolbarDrawer || (ToolbarDrawer = {}));
    const getToolbarDrawer = function(editor) {
        return editor.getParam('toolbar_drawer', '', 'string');
    };
    const fixedContainerSelector = function(editor) {
        return editor.getParam('fixed_toolbar_container', '', 'string');
    };
    const fixedContainerElement = function(editor) {
        const selector = fixedContainerSelector(editor);
        return selector.length > 0 && editor.inline
            ? descendant$1(body(), selector)
            : Option.none();
    };
    const useFixedContainer = function(editor) {
        return editor.inline && fixedContainerElement(editor).isSome();
    };
    const getUiContainer = function(editor) {
        const fixedContainer = fixedContainerElement(editor);
        return fixedContainer.getOr(body());
    };
    const isDistractionFree = function(editor) {
        return (
            editor.inline &&
            !isMenubarEnabled(editor) &&
            !isToolbarEnabled(editor) &&
            !isMultipleToolbars(editor)
        );
    };
    const isStickyToolbar = function(editor) {
        const isStickyToolbar = editor.getParam(
            'toolbar_sticky',
            false,
            'boolean',
        );
        return (
            (isStickyToolbar || editor.inline) &&
            !useFixedContainer(editor) &&
            !isDistractionFree(editor)
        );
    };
    const isDraggableModal = function(editor) {
        return editor.getParam('draggable_modal', false, 'boolean');
    };

    const SIGNIFICANT_MOVE$1 = 5;
    const LONGPRESS_DELAY$1 = 400;
    const getTouch$1 = function(event) {
        if (event.touches === undefined || event.touches.length !== 1) {
            return Option.none();
        }
        return Option.some(event.touches[0]);
    };
    const isFarEnough$1 = function(touch, data) {
        const distX = Math.abs(touch.clientX - data.x());
        const distY = Math.abs(touch.clientY - data.y());
        return distX > SIGNIFICANT_MOVE$1 || distY > SIGNIFICANT_MOVE$1;
    };
    const setup$2 = function(editor) {
        const startData = Cell(Option.none());
        const longpressFired = Cell(false);
        const debounceLongpress = last$2(function(e) {
            editor.fire('longpress', { ...e, type: 'longpress' });
            longpressFired.set(true);
        }, LONGPRESS_DELAY$1);
        editor.on(
            'touchstart',
            function(e) {
                getTouch$1(e).each(function(touch) {
                    debounceLongpress.cancel();
                    const data = {
                        x: constant(touch.clientX),
                        y: constant(touch.clientY),
                        target: constant(e.target),
                    };
                    debounceLongpress.throttle(e);
                    longpressFired.set(false);
                    startData.set(Option.some(data));
                });
            },
            true,
        );
        editor.on(
            'touchmove',
            function(e) {
                debounceLongpress.cancel();
                getTouch$1(e).each(function(touch) {
                    startData.get().each(function(data) {
                        if (isFarEnough$1(touch, data)) {
                            startData.set(Option.none());
                            longpressFired.set(false);
                            editor.fire('longpresscancel');
                        }
                    });
                });
            },
            true,
        );
        editor.on(
            'touchend touchcancel',
            function(e) {
                debounceLongpress.cancel();
                if (e.type === 'touchcancel') {
                    return;
                }
                startData
                    .get()
                    .filter(function(data) {
                        return data.target().isEqualNode(e.target);
                    })
                    .each(function() {
                        if (longpressFired.get()) {
                            e.preventDefault();
                        } else {
                            const result = editor.fire('tap', {
                                touches: e.touches,
                            });
                            if (result.isDefaultPrevented()) {
                                e.preventDefault();
                            }
                        }
                    });
            },
            true,
        );
    };
    const TouchEvents = { setup: setup$2 };

    const formChangeEvent = generate$1('form-component-change');
    const formCloseEvent = generate$1('form-close');
    const formCancelEvent = generate$1('form-cancel');
    const formActionEvent = generate$1('form-action');
    const formSubmitEvent = generate$1('form-submit');
    const formBlockEvent = generate$1('form-block');
    const formUnblockEvent = generate$1('form-unblock');
    const formTabChangeEvent = generate$1('form-tabchange');
    const formResizeEvent = generate$1('form-resize');

    const renderAlertBanner = function(spec, providersBackstage) {
        return Container.sketch({
            dom: {
                tag: 'div',
                attributes: { role: 'alert' },
                classes: [
                    'tox-notification',
                    'tox-notification--in',
                    `tox-notification--${spec.level}`,
                ],
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-notification__icon'],
                    },
                    components: [
                        Button.sketch({
                            dom: {
                                tag: 'button',
                                classes: [
                                    'tox-button',
                                    'tox-button--naked',
                                    'tox-button--icon',
                                ],
                                innerHtml: get$c(
                                    spec.icon,
                                    providersBackstage.icons,
                                ),
                                attributes: {
                                    title: providersBackstage.translate(
                                        spec.iconTooltip,
                                    ),
                                },
                            },
                            action(comp) {
                                emitWith(comp, formActionEvent, {
                                    name: 'alert-banner',
                                    value: spec.url,
                                });
                            },
                        }),
                    ],
                },
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-notification__body'],
                        innerHtml: providersBackstage.translate(spec.text),
                    },
                },
            ],
        });
    };

    const renderBar = function(spec, backstage) {
        return {
            dom: {
                tag: 'div',
                classes: ['tox-bar', 'tox-form__controls-h-stack'],
            },
            components: map(spec.items, backstage.interpreter),
        };
    };

    const schema$e = constant([
        defaulted$1('prefix', 'form-field'),
        field$1('fieldBehaviours', [Composing, Representing]),
    ]);
    const parts$3 = constant([
        optional({
            schema: [strict$1('dom')],
            name: 'label',
        }),
        optional({
            factory: {
                sketch(spec) {
                    return {
                        uid: spec.uid,
                        dom: {
                            tag: 'span',
                            styles: { display: 'none' },
                            attributes: { 'aria-hidden': 'true' },
                            innerHtml: spec.text,
                        },
                    };
                },
            },
            schema: [strict$1('text')],
            name: 'aria-descriptor',
        }),
        required({
            factory: {
                sketch(spec) {
                    const excludeFactory = exclude$1(spec, ['factory']);
                    return spec.factory.sketch(excludeFactory);
                },
            },
            schema: [strict$1('factory')],
            name: 'field',
        }),
    ]);

    const factory$4 = function(detail, components, spec, externals) {
        const behaviours = augment(detail.fieldBehaviours, [
            Composing.config({
                find(container) {
                    return getPart(container, detail, 'field');
                },
            }),
            Representing.config({
                store: {
                    mode: 'manual',
                    getValue(field) {
                        return Composing.getCurrent(field).bind(
                            Representing.getValue,
                        );
                    },
                    setValue(field, value) {
                        Composing.getCurrent(field).each(function(current) {
                            Representing.setValue(current, value);
                        });
                    },
                },
            }),
        ]);
        const events = derive([
            runOnAttached(function(component, simulatedEvent) {
                const ps = getParts(component, detail, [
                    'label',
                    'field',
                    'aria-descriptor',
                ]);
                ps.field().each(function(field) {
                    const id = generate$1(detail.prefix);
                    ps.label().each(function(label) {
                        set$1(label.element(), 'for', id);
                        set$1(field.element(), 'id', id);
                    });
                    ps['aria-descriptor']().each(function(descriptor) {
                        const descriptorId = generate$1(detail.prefix);
                        set$1(descriptor.element(), 'id', descriptorId);
                        set$1(
                            field.element(),
                            'aria-describedby',
                            descriptorId,
                        );
                    });
                });
            }),
        ]);
        const apis = {
            getField(container) {
                return getPart(container, detail, 'field');
            },
            getLabel(container) {
                return getPart(container, detail, 'label');
            },
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours,
            events,
            apis,
        };
    };
    const FormField = composite$1({
        name: 'FormField',
        configFields: schema$e(),
        partFields: parts$3(),
        factory: factory$4,
        apis: {
            getField(apis, comp) {
                return apis.getField(comp);
            },
            getLabel(apis, comp) {
                return apis.getLabel(comp);
            },
        },
    });

    const schema$f = constant([
        option('data'),
        defaulted$1('inputAttributes', {}),
        defaulted$1('inputStyles', {}),
        defaulted$1('tag', 'input'),
        defaulted$1('inputClasses', []),
        onHandler('onSetValue'),
        defaulted$1('styles', {}),
        defaulted$1('eventOrder', {}),
        field$1('inputBehaviours', [Representing, Focusing]),
        defaulted$1('selectOnFocus', true),
    ]);
    const focusBehaviours = function(detail) {
        return derive$1([
            Focusing.config({
                onFocus:
                    detail.selectOnFocus === false
                        ? noop
                        : function(component) {
                              const input = component.element();
                              const value = get$5(input);
                              input.dom().setSelectionRange(0, value.length);
                          },
            }),
        ]);
    };
    const behaviours = function(detail) {
        return {
            ...focusBehaviours(detail),
            ...augment(detail.inputBehaviours, [
                Representing.config({
                    store: {
                        mode: 'manual',
                        initialValue: detail.data.getOr(undefined),
                        getValue(input) {
                            return get$5(input.element());
                        },
                        setValue(input, data) {
                            const current = get$5(input.element());
                            if (current !== data) {
                                set$3(input.element(), data);
                            }
                        },
                    },
                    onSetValue: detail.onSetValue,
                }),
            ]),
        };
    };
    const dom$2 = function(detail) {
        return {
            tag: detail.tag,
            attributes: { type: 'text', ...detail.inputAttributes },
            styles: detail.inputStyles,
            classes: detail.inputClasses,
        };
    };

    const factory$5 = function(detail, spec) {
        return {
            uid: detail.uid,
            dom: dom$2(detail),
            components: [],
            behaviours: behaviours(detail),
            eventOrder: detail.eventOrder,
        };
    };
    const Input = single$2({
        name: 'Input',
        configFields: schema$f(),
        factory: factory$5,
    });

    const exports$1 = {};
    const module = { exports: exports$1 };
    (function(define, exports, module, require) {
        (function(f) {
            if (typeof exports === 'object' && typeof module !== 'undefined') {
                module.exports = f();
            } else if (typeof define === 'function' && define.amd) {
                define([], f);
            } else {
                let g;
                if (typeof window !== 'undefined') {
                    g = window;
                } else if (typeof global !== 'undefined') {
                    g = global;
                } else if (typeof self !== 'undefined') {
                    g = self;
                } else {
                    g = this;
                }
                g.EphoxContactWrapper = f();
            }
        })(function() {
            return (function() {
                function r(e, n, t) {
                    function o(i, f) {
                        if (!n[i]) {
                            if (!e[i]) {
                                const c =
                                    typeof require === 'function' && require;
                                if (!f && c) return c(i, !0);
                                if (u) return u(i, !0);
                                const a = new Error(
                                    `Cannot find module '${i}'`,
                                );
                                throw ((a.code = 'MODULE_NOT_FOUND'), a);
                            }
                            const p = (n[i] = { exports: {} });
                            e[i][0].call(
                                p.exports,
                                function(r) {
                                    const n = e[i][1][r];
                                    return o(n || r);
                                },
                                p,
                                p.exports,
                                r,
                                e,
                                n,
                                t,
                            );
                        }
                        return n[i].exports;
                    }
                    for (
                        var u = typeof require === 'function' && require, i = 0;
                        i < t.length;
                        i++
                    )
                        o(t[i]);
                    return o;
                }
                return r;
            })()(
                {
                    1: [
                        function(require, module, exports) {
                            const process = (module.exports = {});
                            let cachedSetTimeout;
                            let cachedClearTimeout;
                            function defaultSetTimout() {
                                throw new Error(
                                    'setTimeout has not been defined',
                                );
                            }
                            function defaultClearTimeout() {
                                throw new Error(
                                    'clearTimeout has not been defined',
                                );
                            }
                            (function() {
                                try {
                                    if (typeof setTimeout === 'function') {
                                        cachedSetTimeout = setTimeout;
                                    } else {
                                        cachedSetTimeout = defaultSetTimout;
                                    }
                                } catch (e) {
                                    cachedSetTimeout = defaultSetTimout;
                                }
                                try {
                                    if (typeof clearTimeout === 'function') {
                                        cachedClearTimeout = clearTimeout;
                                    } else {
                                        cachedClearTimeout = defaultClearTimeout;
                                    }
                                } catch (e) {
                                    cachedClearTimeout = defaultClearTimeout;
                                }
                            })();
                            function runTimeout(fun) {
                                if (cachedSetTimeout === setTimeout) {
                                    return setTimeout(fun, 0);
                                }
                                if (
                                    (cachedSetTimeout === defaultSetTimout ||
                                        !cachedSetTimeout) &&
                                    setTimeout
                                ) {
                                    cachedSetTimeout = setTimeout;
                                    return setTimeout(fun, 0);
                                }
                                try {
                                    return cachedSetTimeout(fun, 0);
                                } catch (e) {
                                    try {
                                        return cachedSetTimeout.call(
                                            null,
                                            fun,
                                            0,
                                        );
                                    } catch (e) {
                                        return cachedSetTimeout.call(
                                            this,
                                            fun,
                                            0,
                                        );
                                    }
                                }
                            }
                            function runClearTimeout(marker) {
                                if (cachedClearTimeout === clearTimeout) {
                                    return clearTimeout(marker);
                                }
                                if (
                                    (cachedClearTimeout ===
                                        defaultClearTimeout ||
                                        !cachedClearTimeout) &&
                                    clearTimeout
                                ) {
                                    cachedClearTimeout = clearTimeout;
                                    return clearTimeout(marker);
                                }
                                try {
                                    return cachedClearTimeout(marker);
                                } catch (e) {
                                    try {
                                        return cachedClearTimeout.call(
                                            null,
                                            marker,
                                        );
                                    } catch (e) {
                                        return cachedClearTimeout.call(
                                            this,
                                            marker,
                                        );
                                    }
                                }
                            }
                            let queue = [];
                            let draining = false;
                            let currentQueue;
                            let queueIndex = -1;
                            function cleanUpNextTick() {
                                if (!draining || !currentQueue) {
                                    return;
                                }
                                draining = false;
                                if (currentQueue.length) {
                                    queue = currentQueue.concat(queue);
                                } else {
                                    queueIndex = -1;
                                }
                                if (queue.length) {
                                    drainQueue();
                                }
                            }
                            function drainQueue() {
                                if (draining) {
                                    return;
                                }
                                const timeout = runTimeout(cleanUpNextTick);
                                draining = true;
                                let len = queue.length;
                                while (len) {
                                    currentQueue = queue;
                                    queue = [];
                                    while (++queueIndex < len) {
                                        if (currentQueue) {
                                            currentQueue[queueIndex].run();
                                        }
                                    }
                                    queueIndex = -1;
                                    len = queue.length;
                                }
                                currentQueue = null;
                                draining = false;
                                runClearTimeout(timeout);
                            }
                            process.nextTick = function(fun) {
                                const args = new Array(arguments.length - 1);
                                if (arguments.length > 1) {
                                    for (let i = 1; i < arguments.length; i++) {
                                        args[i - 1] = arguments[i];
                                    }
                                }
                                queue.push(new Item(fun, args));
                                if (queue.length === 1 && !draining) {
                                    runTimeout(drainQueue);
                                }
                            };
                            function Item(fun, array) {
                                this.fun = fun;
                                this.array = array;
                            }
                            Item.prototype.run = function() {
                                this.fun.apply(null, this.array);
                            };
                            process.title = 'browser';
                            process.browser = true;
                            process.env = {};
                            process.argv = [];
                            process.version = '';
                            process.versions = {};
                            function noop() {}
                            process.on = noop;
                            process.addListener = noop;
                            process.once = noop;
                            process.off = noop;
                            process.removeListener = noop;
                            process.removeAllListeners = noop;
                            process.emit = noop;
                            process.prependListener = noop;
                            process.prependOnceListener = noop;
                            process.listeners = function(name) {
                                return [];
                            };
                            process.binding = function(name) {
                                throw new Error(
                                    'process.binding is not supported',
                                );
                            };
                            process.cwd = function() {
                                return '/';
                            };
                            process.chdir = function(dir) {
                                throw new Error(
                                    'process.chdir is not supported',
                                );
                            };
                            process.umask = function() {
                                return 0;
                            };
                        },
                        {},
                    ],
                    2: [
                        function(require, module, exports) {
                            (function(setImmediate) {
                                (function(root) {
                                    const setTimeoutFunc = setTimeout;
                                    function noop() {}
                                    function bind(fn, thisArg) {
                                        return function() {
                                            fn.apply(thisArg, arguments);
                                        };
                                    }
                                    function Promise(fn) {
                                        if (typeof this !== 'object')
                                            throw new TypeError(
                                                'Promises must be constructed via new',
                                            );
                                        if (typeof fn !== 'function')
                                            throw new TypeError(
                                                'not a function',
                                            );
                                        this._state = 0;
                                        this._handled = false;
                                        this._value = undefined;
                                        this._deferreds = [];
                                        doResolve(fn, this);
                                    }
                                    function handle(self, deferred) {
                                        while (self._state === 3) {
                                            self = self._value;
                                        }
                                        if (self._state === 0) {
                                            self._deferreds.push(deferred);
                                            return;
                                        }
                                        self._handled = true;
                                        Promise._immediateFn(function() {
                                            const cb =
                                                self._state === 1
                                                    ? deferred.onFulfilled
                                                    : deferred.onRejected;
                                            if (cb === null) {
                                                (self._state === 1
                                                    ? resolve
                                                    : reject)(
                                                    deferred.promise,
                                                    self._value,
                                                );
                                                return;
                                            }
                                            let ret;
                                            try {
                                                ret = cb(self._value);
                                            } catch (e) {
                                                reject(deferred.promise, e);
                                                return;
                                            }
                                            resolve(deferred.promise, ret);
                                        });
                                    }
                                    function resolve(self, newValue) {
                                        try {
                                            if (newValue === self)
                                                throw new TypeError(
                                                    'A promise cannot be resolved with itself.',
                                                );
                                            if (
                                                newValue &&
                                                (typeof newValue === 'object' ||
                                                    typeof newValue ===
                                                        'function')
                                            ) {
                                                const { then } = newValue;
                                                if (
                                                    newValue instanceof Promise
                                                ) {
                                                    self._state = 3;
                                                    self._value = newValue;
                                                    finale(self);
                                                    return;
                                                }
                                                if (
                                                    typeof then === 'function'
                                                ) {
                                                    doResolve(
                                                        bind(then, newValue),
                                                        self,
                                                    );
                                                    return;
                                                }
                                            }
                                            self._state = 1;
                                            self._value = newValue;
                                            finale(self);
                                        } catch (e) {
                                            reject(self, e);
                                        }
                                    }
                                    function reject(self, newValue) {
                                        self._state = 2;
                                        self._value = newValue;
                                        finale(self);
                                    }
                                    function finale(self) {
                                        if (
                                            self._state === 2 &&
                                            self._deferreds.length === 0
                                        ) {
                                            Promise._immediateFn(function() {
                                                if (!self._handled) {
                                                    Promise._unhandledRejectionFn(
                                                        self._value,
                                                    );
                                                }
                                            });
                                        }
                                        for (
                                            let i = 0,
                                                len = self._deferreds.length;
                                            i < len;
                                            i++
                                        ) {
                                            handle(self, self._deferreds[i]);
                                        }
                                        self._deferreds = null;
                                    }
                                    function Handler(
                                        onFulfilled,
                                        onRejected,
                                        promise,
                                    ) {
                                        this.onFulfilled =
                                            typeof onFulfilled === 'function'
                                                ? onFulfilled
                                                : null;
                                        this.onRejected =
                                            typeof onRejected === 'function'
                                                ? onRejected
                                                : null;
                                        this.promise = promise;
                                    }
                                    function doResolve(fn, self) {
                                        let done = false;
                                        try {
                                            fn(
                                                function(value) {
                                                    if (done) return;
                                                    done = true;
                                                    resolve(self, value);
                                                },
                                                function(reason) {
                                                    if (done) return;
                                                    done = true;
                                                    reject(self, reason);
                                                },
                                            );
                                        } catch (ex) {
                                            if (done) return;
                                            done = true;
                                            reject(self, ex);
                                        }
                                    }
                                    Promise.prototype.catch = function(
                                        onRejected,
                                    ) {
                                        return this.then(null, onRejected);
                                    };
                                    Promise.prototype.then = function(
                                        onFulfilled,
                                        onRejected,
                                    ) {
                                        const prom = new this.constructor(noop);
                                        handle(
                                            this,
                                            new Handler(
                                                onFulfilled,
                                                onRejected,
                                                prom,
                                            ),
                                        );
                                        return prom;
                                    };
                                    Promise.all = function(arr) {
                                        const args = Array.prototype.slice.call(
                                            arr,
                                        );
                                        return new Promise(function(
                                            resolve,
                                            reject,
                                        ) {
                                            if (args.length === 0)
                                                return resolve([]);
                                            let remaining = args.length;
                                            function res(i, val) {
                                                try {
                                                    if (
                                                        val &&
                                                        (typeof val ===
                                                            'object' ||
                                                            typeof val ===
                                                                'function')
                                                    ) {
                                                        const { then } = val;
                                                        if (
                                                            typeof then ===
                                                            'function'
                                                        ) {
                                                            then.call(
                                                                val,
                                                                function(val) {
                                                                    res(i, val);
                                                                },
                                                                reject,
                                                            );
                                                            return;
                                                        }
                                                    }
                                                    args[i] = val;
                                                    if (--remaining === 0) {
                                                        resolve(args);
                                                    }
                                                } catch (ex) {
                                                    reject(ex);
                                                }
                                            }
                                            for (
                                                let i = 0;
                                                i < args.length;
                                                i++
                                            ) {
                                                res(i, args[i]);
                                            }
                                        });
                                    };
                                    Promise.resolve = function(value) {
                                        if (
                                            value &&
                                            typeof value === 'object' &&
                                            value.constructor === Promise
                                        ) {
                                            return value;
                                        }
                                        return new Promise(function(resolve) {
                                            resolve(value);
                                        });
                                    };
                                    Promise.reject = function(value) {
                                        return new Promise(function(
                                            resolve,
                                            reject,
                                        ) {
                                            reject(value);
                                        });
                                    };
                                    Promise.race = function(values) {
                                        return new Promise(function(
                                            resolve,
                                            reject,
                                        ) {
                                            for (
                                                let i = 0, len = values.length;
                                                i < len;
                                                i++
                                            ) {
                                                values[i].then(resolve, reject);
                                            }
                                        });
                                    };
                                    Promise._immediateFn =
                                        typeof setImmediate === 'function'
                                            ? function(fn) {
                                                  setImmediate(fn);
                                              }
                                            : function(fn) {
                                                  setTimeoutFunc(fn, 0);
                                              };
                                    Promise._unhandledRejectionFn = function _unhandledRejectionFn(
                                        err,
                                    ) {
                                        if (
                                            typeof console !== 'undefined' &&
                                            console
                                        ) {
                                            console.warn(
                                                'Possible Unhandled Promise Rejection:',
                                                err,
                                            );
                                        }
                                    };
                                    Promise._setImmediateFn = function _setImmediateFn(
                                        fn,
                                    ) {
                                        Promise._immediateFn = fn;
                                    };
                                    Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(
                                        fn,
                                    ) {
                                        Promise._unhandledRejectionFn = fn;
                                    };
                                    if (
                                        typeof module !== 'undefined' &&
                                        module.exports
                                    ) {
                                        module.exports = Promise;
                                    } else if (!root.Promise) {
                                        root.Promise = Promise;
                                    }
                                })(this);
                            }.call(this, require('timers').setImmediate));
                        },
                        { timers: 3 },
                    ],
                    3: [
                        function(require, module, exports) {
                            (function(setImmediate, clearImmediate) {
                                const {
                                    nextTick,
                                } = require('process/browser.js');
                                const { apply } = Function.prototype;
                                const { slice } = Array.prototype;
                                const immediateIds = {};
                                let nextImmediateId = 0;
                                exports.setTimeout = function() {
                                    return new Timeout(
                                        apply.call(
                                            setTimeout,
                                            window,
                                            arguments,
                                        ),
                                        clearTimeout,
                                    );
                                };
                                exports.setInterval = function() {
                                    return new Timeout(
                                        apply.call(
                                            setInterval,
                                            window,
                                            arguments,
                                        ),
                                        clearInterval,
                                    );
                                };
                                exports.clearTimeout = exports.clearInterval = function(
                                    timeout,
                                ) {
                                    timeout.close();
                                };
                                function Timeout(id, clearFn) {
                                    this._id = id;
                                    this._clearFn = clearFn;
                                }
                                Timeout.prototype.unref = Timeout.prototype.ref = function() {};
                                Timeout.prototype.close = function() {
                                    this._clearFn.call(window, this._id);
                                };
                                exports.enroll = function(item, msecs) {
                                    clearTimeout(item._idleTimeoutId);
                                    item._idleTimeout = msecs;
                                };
                                exports.unenroll = function(item) {
                                    clearTimeout(item._idleTimeoutId);
                                    item._idleTimeout = -1;
                                };
                                exports._unrefActive = exports.active = function(
                                    item,
                                ) {
                                    clearTimeout(item._idleTimeoutId);
                                    const msecs = item._idleTimeout;
                                    if (msecs >= 0) {
                                        item._idleTimeoutId = setTimeout(
                                            function onTimeout() {
                                                if (item._onTimeout)
                                                    item._onTimeout();
                                            },
                                            msecs,
                                        );
                                    }
                                };
                                exports.setImmediate =
                                    typeof setImmediate === 'function'
                                        ? setImmediate
                                        : function(fn) {
                                              const id = nextImmediateId++;
                                              const args =
                                                  arguments.length < 2
                                                      ? false
                                                      : slice.call(
                                                            arguments,
                                                            1,
                                                        );
                                              immediateIds[id] = true;
                                              nextTick(function onNextTick() {
                                                  if (immediateIds[id]) {
                                                      if (args) {
                                                          fn.apply(null, args);
                                                      } else {
                                                          fn.call(null);
                                                      }
                                                      exports.clearImmediate(
                                                          id,
                                                      );
                                                  }
                                              });
                                              return id;
                                          };
                                exports.clearImmediate =
                                    typeof clearImmediate === 'function'
                                        ? clearImmediate
                                        : function(id) {
                                              delete immediateIds[id];
                                          };
                            }.call(
                                this,
                                require('timers').setImmediate,
                                require('timers').clearImmediate,
                            ));
                        },
                        {
                            'process/browser.js': 1,
                            timers: 3,
                        },
                    ],
                    4: [
                        function(require, module, exports) {
                            const promisePolyfill = require('promise-polyfill');
                            const Global = (function() {
                                if (typeof window !== 'undefined') {
                                    return window;
                                }
                                return Function('return this;')();
                            })();
                            module.exports = {
                                boltExport: Global.Promise || promisePolyfill,
                            };
                        },
                        { 'promise-polyfill': 2 },
                    ],
                },
                {},
                [4],
            )(4);
        });
    })(undefined, exports$1, module, undefined);
    const Promise = module.exports.boltExport;

    var nu$a = function(baseFn) {
        let data = Option.none();
        let callbacks = [];
        const map = function(f) {
            return nu$a(function(nCallback) {
                get(function(data) {
                    nCallback(f(data));
                });
            });
        };
        var get = function(nCallback) {
            if (isReady()) {
                call(nCallback);
            } else {
                callbacks.push(nCallback);
            }
        };
        const set = function(x) {
            data = Option.some(x);
            run(callbacks);
            callbacks = [];
        };
        var isReady = function() {
            return data.isSome();
        };
        var run = function(cbs) {
            each(cbs, call);
        };
        var call = function(cb) {
            data.each(function(x) {
                domGlobals.setTimeout(function() {
                    cb(x);
                }, 0);
            });
        };
        baseFn(set);
        return {
            get,
            map,
            isReady,
        };
    };
    const pure$1 = function(a) {
        return nu$a(function(callback) {
            callback(a);
        });
    };
    const LazyValue = {
        nu: nu$a,
        pure: pure$1,
    };

    const errorReporter = function(err) {
        domGlobals.setTimeout(function() {
            throw err;
        }, 0);
    };
    var make$3 = function(run) {
        const get = function(callback) {
            run().then(callback, errorReporter);
        };
        const map = function(fab) {
            return make$3(function() {
                return run().then(fab);
            });
        };
        const bind = function(aFutureB) {
            return make$3(function() {
                return run().then(function(v) {
                    return aFutureB(v).toPromise();
                });
            });
        };
        const anonBind = function(futureB) {
            return make$3(function() {
                return run().then(function() {
                    return futureB.toPromise();
                });
            });
        };
        const toLazy = function() {
            return LazyValue.nu(get);
        };
        const toCached = function() {
            let cache = null;
            return make$3(function() {
                if (cache === null) {
                    cache = run();
                }
                return cache;
            });
        };
        const toPromise = run;
        return {
            map,
            bind,
            anonBind,
            toLazy,
            toCached,
            toPromise,
            get,
        };
    };
    const nu$b = function(baseFn) {
        return make$3(function() {
            return new Promise(baseFn);
        });
    };
    const pure$2 = function(a) {
        return make$3(function() {
            return Promise.resolve(a);
        });
    };
    const Future = {
        nu: nu$b,
        pure: pure$2,
    };

    const ariaElements = ['input', 'textarea'];
    const isAriaElement = function(elem) {
        const name$1 = name(elem);
        return contains(ariaElements, name$1);
    };
    const markValid = function(component, invalidConfig) {
        const elem = invalidConfig
            .getRoot(component)
            .getOr(component.element());
        remove$4(elem, invalidConfig.invalidClass);
        invalidConfig.notify.each(function(notifyInfo) {
            if (isAriaElement(component.element())) {
                set$1(component.element(), 'aria-invalid', false);
            }
            notifyInfo.getContainer(component).each(function(container) {
                set(container, notifyInfo.validHtml);
            });
            notifyInfo.onValid(component);
        });
    };
    const markInvalid = function(component, invalidConfig, invalidState, text) {
        const elem = invalidConfig
            .getRoot(component)
            .getOr(component.element());
        add$2(elem, invalidConfig.invalidClass);
        invalidConfig.notify.each(function(notifyInfo) {
            if (isAriaElement(component.element())) {
                set$1(component.element(), 'aria-invalid', true);
            }
            notifyInfo.getContainer(component).each(function(container) {
                set(container, text);
            });
            notifyInfo.onInvalid(component, text);
        });
    };
    const query = function(component, invalidConfig, invalidState) {
        return invalidConfig.validator.fold(
            function() {
                return Future.pure(Result.value(true));
            },
            function(validatorInfo) {
                return validatorInfo.validate(component);
            },
        );
    };
    const run$1 = function(component, invalidConfig, invalidState) {
        invalidConfig.notify.each(function(notifyInfo) {
            notifyInfo.onValidate(component);
        });
        return query(component, invalidConfig).map(function(valid) {
            if (component.getSystem().isConnected()) {
                return valid.fold(
                    function(err) {
                        markInvalid(
                            component,
                            invalidConfig,
                            invalidState,
                            err,
                        );
                        return Result.error(err);
                    },
                    function(v) {
                        markValid(component, invalidConfig);
                        return Result.value(v);
                    },
                );
            }
            return Result.error('No longer in system');
        });
    };
    const isInvalid = function(component, invalidConfig) {
        const elem = invalidConfig
            .getRoot(component)
            .getOr(component.element());
        return has$2(elem, invalidConfig.invalidClass);
    };

    const InvalidateApis = /* #__PURE__ */ Object.freeze({
        markValid,
        markInvalid,
        query,
        run: run$1,
        isInvalid,
    });

    const events$a = function(invalidConfig, invalidState) {
        return invalidConfig.validator
            .map(function(validatorInfo) {
                return derive(
                    [
                        run(validatorInfo.onEvent, function(component) {
                            run$1(component, invalidConfig, invalidState).get(
                                identity,
                            );
                        }),
                    ].concat(
                        validatorInfo.validateOnLoad
                            ? [
                                  runOnAttached(function(component) {
                                      run$1(
                                          component,
                                          invalidConfig,
                                          invalidState,
                                      ).get(noop);
                                  }),
                              ]
                            : [],
                    ),
                );
            })
            .getOr({});
    };

    const ActiveInvalidate = /* #__PURE__ */ Object.freeze({
        events: events$a,
    });

    const InvalidateSchema = [
        strict$1('invalidClass'),
        defaulted$1('getRoot', Option.none),
        optionObjOf('notify', [
            defaulted$1('aria', 'alert'),
            defaulted$1('getContainer', Option.none),
            defaulted$1('validHtml', ''),
            onHandler('onValid'),
            onHandler('onInvalid'),
            onHandler('onValidate'),
        ]),
        optionObjOf('validator', [
            strict$1('validate'),
            defaulted$1('onEvent', 'input'),
            defaulted$1('validateOnLoad', true),
        ]),
    ];

    const Invalidating = create$1({
        fields: InvalidateSchema,
        name: 'invalidating',
        active: ActiveInvalidate,
        apis: InvalidateApis,
        extra: {
            validation(validator) {
                return function(component) {
                    const v = Representing.getValue(component);
                    return Future.pure(validator(v));
                };
            },
        },
    });

    const exhibit$4 = function(base, tabConfig) {
        return nu$6({
            attributes: wrapAll$1([
                {
                    key: tabConfig.tabAttr,
                    value: 'true',
                },
            ]),
        });
    };

    const ActiveTabstopping = /* #__PURE__ */ Object.freeze({
        exhibit: exhibit$4,
    });

    const TabstopSchema = [defaulted$1('tabAttr', 'data-alloy-tabstop')];

    const Tabstopping = create$1({
        fields: TabstopSchema,
        name: 'tabstopping',
        active: ActiveTabstopping,
    });

    const renderFormFieldWith = function(
        pLabel,
        pField,
        extraClasses,
        extraBehaviours,
    ) {
        const spec = renderFormFieldSpecWith(
            pLabel,
            pField,
            extraClasses,
            extraBehaviours,
        );
        return FormField.sketch(spec);
    };
    const renderFormField = function(pLabel, pField) {
        return renderFormFieldWith(pLabel, pField, [], []);
    };
    var renderFormFieldSpecWith = function(
        pLabel,
        pField,
        extraClasses,
        extraBehaviours,
    ) {
        return {
            dom: renderFormFieldDomWith(extraClasses),
            components: pLabel.toArray().concat([pField]),
            fieldBehaviours: derive$1(extraBehaviours),
        };
    };
    const renderFormFieldDom = function() {
        return renderFormFieldDomWith([]);
    };
    var renderFormFieldDomWith = function(extraClasses) {
        return {
            tag: 'div',
            classes: ['tox-form__group'].concat(extraClasses),
        };
    };
    const renderLabel = function(label, providersBackstage) {
        return FormField.parts().label({
            dom: {
                tag: 'label',
                classes: ['tox-label'],
                innerHtml: providersBackstage.translate(label),
            },
        });
    };

    const getCoupled = function(component, coupleConfig, coupleState, name) {
        return coupleState.getOrCreate(component, coupleConfig, name);
    };

    const CouplingApis = /* #__PURE__ */ Object.freeze({
        getCoupled,
    });

    const CouplingSchema = [
        strictOf('others', setOf$1(Result.value, anyValue$1())),
    ];

    const init$5 = function(spec) {
        const coupled = {};
        const getOrCreate = function(component, coupleConfig, name) {
            const available = keys(coupleConfig.others);
            if (!available) {
                throw new Error(
                    `Cannot find coupled component: ${name}. Known coupled components: ${JSON.stringify(
                        available,
                        null,
                        2,
                    )}`,
                );
            } else {
                return readOptFrom$1(coupled, name).getOrThunk(function() {
                    const builder = readOptFrom$1(
                        coupleConfig.others,
                        name,
                    ).getOrDie(
                        `No information found for coupled component: ${name}`,
                    );
                    const spec = builder(component);
                    const built = component.getSystem().build(spec);
                    coupled[name] = built;
                    return built;
                });
            }
        };
        const readState = constant({});
        return nu$5({
            readState,
            getOrCreate,
        });
    };

    const CouplingState = /* #__PURE__ */ Object.freeze({
        init: init$5,
    });

    const Coupling = create$1({
        fields: CouplingSchema,
        name: 'coupling',
        apis: CouplingApis,
        state: CouplingState,
    });

    const suffix = constant('sink');
    const partType = constant(
        optional({
            name: suffix(),
            overrides: constant({
                dom: { tag: 'div' },
                behaviours: derive$1([
                    Positioning.config({ useFixed: always }),
                ]),
                events: derive([
                    cutter(keydown()),
                    cutter(mousedown()),
                    cutter(click()),
                ]),
            }),
        }),
    );

    let HighlightOnOpen;
    (function(HighlightOnOpen) {
        HighlightOnOpen[(HighlightOnOpen.HighlightFirst = 0)] =
            'HighlightFirst';
        HighlightOnOpen[(HighlightOnOpen.HighlightNone = 1)] = 'HighlightNone';
    })(HighlightOnOpen || (HighlightOnOpen = {}));
    const getAnchor = function(detail, component) {
        const hotspot = detail.getHotspot(component).getOr(component);
        const anchor = 'hotspot';
        const overrides = detail.getAnchorOverrides();
        return detail.layouts.fold(
            function() {
                return {
                    anchor,
                    hotspot,
                    overrides,
                };
            },
            function(layouts) {
                return {
                    anchor,
                    hotspot,
                    overrides,
                    layouts,
                };
            },
        );
    };
    const fetch = function(detail, mapFetch, component) {
        const fetcher = detail.fetch;
        return fetcher(component).map(mapFetch);
    };
    const openF = function(
        detail,
        mapFetch,
        anchor,
        component,
        sandbox,
        externals,
        highlightOnOpen,
    ) {
        const futureData = fetch(detail, mapFetch, component);
        const getLazySink = getSink(component, detail);
        return futureData.map(function(tdata) {
            return tdata.bind(function(data) {
                return Option.from(
                    tieredMenu.sketch({
                        ...externals.menu(),
                        uid: generate$2(''),
                        data,
                        highlightImmediately:
                            highlightOnOpen === HighlightOnOpen.HighlightFirst,
                        onOpenMenu(tmenu, menu) {
                            const sink = getLazySink().getOrDie();
                            Positioning.position(sink, anchor, menu);
                            Sandboxing.decloak(sandbox);
                        },
                        onOpenSubmenu(tmenu, item, submenu) {
                            const sink = getLazySink().getOrDie();
                            Positioning.position(
                                sink,
                                {
                                    anchor: 'submenu',
                                    item,
                                },
                                submenu,
                            );
                            Sandboxing.decloak(sandbox);
                        },
                        onRepositionMenu(tmenu, primaryMenu, submenuTriggers) {
                            const sink = getLazySink().getOrDie();
                            Positioning.position(sink, anchor, primaryMenu);
                            each(submenuTriggers, function(st) {
                                Positioning.position(
                                    sink,
                                    {
                                        anchor: 'submenu',
                                        item: st.triggeringItem,
                                    },
                                    st.triggeredMenu,
                                );
                            });
                        },
                        onEscape() {
                            Focusing.focus(component);
                            Sandboxing.close(sandbox);
                            return Option.some(true);
                        },
                    }),
                );
            });
        });
    };
    const open$1 = function(
        detail,
        mapFetch,
        hotspot,
        sandbox,
        externals,
        onOpenSync,
        highlightOnOpen,
    ) {
        const anchor = getAnchor(detail, hotspot);
        const processed = openF(
            detail,
            mapFetch,
            anchor,
            hotspot,
            sandbox,
            externals,
            highlightOnOpen,
        );
        return processed.map(function(tdata) {
            tdata.fold(
                function() {
                    if (Sandboxing.isOpen(sandbox)) {
                        Sandboxing.close(sandbox);
                    }
                },
                function(data) {
                    Sandboxing.cloak(sandbox);
                    Sandboxing.open(sandbox, data);
                    onOpenSync(sandbox);
                },
            );
            return sandbox;
        });
    };
    const close$1 = function(
        detail,
        mapFetch,
        component,
        sandbox,
        _externals,
        _onOpenSync,
        _highlightOnOpen,
    ) {
        Sandboxing.close(sandbox);
        return Future.pure(sandbox);
    };
    const togglePopup = function(
        detail,
        mapFetch,
        hotspot,
        externals,
        onOpenSync,
        highlightOnOpen,
    ) {
        const sandbox = Coupling.getCoupled(hotspot, 'sandbox');
        const showing = Sandboxing.isOpen(sandbox);
        const action = showing ? close$1 : open$1;
        return action(
            detail,
            mapFetch,
            hotspot,
            sandbox,
            externals,
            onOpenSync,
            highlightOnOpen,
        );
    };
    const matchWidth = function(hotspot, container, useMinWidth) {
        const menu = Composing.getCurrent(container).getOr(container);
        const buttonWidth = get$7(hotspot.element());
        if (useMinWidth) {
            set$2(menu.element(), 'min-width', `${buttonWidth}px`);
        } else {
            set$4(menu.element(), buttonWidth);
        }
    };
    var getSink = function(anyInSystem, sinkDetail) {
        return anyInSystem
            .getSystem()
            .getByUid(`${sinkDetail.uid}-${suffix()}`)
            .map(function(internalSink) {
                return function() {
                    return Result.value(internalSink);
                };
            })
            .getOrThunk(function() {
                return sinkDetail.lazySink.fold(
                    function() {
                        return function() {
                            return Result.error(
                                new Error(
                                    'No internal sink is specified, nor could an external sink be found',
                                ),
                            );
                        };
                    },
                    function(lazySinkFn) {
                        return function() {
                            return lazySinkFn(anyInSystem);
                        };
                    },
                );
            });
    };
    const doRepositionMenus = function(sandbox) {
        Sandboxing.getState(sandbox).each(function(tmenu) {
            tieredMenu.repositionMenus(tmenu);
        });
    };
    const makeSandbox = function(detail, hotspot, extras) {
        const ariaOwner = manager();
        const onOpen = function(component, menu) {
            const anchor = getAnchor(detail, hotspot);
            ariaOwner.link(hotspot.element());
            if (detail.matchWidth) {
                matchWidth(anchor.hotspot, menu, detail.useMinWidth);
            }
            detail.onOpen(anchor, component, menu);
            if (extras !== undefined && extras.onOpen !== undefined) {
                extras.onOpen(component, menu);
            }
        };
        const onClose = function(component, menu) {
            ariaOwner.unlink(hotspot.element());
            if (extras !== undefined && extras.onClose !== undefined) {
                extras.onClose(component, menu);
            }
        };
        const lazySink = getSink(hotspot, detail);
        return {
            dom: {
                tag: 'div',
                classes: detail.sandboxClasses,
                attributes: {
                    id: ariaOwner.id(),
                    role: 'listbox',
                },
            },
            behaviours: SketchBehaviours.augment(detail.sandboxBehaviours, [
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: hotspot,
                    },
                }),
                Sandboxing.config({
                    onOpen,
                    onClose,
                    isPartOf(container, data, queryElem) {
                        return (
                            isPartOf(data, queryElem) ||
                            isPartOf(hotspot, queryElem)
                        );
                    },
                    getAttachPoint() {
                        return lazySink().getOrDie();
                    },
                }),
                Composing.config({
                    find(sandbox) {
                        return Sandboxing.getState(sandbox).bind(function(
                            menu,
                        ) {
                            return Composing.getCurrent(menu);
                        });
                    },
                }),
                Receiving.config({
                    channels: {
                        ...receivingChannel({ isExtraPart: constant(false) }),
                        ...receivingChannel$1({
                            isExtraPart: constant(false),
                            doReposition: doRepositionMenus,
                        }),
                    },
                }),
            ]),
        };
    };
    const repositionMenus = function(comp) {
        const sandbox = Coupling.getCoupled(comp, 'sandbox');
        doRepositionMenus(sandbox);
    };

    const sandboxFields = function() {
        return [
            defaulted$1('sandboxClasses', []),
            SketchBehaviours.field('sandboxBehaviours', [
                Composing,
                Receiving,
                Sandboxing,
                Representing,
            ]),
        ];
    };

    const schema$g = constant(
        [
            strict$1('dom'),
            strict$1('fetch'),
            onHandler('onOpen'),
            onKeyboardHandler('onExecute'),
            defaulted$1('getHotspot', Option.some),
            defaulted$1('getAnchorOverrides', constant({})),
            defaulted$1('layouts', Option.none()),
            field$1('dropdownBehaviours', [
                Toggling,
                Coupling,
                Keying,
                Focusing,
            ]),
            strict$1('toggleClass'),
            defaulted$1('eventOrder', {}),
            option('lazySink'),
            defaulted$1('matchWidth', false),
            defaulted$1('useMinWidth', false),
            option('role'),
        ].concat(sandboxFields()),
    );
    const parts$4 = constant([
        external$1({
            schema: [tieredMenuMarkers()],
            name: 'menu',
            defaults(detail) {
                return { onExecute: detail.onExecute };
            },
        }),
        partType(),
    ]);

    const factory$6 = function(detail, components, _spec, externals) {
        let _a;
        const lookupAttr = function(attr) {
            return readOptFrom$1(detail.dom, 'attributes').bind(function(
                attrs,
            ) {
                return readOptFrom$1(attrs, attr);
            });
        };
        const switchToMenu = function(sandbox) {
            Sandboxing.getState(sandbox).each(function(tmenu) {
                tieredMenu.highlightPrimary(tmenu);
            });
        };
        const action = function(component) {
            const onOpenSync = switchToMenu;
            togglePopup(
                detail,
                function(x) {
                    return x;
                },
                component,
                externals,
                onOpenSync,
                HighlightOnOpen.HighlightFirst,
            ).get(noop);
        };
        const apis = {
            expand(comp) {
                if (!Toggling.isOn(comp)) {
                    togglePopup(
                        detail,
                        function(x) {
                            return x;
                        },
                        comp,
                        externals,
                        noop,
                        HighlightOnOpen.HighlightNone,
                    ).get(noop);
                }
            },
            open(comp) {
                if (!Toggling.isOn(comp)) {
                    togglePopup(
                        detail,
                        function(x) {
                            return x;
                        },
                        comp,
                        externals,
                        noop,
                        HighlightOnOpen.HighlightFirst,
                    ).get(noop);
                }
            },
            isOpen: Toggling.isOn,
            close(comp) {
                if (Toggling.isOn(comp)) {
                    togglePopup(
                        detail,
                        function(x) {
                            return x;
                        },
                        comp,
                        externals,
                        noop,
                        HighlightOnOpen.HighlightFirst,
                    ).get(noop);
                }
            },
            repositionMenus(comp) {
                if (Toggling.isOn(comp)) {
                    repositionMenus(comp);
                }
            },
        };
        const triggerExecute = function(comp, se) {
            emitExecute(comp);
            return Option.some(true);
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.dropdownBehaviours, [
                Toggling.config({
                    toggleClass: detail.toggleClass,
                    aria: { mode: 'expanded' },
                }),
                Coupling.config({
                    others: {
                        sandbox(hotspot) {
                            return makeSandbox(detail, hotspot, {
                                onOpen() {
                                    Toggling.on(hotspot);
                                },
                                onClose() {
                                    Toggling.off(hotspot);
                                },
                            });
                        },
                    },
                }),
                Keying.config({
                    mode: 'special',
                    onSpace: triggerExecute,
                    onEnter: triggerExecute,
                    onDown(comp, se) {
                        if (Dropdown.isOpen(comp)) {
                            const sandbox = Coupling.getCoupled(
                                comp,
                                'sandbox',
                            );
                            switchToMenu(sandbox);
                        } else {
                            Dropdown.open(comp);
                        }
                        return Option.some(true);
                    },
                    onEscape(comp, se) {
                        if (Dropdown.isOpen(comp)) {
                            Dropdown.close(comp);
                            return Option.some(true);
                        }
                        return Option.none();
                    },
                }),
                Focusing.config({}),
            ]),
            events: events$7(Option.some(action)),
            eventOrder: {
                ...detail.eventOrder,
                ...((_a = {}),
                (_a[execute()] = [
                    'disabling',
                    'toggling',
                    'alloy.base.behaviour',
                ]),
                _a),
            },
            apis,
            domModification: {
                attributes: {
                    'aria-haspopup': 'true',
                    ...detail.role.fold(
                        function() {
                            return {};
                        },
                        function(role) {
                            return { role };
                        },
                    ),
                    ...(detail.dom.tag === 'button'
                        ? { type: lookupAttr('type').getOr('button') }
                        : {}),
                },
            },
        };
    };
    var Dropdown = composite$1({
        name: 'Dropdown',
        configFields: schema$g(),
        partFields: parts$4(),
        factory: factory$6,
        apis: {
            open(apis, comp) {
                return apis.open(comp);
            },
            expand(apis, comp) {
                return apis.expand(comp);
            },
            close(apis, comp) {
                return apis.close(comp);
            },
            isOpen(apis, comp) {
                return apis.isOpen(comp);
            },
            repositionMenus(apis, comp) {
                return apis.repositionMenus(comp);
            },
        },
    });

    const exhibit$5 = function(base, unselectConfig) {
        return nu$6({
            styles: {
                '-webkit-user-select': 'none',
                'user-select': 'none',
                '-ms-user-select': 'none',
                '-moz-user-select': '-moz-none',
            },
            attributes: { unselectable: 'on' },
        });
    };
    const events$b = function(unselectConfig) {
        return derive([abort(selectstart(), constant(true))]);
    };

    const ActiveUnselecting = /* #__PURE__ */ Object.freeze({
        events: events$b,
        exhibit: exhibit$5,
    });

    const Unselecting = create$1({
        fields: [],
        name: 'unselecting',
        active: ActiveUnselecting,
    });

    const renderPanelButton = function(spec, sharedBackstage) {
        return Dropdown.sketch({
            dom: spec.dom,
            components: spec.components,
            toggleClass: 'mce-active',
            dropdownBehaviours: derive$1([
                Unselecting.config({}),
                Tabstopping.config({}),
            ]),
            layouts: spec.layouts,
            sandboxClasses: ['tox-dialog__popups'],
            lazySink: sharedBackstage.getSink,
            fetch(comp) {
                return Future.nu(function(callback) {
                    return spec.fetch(callback);
                }).map(function(items) {
                    return Option.from(
                        createTieredDataFrom(
                            deepMerge(
                                createPartialChoiceMenu(
                                    generate$1('menu-value'),
                                    items,
                                    function(value) {
                                        spec.onItemAction(comp, value);
                                    },
                                    spec.columns,
                                    spec.presets,
                                    ItemResponse$1.CLOSE_ON_EXECUTE,
                                    function() {
                                        return false;
                                    },
                                    sharedBackstage.providers,
                                ),
                                {
                                    movement: deriveMenuMovement(
                                        spec.columns,
                                        spec.presets,
                                    ),
                                },
                            ),
                        ),
                    );
                });
            },
            parts: { menu: part(false, 1, spec.presets) },
        });
    };

    const colorInputChangeEvent = generate$1('color-input-change');
    const colorSwatchChangeEvent = generate$1('color-swatch-change');
    const colorPickerCancelEvent = generate$1('color-picker-cancel');
    const renderColorInput = function(
        spec,
        sharedBackstage,
        colorInputBackstage,
    ) {
        const pField = FormField.parts().field({
            factory: Input,
            inputClasses: ['tox-textfield'],
            onSetValue(c) {
                return Invalidating.run(c).get(function() {});
            },
            inputBehaviours: derive$1([
                Tabstopping.config({}),
                Invalidating.config({
                    invalidClass: 'tox-textbox-field-invalid',
                    getRoot(comp) {
                        return parent(comp.element());
                    },
                    notify: {
                        onValid(comp) {
                            const val = Representing.getValue(comp);
                            emitWith(comp, colorInputChangeEvent, {
                                color: val,
                            });
                        },
                    },
                    validator: {
                        validateOnLoad: false,
                        validate(input) {
                            const inputValue = Representing.getValue(input);
                            if (inputValue.length === 0) {
                                return Future.pure(Result.value(true));
                            }
                            const span = Element.fromTag('span');
                            set$2(span, 'background-color', inputValue);
                            const res = getRaw(span, 'background-color').fold(
                                function() {
                                    return Result.error('blah');
                                },
                                function(_) {
                                    return Result.value(inputValue);
                                },
                            );
                            return Future.pure(res);
                        },
                    },
                }),
            ]),
            selectOnFocus: false,
        });
        const pLabel = spec.label.map(function(label) {
            return renderLabel(label, sharedBackstage.providers);
        });
        const emitSwatchChange = function(colorBit, value) {
            emitWith(colorBit, colorSwatchChangeEvent, { value });
        };
        const onItemAction = function(comp, value) {
            memColorButton.getOpt(comp).each(function(colorBit) {
                if (value === 'custom') {
                    colorInputBackstage.colorPicker(function(valueOpt) {
                        valueOpt.fold(
                            function() {
                                return emit(colorBit, colorPickerCancelEvent);
                            },
                            function(value) {
                                emitSwatchChange(colorBit, value);
                                Settings.addColor(value);
                            },
                        );
                    }, '#ffffff');
                } else if (value === 'remove') {
                    emitSwatchChange(colorBit, '');
                } else {
                    emitSwatchChange(colorBit, value);
                }
            });
        };
        var memColorButton = record(
            renderPanelButton(
                {
                    dom: {
                        tag: 'span',
                        attributes: {
                            'aria-label': sharedBackstage.providers.translate(
                                'Color swatch',
                            ),
                        },
                    },
                    layouts: Option.some({
                        onRtl() {
                            return [southeast$1];
                        },
                        onLtr() {
                            return [southwest$1];
                        },
                    }),
                    components: [],
                    fetch: ColorSwatch.getFetch(
                        colorInputBackstage.getColors(),
                        colorInputBackstage.hasCustomColors(),
                    ),
                    columns: colorInputBackstage.getColorCols(),
                    presets: 'color',
                    onItemAction,
                },
                sharedBackstage,
            ),
        );
        return FormField.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-form__group'],
            },
            components: pLabel.toArray().concat([
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-color-input'],
                    },
                    components: [pField, memColorButton.asSpec()],
                },
            ]),
            fieldBehaviours: derive$1([
                config('form-field-events', [
                    run(colorInputChangeEvent, function(comp, se) {
                        memColorButton.getOpt(comp).each(function(colorButton) {
                            set$2(
                                colorButton.element(),
                                'background-color',
                                se.event().color(),
                            );
                        });
                        emitWith(comp, formChangeEvent, { name: spec.name });
                    }),
                    run(colorSwatchChangeEvent, function(comp, se) {
                        FormField.getField(comp).each(function(field) {
                            Representing.setValue(field, se.event().value());
                            Composing.getCurrent(comp).each(Focusing.focus);
                        });
                    }),
                    run(colorPickerCancelEvent, function(comp, se) {
                        FormField.getField(comp).each(function(field) {
                            Composing.getCurrent(comp).each(Focusing.focus);
                        });
                    }),
                ]),
            ]),
        });
    };

    const hsvColour = function(hue, saturation, value) {
        return {
            hue: constant(hue),
            saturation: constant(saturation),
            value: constant(value),
        };
    };
    const fromRgb = function(rgbaColour) {
        let h = 0;
        let s = 0;
        let v = 0;
        const r = rgbaColour.red() / 255;
        const g = rgbaColour.green() / 255;
        const b = rgbaColour.blue() / 255;
        const minRGB = Math.min(r, Math.min(g, b));
        const maxRGB = Math.max(r, Math.max(g, b));
        if (minRGB === maxRGB) {
            v = minRGB;
            return hsvColour(0, 0, v * 100);
        }
        const d = r === minRGB ? g - b : b === minRGB ? r - g : b - r;
        h = r === minRGB ? 3 : b === minRGB ? 1 : 5;
        h = 60 * (h - d / (maxRGB - minRGB));
        s = (maxRGB - minRGB) / maxRGB;
        v = maxRGB;
        return hsvColour(
            Math.round(h),
            Math.round(s * 100),
            Math.round(v * 100),
        );
    };

    const calcHex = function(value) {
        const hue = ((100 - value) / 100) * 360;
        const hsv = hsvColour(hue, 100, 100);
        const rgb = fromHsv(hsv);
        return fromRgba(rgb);
    };

    const fieldsUpdate = constant(generate$1('rgb-hex-update'));
    const sliderUpdate = constant(generate$1('slider-update'));
    const paletteUpdate = constant(generate$1('palette-update'));

    const labelPart = optional({
        schema: [strict$1('dom')],
        name: 'label',
    });
    const edgePart = function(name) {
        return optional({
            name: `${name}-edge`,
            overrides(detail) {
                const action = detail.model.manager.edgeActions[name];
                return action.fold(
                    function() {
                        return {};
                    },
                    function(a) {
                        return {
                            events: derive([
                                runActionExtra(touchstart(), a, [detail]),
                                runActionExtra(mousedown(), a, [detail]),
                                runActionExtra(
                                    mousemove(),
                                    function(l, se, det) {
                                        if (det.mouseIsDown.get()) {
                                            a(l, det);
                                        }
                                    },
                                    [detail],
                                ),
                            ]),
                        };
                    },
                );
            },
        });
    };
    const tlEdgePart = edgePart('top-left');
    const tedgePart = edgePart('top');
    const trEdgePart = edgePart('top-right');
    const redgePart = edgePart('right');
    const brEdgePart = edgePart('bottom-right');
    const bedgePart = edgePart('bottom');
    const blEdgePart = edgePart('bottom-left');
    const ledgePart = edgePart('left');
    const thumbPart = required({
        name: 'thumb',
        defaults: constant({ dom: { styles: { position: 'absolute' } } }),
        overrides(detail) {
            return {
                events: derive([
                    redirectToPart(touchstart(), detail, 'spectrum'),
                    redirectToPart(touchmove(), detail, 'spectrum'),
                    redirectToPart(touchend(), detail, 'spectrum'),
                    redirectToPart(mousedown(), detail, 'spectrum'),
                    redirectToPart(mousemove(), detail, 'spectrum'),
                    redirectToPart(mouseup(), detail, 'spectrum'),
                ]),
            };
        },
    });
    const spectrumPart = required({
        schema: [
            state$1('mouseIsDown', function() {
                return Cell(false);
            }),
        ],
        name: 'spectrum',
        overrides(detail) {
            const modelDetail = detail.model;
            const model = modelDetail.manager;
            const setValueFrom = function(component, simulatedEvent) {
                return model
                    .getValueFromEvent(simulatedEvent)
                    .map(function(value) {
                        return model.setValueFrom(component, detail, value);
                    });
            };
            return {
                behaviours: derive$1([
                    Keying.config({
                        mode: 'special',
                        onLeft(spectrum) {
                            return model.onLeft(spectrum, detail);
                        },
                        onRight(spectrum) {
                            return model.onRight(spectrum, detail);
                        },
                        onUp(spectrum) {
                            return model.onUp(spectrum, detail);
                        },
                        onDown(spectrum) {
                            return model.onDown(spectrum, detail);
                        },
                    }),
                    Focusing.config({}),
                ]),
                events: derive([
                    run(touchstart(), setValueFrom),
                    run(touchmove(), setValueFrom),
                    run(mousedown(), setValueFrom),
                    run(mousemove(), function(spectrum, se) {
                        if (detail.mouseIsDown.get()) {
                            setValueFrom(spectrum, se);
                        }
                    }),
                ]),
            };
        },
    });
    const SliderParts = [
        labelPart,
        ledgePart,
        redgePart,
        tedgePart,
        bedgePart,
        tlEdgePart,
        trEdgePart,
        blEdgePart,
        brEdgePart,
        thumbPart,
        spectrumPart,
    ];

    const _sliderChangeEvent = 'slider.change.value';
    const sliderChangeEvent = constant(_sliderChangeEvent);
    const isTouchEvent = function(evt) {
        return evt.type.indexOf('touch') !== -1;
    };
    const getEventSource = function(simulatedEvent) {
        const evt = simulatedEvent.event().raw();
        if (isTouchEvent(evt)) {
            const touchEvent = evt;
            return touchEvent.touches !== undefined &&
                touchEvent.touches.length === 1
                ? Option.some(touchEvent.touches[0]).map(function(t) {
                      return Position(t.clientX, t.clientY);
                  })
                : Option.none();
        }
        const mouseEvent = evt;
        return mouseEvent.clientX !== undefined
            ? Option.some(mouseEvent).map(function(me) {
                  return Position(me.clientX, me.clientY);
              })
            : Option.none();
    };

    const t = 'top';
    const r$1 = 'right';
    const b = 'bottom';
    const l = 'left';
    const minX = function(detail) {
        return detail.model.minX;
    };
    const minY = function(detail) {
        return detail.model.minY;
    };
    const min1X = function(detail) {
        return detail.model.minX - 1;
    };
    const min1Y = function(detail) {
        return detail.model.minY - 1;
    };
    const maxX = function(detail) {
        return detail.model.maxX;
    };
    const maxY = function(detail) {
        return detail.model.maxY;
    };
    const max1X = function(detail) {
        return detail.model.maxX + 1;
    };
    const max1Y = function(detail) {
        return detail.model.maxY + 1;
    };
    const range$2 = function(detail, max, min) {
        return max(detail) - min(detail);
    };
    const xRange = function(detail) {
        return range$2(detail, maxX, minX);
    };
    const yRange = function(detail) {
        return range$2(detail, maxY, minY);
    };
    const halfX = function(detail) {
        return xRange(detail) / 2;
    };
    const halfY = function(detail) {
        return yRange(detail) / 2;
    };
    const step = function(detail) {
        return detail.stepSize;
    };
    const snap = function(detail) {
        return detail.snapToGrid;
    };
    const snapStart = function(detail) {
        return detail.snapStart;
    };
    const rounded = function(detail) {
        return detail.rounded;
    };
    const hasEdge = function(detail, edgeName) {
        return detail[`${edgeName}-edge`] !== undefined;
    };
    const hasLEdge = function(detail) {
        return hasEdge(detail, l);
    };
    const hasREdge = function(detail) {
        return hasEdge(detail, r$1);
    };
    const hasTEdge = function(detail) {
        return hasEdge(detail, t);
    };
    const hasBEdge = function(detail) {
        return hasEdge(detail, b);
    };
    const currentValue = function(detail) {
        return detail.model.value.get();
    };

    const xValue = function(x) {
        return { x: constant(x) };
    };
    const yValue = function(y) {
        return { y: constant(y) };
    };
    const xyValue = function(x, y) {
        return {
            x: constant(x),
            y: constant(y),
        };
    };
    const fireSliderChange = function(component, value) {
        emitWith(component, sliderChangeEvent(), { value });
    };
    const setToTLEdgeXY = function(edge, detail) {
        fireSliderChange(edge, xyValue(min1X(detail), min1Y(detail)));
    };
    const setToTEdge = function(edge, detail) {
        fireSliderChange(edge, yValue(min1Y(detail)));
    };
    const setToTEdgeXY = function(edge, detail) {
        fireSliderChange(edge, xyValue(halfX(detail), min1Y(detail)));
    };
    const setToTREdgeXY = function(edge, detail) {
        fireSliderChange(edge, xyValue(max1X(detail), min1Y(detail)));
    };
    const setToREdge = function(edge, detail) {
        fireSliderChange(edge, xValue(max1X(detail)));
    };
    const setToREdgeXY = function(edge, detail) {
        fireSliderChange(edge, xyValue(max1X(detail), halfY(detail)));
    };
    const setToBREdgeXY = function(edge, detail) {
        fireSliderChange(edge, xyValue(max1X(detail), max1Y(detail)));
    };
    const setToBEdge = function(edge, detail) {
        fireSliderChange(edge, yValue(max1Y(detail)));
    };
    const setToBEdgeXY = function(edge, detail) {
        fireSliderChange(edge, xyValue(halfX(detail), max1Y(detail)));
    };
    const setToBLEdgeXY = function(edge, detail) {
        fireSliderChange(edge, xyValue(min1X(detail), max1Y(detail)));
    };
    const setToLEdge = function(edge, detail) {
        fireSliderChange(edge, xValue(min1X(detail)));
    };
    const setToLEdgeXY = function(edge, detail) {
        fireSliderChange(edge, xyValue(min1X(detail), halfY(detail)));
    };

    const reduceBy = function(value, min, max, step) {
        if (value < min) {
            return value;
        }
        if (value > max) {
            return max;
        }
        if (value === min) {
            return min - 1;
        }
        return Math.max(min, value - step);
    };
    const increaseBy = function(value, min, max, step) {
        if (value > max) {
            return value;
        }
        if (value < min) {
            return min;
        }
        if (value === max) {
            return max + 1;
        }
        return Math.min(max, value + step);
    };
    const capValue = function(value, min, max) {
        return Math.max(min, Math.min(max, value));
    };
    const snapValueOf = function(value, min, max, step, snapStart) {
        return snapStart.fold(
            function() {
                const initValue = value - min;
                const extraValue = Math.round(initValue / step) * step;
                return capValue(min + extraValue, min - 1, max + 1);
            },
            function(start) {
                const remainder = (value - start) % step;
                const adjustment = Math.round(remainder / step);
                const rawSteps = Math.floor((value - start) / step);
                const maxSteps = Math.floor((max - start) / step);
                const numSteps = Math.min(maxSteps, rawSteps + adjustment);
                const r = start + numSteps * step;
                return Math.max(start, r);
            },
        );
    };
    const findOffsetOf = function(value, min, max) {
        return Math.min(max, Math.max(value, min)) - min;
    };
    const findValueOf = function(args) {
        const { min } = args;
        const { max } = args;
        const { range } = args;
        const { value } = args;
        const { step } = args;
        const { snap } = args;
        const { snapStart } = args;
        const { rounded } = args;
        const { hasMinEdge } = args;
        const { hasMaxEdge } = args;
        const { minBound } = args;
        const { maxBound } = args;
        const { screenRange } = args;
        const capMin = hasMinEdge ? min - 1 : min;
        const capMax = hasMaxEdge ? max + 1 : max;
        if (value < minBound) {
            return capMin;
        }
        if (value > maxBound) {
            return capMax;
        }
        const offset = findOffsetOf(value, minBound, maxBound);
        const newValue = capValue(
            (offset / screenRange) * range + min,
            capMin,
            capMax,
        );
        if (snap && newValue >= min && newValue <= max) {
            return snapValueOf(newValue, min, max, step, snapStart);
        }
        if (rounded) {
            return Math.round(newValue);
        }
        return newValue;
    };
    const findOffsetOfValue = function(args) {
        const { min } = args;
        const { max } = args;
        const { range } = args;
        const { value } = args;
        const { hasMinEdge } = args;
        const { hasMaxEdge } = args;
        const { maxBound } = args;
        const { maxOffset } = args;
        const { centerMinEdge } = args;
        const { centerMaxEdge } = args;
        if (value < min) {
            return hasMinEdge ? 0 : centerMinEdge;
        }
        if (value > max) {
            return hasMaxEdge ? maxBound : centerMaxEdge;
        }
        return ((value - min) / range) * maxOffset;
    };

    const top = 'top';
    const right = 'right';
    const bottom = 'bottom';
    const left = 'left';
    const width = 'width';
    const height = 'height';
    const getBounds$1 = function(component) {
        return component
            .element()
            .dom()
            .getBoundingClientRect();
    };
    const getBoundsProperty = function(bounds, property) {
        return bounds[property];
    };
    const getMinXBounds = function(component) {
        const bounds = getBounds$1(component);
        return getBoundsProperty(bounds, left);
    };
    const getMaxXBounds = function(component) {
        const bounds = getBounds$1(component);
        return getBoundsProperty(bounds, right);
    };
    const getMinYBounds = function(component) {
        const bounds = getBounds$1(component);
        return getBoundsProperty(bounds, top);
    };
    const getMaxYBounds = function(component) {
        const bounds = getBounds$1(component);
        return getBoundsProperty(bounds, bottom);
    };
    const getXScreenRange = function(component) {
        const bounds = getBounds$1(component);
        return getBoundsProperty(bounds, width);
    };
    const getYScreenRange = function(component) {
        const bounds = getBounds$1(component);
        return getBoundsProperty(bounds, height);
    };
    const getCenterOffsetOf = function(
        componentMinEdge,
        componentMaxEdge,
        spectrumMinEdge,
    ) {
        return (componentMinEdge + componentMaxEdge) / 2 - spectrumMinEdge;
    };
    const getXCenterOffSetOf = function(component, spectrum) {
        const componentBounds = getBounds$1(component);
        const spectrumBounds = getBounds$1(spectrum);
        const componentMinEdge = getBoundsProperty(componentBounds, left);
        const componentMaxEdge = getBoundsProperty(componentBounds, right);
        const spectrumMinEdge = getBoundsProperty(spectrumBounds, left);
        return getCenterOffsetOf(
            componentMinEdge,
            componentMaxEdge,
            spectrumMinEdge,
        );
    };
    const getYCenterOffSetOf = function(component, spectrum) {
        const componentBounds = getBounds$1(component);
        const spectrumBounds = getBounds$1(spectrum);
        const componentMinEdge = getBoundsProperty(componentBounds, top);
        const componentMaxEdge = getBoundsProperty(componentBounds, bottom);
        const spectrumMinEdge = getBoundsProperty(spectrumBounds, top);
        return getCenterOffsetOf(
            componentMinEdge,
            componentMaxEdge,
            spectrumMinEdge,
        );
    };

    const fireSliderChange$1 = function(spectrum, value) {
        emitWith(spectrum, sliderChangeEvent(), { value });
    };
    const sliderValue = function(x) {
        return { x: constant(x) };
    };
    const findValueOfOffset = function(spectrum, detail, left) {
        const args = {
            min: minX(detail),
            max: maxX(detail),
            range: xRange(detail),
            value: left,
            step: step(detail),
            snap: snap(detail),
            snapStart: snapStart(detail),
            rounded: rounded(detail),
            hasMinEdge: hasLEdge(detail),
            hasMaxEdge: hasREdge(detail),
            minBound: getMinXBounds(spectrum),
            maxBound: getMaxXBounds(spectrum),
            screenRange: getXScreenRange(spectrum),
        };
        return findValueOf(args);
    };
    const setValueFrom = function(spectrum, detail, value) {
        const xValue = findValueOfOffset(spectrum, detail, value);
        const sliderVal = sliderValue(xValue);
        fireSliderChange$1(spectrum, sliderVal);
        return xValue;
    };
    const setToMin = function(spectrum, detail) {
        const min = minX(detail);
        fireSliderChange$1(spectrum, sliderValue(min));
    };
    const setToMax = function(spectrum, detail) {
        const max = maxX(detail);
        fireSliderChange$1(spectrum, sliderValue(max));
    };
    const moveBy = function(direction, spectrum, detail) {
        const f = direction > 0 ? increaseBy : reduceBy;
        const xValue = f(
            currentValue(detail).x(),
            minX(detail),
            maxX(detail),
            step(detail),
        );
        fireSliderChange$1(spectrum, sliderValue(xValue));
        return Option.some(xValue);
    };
    const handleMovement = function(direction) {
        return function(spectrum, detail) {
            return moveBy(direction, spectrum, detail).map(function() {
                return true;
            });
        };
    };
    const getValueFromEvent = function(simulatedEvent) {
        const pos = getEventSource(simulatedEvent);
        return pos.map(function(p) {
            return p.left();
        });
    };
    const findOffsetOfValue$1 = function(
        spectrum,
        detail,
        value,
        minEdge,
        maxEdge,
    ) {
        const minOffset = 0;
        const maxOffset = getXScreenRange(spectrum);
        const centerMinEdge = minEdge
            .bind(function(edge) {
                return Option.some(getXCenterOffSetOf(edge, spectrum));
            })
            .getOr(minOffset);
        const centerMaxEdge = maxEdge
            .bind(function(edge) {
                return Option.some(getXCenterOffSetOf(edge, spectrum));
            })
            .getOr(maxOffset);
        const args = {
            min: minX(detail),
            max: maxX(detail),
            range: xRange(detail),
            value,
            hasMinEdge: hasLEdge(detail),
            hasMaxEdge: hasREdge(detail),
            minBound: getMinXBounds(spectrum),
            minOffset,
            maxBound: getMaxXBounds(spectrum),
            maxOffset,
            centerMinEdge,
            centerMaxEdge,
        };
        return findOffsetOfValue(args);
    };
    const findPositionOfValue = function(
        slider,
        spectrum,
        value,
        minEdge,
        maxEdge,
        detail,
    ) {
        const offset = findOffsetOfValue$1(
            spectrum,
            detail,
            value,
            minEdge,
            maxEdge,
        );
        return getMinXBounds(spectrum) - getMinXBounds(slider) + offset;
    };
    const setPositionFromValue = function(slider, thumb, detail, edges) {
        const value = currentValue(detail);
        const pos = findPositionOfValue(
            slider,
            edges.getSpectrum(slider),
            value.x(),
            edges.getLeftEdge(slider),
            edges.getRightEdge(slider),
            detail,
        );
        const thumbRadius = get$7(thumb.element()) / 2;
        set$2(thumb.element(), 'left', `${pos - thumbRadius}px`);
    };
    const onLeft = handleMovement(-1);
    const onRight = handleMovement(1);
    const onUp = Option.none;
    const onDown = Option.none;
    const edgeActions = {
        'top-left': Option.none(),
        top: Option.none(),
        'top-right': Option.none(),
        right: Option.some(setToREdge),
        'bottom-right': Option.none(),
        bottom: Option.none(),
        'bottom-left': Option.none(),
        left: Option.some(setToLEdge),
    };

    const HorizontalModel = /* #__PURE__ */ Object.freeze({
        setValueFrom,
        setToMin,
        setToMax,
        findValueOfOffset,
        getValueFromEvent,
        findPositionOfValue,
        setPositionFromValue,
        onLeft,
        onRight,
        onUp,
        onDown,
        edgeActions,
    });

    const fireSliderChange$2 = function(spectrum, value) {
        emitWith(spectrum, sliderChangeEvent(), { value });
    };
    const sliderValue$1 = function(y) {
        return { y: constant(y) };
    };
    const findValueOfOffset$1 = function(spectrum, detail, top) {
        const args = {
            min: minY(detail),
            max: maxY(detail),
            range: yRange(detail),
            value: top,
            step: step(detail),
            snap: snap(detail),
            snapStart: snapStart(detail),
            rounded: rounded(detail),
            hasMinEdge: hasTEdge(detail),
            hasMaxEdge: hasBEdge(detail),
            minBound: getMinYBounds(spectrum),
            maxBound: getMaxYBounds(spectrum),
            screenRange: getYScreenRange(spectrum),
        };
        return findValueOf(args);
    };
    const setValueFrom$1 = function(spectrum, detail, value) {
        const yValue = findValueOfOffset$1(spectrum, detail, value);
        const sliderVal = sliderValue$1(yValue);
        fireSliderChange$2(spectrum, sliderVal);
        return yValue;
    };
    const setToMin$1 = function(spectrum, detail) {
        const min = minY(detail);
        fireSliderChange$2(spectrum, sliderValue$1(min));
    };
    const setToMax$1 = function(spectrum, detail) {
        const max = maxY(detail);
        fireSliderChange$2(spectrum, sliderValue$1(max));
    };
    const moveBy$1 = function(direction, spectrum, detail) {
        const f = direction > 0 ? increaseBy : reduceBy;
        const yValue = f(
            currentValue(detail).y(),
            minY(detail),
            maxY(detail),
            step(detail),
        );
        fireSliderChange$2(spectrum, sliderValue$1(yValue));
        return Option.some(yValue);
    };
    const handleMovement$1 = function(direction) {
        return function(spectrum, detail) {
            return moveBy$1(direction, spectrum, detail).map(function() {
                return true;
            });
        };
    };
    const getValueFromEvent$1 = function(simulatedEvent) {
        const pos = getEventSource(simulatedEvent);
        return pos.map(function(p) {
            return p.top();
        });
    };
    const findOffsetOfValue$2 = function(
        spectrum,
        detail,
        value,
        minEdge,
        maxEdge,
    ) {
        const minOffset = 0;
        const maxOffset = getYScreenRange(spectrum);
        const centerMinEdge = minEdge
            .bind(function(edge) {
                return Option.some(getYCenterOffSetOf(edge, spectrum));
            })
            .getOr(minOffset);
        const centerMaxEdge = maxEdge
            .bind(function(edge) {
                return Option.some(getYCenterOffSetOf(edge, spectrum));
            })
            .getOr(maxOffset);
        const args = {
            min: minY(detail),
            max: maxY(detail),
            range: yRange(detail),
            value,
            hasMinEdge: hasTEdge(detail),
            hasMaxEdge: hasBEdge(detail),
            minBound: getMinYBounds(spectrum),
            minOffset,
            maxBound: getMaxYBounds(spectrum),
            maxOffset,
            centerMinEdge,
            centerMaxEdge,
        };
        return findOffsetOfValue(args);
    };
    const findPositionOfValue$1 = function(
        slider,
        spectrum,
        value,
        minEdge,
        maxEdge,
        detail,
    ) {
        const offset = findOffsetOfValue$2(
            spectrum,
            detail,
            value,
            minEdge,
            maxEdge,
        );
        return getMinYBounds(spectrum) - getMinYBounds(slider) + offset;
    };
    const setPositionFromValue$1 = function(slider, thumb, detail, edges) {
        const value = currentValue(detail);
        const pos = findPositionOfValue$1(
            slider,
            edges.getSpectrum(slider),
            value.y(),
            edges.getTopEdge(slider),
            edges.getBottomEdge(slider),
            detail,
        );
        const thumbRadius = get$6(thumb.element()) / 2;
        set$2(thumb.element(), 'top', `${pos - thumbRadius}px`);
    };
    const onLeft$1 = Option.none;
    const onRight$1 = Option.none;
    const onUp$1 = handleMovement$1(-1);
    const onDown$1 = handleMovement$1(1);
    const edgeActions$1 = {
        'top-left': Option.none(),
        top: Option.some(setToTEdge),
        'top-right': Option.none(),
        right: Option.none(),
        'bottom-right': Option.none(),
        bottom: Option.some(setToBEdge),
        'bottom-left': Option.none(),
        left: Option.none(),
    };

    const VerticalModel = /* #__PURE__ */ Object.freeze({
        setValueFrom: setValueFrom$1,
        setToMin: setToMin$1,
        setToMax: setToMax$1,
        findValueOfOffset: findValueOfOffset$1,
        getValueFromEvent: getValueFromEvent$1,
        findPositionOfValue: findPositionOfValue$1,
        setPositionFromValue: setPositionFromValue$1,
        onLeft: onLeft$1,
        onRight: onRight$1,
        onUp: onUp$1,
        onDown: onDown$1,
        edgeActions: edgeActions$1,
    });

    const fireSliderChange$3 = function(spectrum, value) {
        emitWith(spectrum, sliderChangeEvent(), { value });
    };
    const sliderValue$2 = function(x, y) {
        return {
            x: constant(x),
            y: constant(y),
        };
    };
    const setValueFrom$2 = function(spectrum, detail, value) {
        const xValue = findValueOfOffset(spectrum, detail, value.left());
        const yValue = findValueOfOffset$1(spectrum, detail, value.top());
        const val = sliderValue$2(xValue, yValue);
        fireSliderChange$3(spectrum, val);
        return val;
    };
    const moveBy$2 = function(direction, isVerticalMovement, spectrum, detail) {
        const f = direction > 0 ? increaseBy : reduceBy;
        const xValue = isVerticalMovement
            ? currentValue(detail).x()
            : f(
                  currentValue(detail).x(),
                  minX(detail),
                  maxX(detail),
                  step(detail),
              );
        const yValue = !isVerticalMovement
            ? currentValue(detail).y()
            : f(
                  currentValue(detail).y(),
                  minY(detail),
                  maxY(detail),
                  step(detail),
              );
        fireSliderChange$3(spectrum, sliderValue$2(xValue, yValue));
        return Option.some(xValue);
    };
    const handleMovement$2 = function(direction, isVerticalMovement) {
        return function(spectrum, detail) {
            return moveBy$2(
                direction,
                isVerticalMovement,
                spectrum,
                detail,
            ).map(function() {
                return true;
            });
        };
    };
    const setToMin$2 = function(spectrum, detail) {
        const mX = minX(detail);
        const mY = minY(detail);
        fireSliderChange$3(spectrum, sliderValue$2(mX, mY));
    };
    const setToMax$2 = function(spectrum, detail) {
        const mX = maxX(detail);
        const mY = maxY(detail);
        fireSliderChange$3(spectrum, sliderValue$2(mX, mY));
    };
    const getValueFromEvent$2 = function(simulatedEvent) {
        return getEventSource(simulatedEvent);
    };
    const setPositionFromValue$2 = function(slider, thumb, detail, edges) {
        const value = currentValue(detail);
        const xPos = findPositionOfValue(
            slider,
            edges.getSpectrum(slider),
            value.x(),
            edges.getLeftEdge(slider),
            edges.getRightEdge(slider),
            detail,
        );
        const yPos = findPositionOfValue$1(
            slider,
            edges.getSpectrum(slider),
            value.y(),
            edges.getTopEdge(slider),
            edges.getBottomEdge(slider),
            detail,
        );
        const thumbXRadius = get$7(thumb.element()) / 2;
        const thumbYRadius = get$6(thumb.element()) / 2;
        set$2(thumb.element(), 'left', `${xPos - thumbXRadius}px`);
        set$2(thumb.element(), 'top', `${yPos - thumbYRadius}px`);
    };
    const onLeft$2 = handleMovement$2(-1, false);
    const onRight$2 = handleMovement$2(1, false);
    const onUp$2 = handleMovement$2(-1, true);
    const onDown$2 = handleMovement$2(1, true);
    const edgeActions$2 = {
        'top-left': Option.some(setToTLEdgeXY),
        top: Option.some(setToTEdgeXY),
        'top-right': Option.some(setToTREdgeXY),
        right: Option.some(setToREdgeXY),
        'bottom-right': Option.some(setToBREdgeXY),
        bottom: Option.some(setToBEdgeXY),
        'bottom-left': Option.some(setToBLEdgeXY),
        left: Option.some(setToLEdgeXY),
    };

    const TwoDModel = /* #__PURE__ */ Object.freeze({
        setValueFrom: setValueFrom$2,
        setToMin: setToMin$2,
        setToMax: setToMax$2,
        getValueFromEvent: getValueFromEvent$2,
        setPositionFromValue: setPositionFromValue$2,
        onLeft: onLeft$2,
        onRight: onRight$2,
        onUp: onUp$2,
        onDown: onDown$2,
        edgeActions: edgeActions$2,
    });

    const SliderSchema = [
        defaulted$1('stepSize', 1),
        defaulted$1('onChange', noop),
        defaulted$1('onChoose', noop),
        defaulted$1('onInit', noop),
        defaulted$1('onDragStart', noop),
        defaulted$1('onDragEnd', noop),
        defaulted$1('snapToGrid', false),
        defaulted$1('rounded', true),
        option('snapStart'),
        strictOf(
            'model',
            choose$1('mode', {
                x: [
                    defaulted$1('minX', 0),
                    defaulted$1('maxX', 100),
                    state$1('value', function(spec) {
                        return Cell(spec.mode.minX);
                    }),
                    strict$1('getInitialValue'),
                    output('manager', HorizontalModel),
                ],
                y: [
                    defaulted$1('minY', 0),
                    defaulted$1('maxY', 100),
                    state$1('value', function(spec) {
                        return Cell(spec.mode.minY);
                    }),
                    strict$1('getInitialValue'),
                    output('manager', VerticalModel),
                ],
                xy: [
                    defaulted$1('minX', 0),
                    defaulted$1('maxX', 100),
                    defaulted$1('minY', 0),
                    defaulted$1('maxY', 100),
                    state$1('value', function(spec) {
                        return Cell({
                            x: constant(spec.mode.minX),
                            y: constant(spec.mode.minY),
                        });
                    }),
                    strict$1('getInitialValue'),
                    output('manager', TwoDModel),
                ],
            }),
        ),
        field$1('sliderBehaviours', [Keying, Representing]),
        state$1('mouseIsDown', function() {
            return Cell(false);
        }),
    ];

    const sketch = function(detail, components, _spec, _externals) {
        let _a;
        const getThumb = function(component) {
            return getPartOrDie(component, detail, 'thumb');
        };
        const getSpectrum = function(component) {
            return getPartOrDie(component, detail, 'spectrum');
        };
        const getLeftEdge = function(component) {
            return getPart(component, detail, 'left-edge');
        };
        const getRightEdge = function(component) {
            return getPart(component, detail, 'right-edge');
        };
        const getTopEdge = function(component) {
            return getPart(component, detail, 'top-edge');
        };
        const getBottomEdge = function(component) {
            return getPart(component, detail, 'bottom-edge');
        };
        const modelDetail = detail.model;
        const model = modelDetail.manager;
        const refresh = function(slider, thumb) {
            model.setPositionFromValue(slider, thumb, detail, {
                getLeftEdge,
                getRightEdge,
                getTopEdge,
                getBottomEdge,
                getSpectrum,
            });
        };
        const changeValue = function(slider, newValue) {
            modelDetail.value.set(newValue);
            const thumb = getThumb(slider);
            refresh(slider, thumb);
            detail.onChange(slider, thumb, newValue);
            return Option.some(true);
        };
        const resetToMin = function(slider) {
            model.setToMin(slider, detail);
        };
        const resetToMax = function(slider) {
            model.setToMax(slider, detail);
        };
        const choose = function(slider) {
            const fireOnChoose = function() {
                getPart(slider, detail, 'thumb').each(function(thumb) {
                    const value = modelDetail.value.get();
                    detail.onChoose(slider, thumb, value);
                });
            };
            const wasDown = detail.mouseIsDown.get();
            detail.mouseIsDown.set(false);
            if (wasDown) {
                fireOnChoose();
            }
        };
        const onDragStart = function(slider, simulatedEvent) {
            simulatedEvent.stop();
            detail.mouseIsDown.set(true);
            detail.onDragStart(slider, getThumb(slider));
        };
        const onDragEnd = function(slider, simulatedEvent) {
            simulatedEvent.stop();
            detail.onDragEnd(slider, getThumb(slider));
            choose(slider);
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.sliderBehaviours, [
                Keying.config({
                    mode: 'special',
                    focusIn(slider) {
                        return getPart(slider, detail, 'spectrum')
                            .map(Keying.focusIn)
                            .map(constant(true));
                    },
                }),
                Representing.config({
                    store: {
                        mode: 'manual',
                        getValue(_) {
                            return modelDetail.value.get();
                        },
                    },
                }),
                Receiving.config({
                    channels:
                        ((_a = {}),
                        (_a[mouseReleased()] = { onReceive: choose }),
                        _a),
                }),
            ]),
            events: derive([
                run(sliderChangeEvent(), function(slider, simulatedEvent) {
                    changeValue(slider, simulatedEvent.event().value());
                }),
                runOnAttached(function(slider, simulatedEvent) {
                    const getInitial = modelDetail.getInitialValue();
                    modelDetail.value.set(getInitial);
                    const thumb = getThumb(slider);
                    refresh(slider, thumb);
                    const spectrum = getSpectrum(slider);
                    detail.onInit(
                        slider,
                        thumb,
                        spectrum,
                        modelDetail.value.get(),
                    );
                }),
                run(touchstart(), onDragStart),
                run(touchend(), onDragEnd),
                run(mousedown(), onDragStart),
                run(mouseup(), onDragEnd),
            ]),
            apis: {
                resetToMin,
                resetToMax,
                changeValue,
                refresh,
            },
            domModification: { styles: { position: 'relative' } },
        };
    };

    const Slider = composite$1({
        name: 'Slider',
        configFields: SliderSchema,
        partFields: SliderParts,
        factory: sketch,
        apis: {
            resetToMin(apis, slider) {
                apis.resetToMin(slider);
            },
            resetToMax(apis, slider) {
                apis.resetToMax(slider);
            },
            refresh(apis, slider) {
                apis.refresh(slider);
            },
        },
    });

    const sliderFactory = function(translate, getClass) {
        const spectrum = Slider.parts().spectrum({
            dom: {
                tag: 'div',
                classes: [getClass('hue-slider-spectrum')],
                attributes: { role: 'presentation' },
            },
        });
        const thumb = Slider.parts().thumb({
            dom: {
                tag: 'div',
                classes: [getClass('hue-slider-thumb')],
                attributes: { role: 'presentation' },
            },
        });
        return Slider.sketch({
            dom: {
                tag: 'div',
                classes: [getClass('hue-slider')],
                attributes: { role: 'presentation' },
            },
            rounded: false,
            model: {
                mode: 'y',
                getInitialValue: constant({ y: constant(0) }),
            },
            components: [spectrum, thumb],
            sliderBehaviours: derive$1([Focusing.config({})]),
            onChange(slider, _thumb, value) {
                emitWith(slider, sliderUpdate(), { value });
            },
        });
    };
    const HueSlider = { sliderFactory };

    const owner$3 = 'form';
    const schema$h = [field$1('formBehaviours', [Representing])];
    const getPartName = function(name) {
        return `<alloy.field.${name}>`;
    };
    const sketch$1 = function(fSpec) {
        const parts = (function() {
            const record = [];
            const field = function(name, config) {
                record.push(name);
                return generateOne(owner$3, getPartName(name), config);
            };
            return {
                field,
                record() {
                    return record;
                },
            };
        })();
        const spec = fSpec(parts);
        const partNames = parts.record();
        const fieldParts = map(partNames, function(n) {
            return required({
                name: n,
                pname: getPartName(n),
            });
        });
        return composite(owner$3, schema$h, fieldParts, make$4, spec);
    };
    const toResult$1 = function(o, e) {
        return o.fold(function() {
            return Result.error(e);
        }, Result.value);
    };
    var make$4 = function(detail, components, spec) {
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.formBehaviours, [
                Representing.config({
                    store: {
                        mode: 'manual',
                        getValue(form) {
                            const resPs = getAllParts(form, detail);
                            return map$1(resPs, function(resPThunk, pName) {
                                return resPThunk()
                                    .bind(function(v) {
                                        const opt = Composing.getCurrent(v);
                                        return toResult$1(
                                            opt,
                                            'missing current',
                                        );
                                    })
                                    .map(Representing.getValue);
                            });
                        },
                        setValue(form, values) {
                            each$1(values, function(newValue, key) {
                                getPart(form, detail, key).each(function(
                                    wrapper,
                                ) {
                                    Composing.getCurrent(wrapper).each(function(
                                        field,
                                    ) {
                                        Representing.setValue(field, newValue);
                                    });
                                });
                            });
                        },
                    },
                }),
            ]),
            apis: {
                getField(form, key) {
                    return getPart(form, detail, key).bind(
                        Composing.getCurrent,
                    );
                },
            },
        };
    };
    const Form = {
        getField: makeApi(function(apis, component, key) {
            return apis.getField(component, key);
        }),
        sketch: sketch$1,
    };

    const validInput = generate$1('valid-input');
    const invalidInput = generate$1('invalid-input');
    const validatingInput = generate$1('validating-input');
    const translatePrefix = 'colorcustom.rgb.';
    const rgbFormFactory = function(
        translate,
        getClass,
        onValidHexx,
        onInvalidHexx,
    ) {
        const invalidation = function(label, isValid) {
            return Invalidating.config({
                invalidClass: getClass('invalid'),
                notify: {
                    onValidate(comp) {
                        emitWith(comp, validatingInput, { type: label });
                    },
                    onValid(comp) {
                        emitWith(comp, validInput, {
                            type: label,
                            value: Representing.getValue(comp),
                        });
                    },
                    onInvalid(comp) {
                        emitWith(comp, invalidInput, {
                            type: label,
                            value: Representing.getValue(comp),
                        });
                    },
                },
                validator: {
                    validate(comp) {
                        const value = Representing.getValue(comp);
                        const res = isValid(value)
                            ? Result.value(true)
                            : Result.error(translate('aria.input.invalid'));
                        return Future.pure(res);
                    },
                    validateOnLoad: false,
                },
            });
        };
        const renderTextField = function(
            isValid,
            name,
            label,
            description,
            data,
        ) {
            const helptext = translate(`${translatePrefix}range`);
            const pLabel = FormField.parts().label({
                dom: {
                    tag: 'label',
                    innerHtml: label,
                    attributes: { 'aria-label': description },
                },
            });
            const pField = FormField.parts().field({
                data,
                factory: Input,
                inputAttributes: {
                    type: 'text',
                    ...(name === 'hex' ? { 'aria-live': 'polite' } : {}),
                },
                inputClasses: [getClass('textfield')],
                inputBehaviours: derive$1([
                    invalidation(name, isValid),
                    Tabstopping.config({}),
                ]),
                onSetValue(input) {
                    if (Invalidating.isInvalid(input)) {
                        const run = Invalidating.run(input);
                        run.get(noop);
                    }
                },
            });
            const comps = [pLabel, pField];
            const concats =
                name !== 'hex'
                    ? [FormField.parts()['aria-descriptor']({ text: helptext })]
                    : [];
            const components = comps.concat(concats);
            return {
                dom: {
                    tag: 'div',
                    attributes: { role: 'presentation' },
                },
                components,
            };
        };
        const copyRgbToHex = function(form, rgba) {
            const hex = fromRgba(rgba);
            Form.getField(form, 'hex').each(function(hexField) {
                if (!Focusing.isFocused(hexField)) {
                    Representing.setValue(form, { hex: hex.value() });
                }
            });
            return hex;
        };
        const copyRgbToForm = function(form, rgb) {
            const red = rgb.red();
            const green = rgb.green();
            const blue = rgb.blue();
            Representing.setValue(form, {
                red,
                green,
                blue,
            });
        };
        const memPreview = record({
            dom: {
                tag: 'div',
                classes: [getClass('rgba-preview')],
                styles: { 'background-color': 'white' },
                attributes: { role: 'presentation' },
            },
        });
        const updatePreview = function(anyInSystem, hex) {
            memPreview.getOpt(anyInSystem).each(function(preview) {
                set$2(preview.element(), 'background-color', `#${hex.value()}`);
            });
        };
        const factory = function() {
            const state = {
                red: constant(Cell(Option.some(255))),
                green: constant(Cell(Option.some(255))),
                blue: constant(Cell(Option.some(255))),
                hex: constant(Cell(Option.some('ffffff'))),
            };
            const copyHexToRgb = function(form, hex) {
                const rgb = fromHex(hex);
                copyRgbToForm(form, rgb);
                setValueRgb(rgb);
            };
            const get = function(prop) {
                return state[prop]().get();
            };
            const set = function(prop, value) {
                state[prop]().set(value);
            };
            const getValueRgb = function() {
                return get('red').bind(function(red) {
                    return get('green').bind(function(green) {
                        return get('blue').map(function(blue) {
                            return rgbaColour(red, green, blue, 1);
                        });
                    });
                });
            };
            var setValueRgb = function(rgb) {
                const red = rgb.red();
                const green = rgb.green();
                const blue = rgb.blue();
                set('red', Option.some(red));
                set('green', Option.some(green));
                set('blue', Option.some(blue));
            };
            const onInvalidInput = function(form, simulatedEvent) {
                const data = simulatedEvent.event();
                if (data.type() !== 'hex') {
                    set(data.type(), Option.none());
                } else {
                    onInvalidHexx(form);
                }
            };
            const onValidHex = function(form, value) {
                onValidHexx(form);
                const hex = hexColour(value);
                set('hex', Option.some(value));
                const rgb = fromHex(hex);
                copyRgbToForm(form, rgb);
                setValueRgb(rgb);
                emitWith(form, fieldsUpdate(), { hex });
                updatePreview(form, hex);
            };
            const onValidRgb = function(form, prop, value) {
                const val = parseInt(value, 10);
                set(prop, Option.some(val));
                getValueRgb().each(function(rgb) {
                    const hex = copyRgbToHex(form, rgb);
                    updatePreview(form, hex);
                });
            };
            const isHexInputEvent = function(data) {
                return data.type() === 'hex';
            };
            const onValidInput = function(form, simulatedEvent) {
                const data = simulatedEvent.event();
                if (isHexInputEvent(data)) {
                    onValidHex(form, data.value());
                } else {
                    onValidRgb(form, data.type(), data.value());
                }
            };
            const formPartStrings = function(key) {
                return {
                    label: translate(`${translatePrefix + key}.label`),
                    description: translate(
                        `${translatePrefix + key}.description`,
                    ),
                };
            };
            const redStrings = formPartStrings('red');
            const greenStrings = formPartStrings('green');
            const blueStrings = formPartStrings('blue');
            const hexStrings = formPartStrings('hex');
            return deepMerge(
                Form.sketch(function(parts) {
                    return {
                        dom: {
                            tag: 'form',
                            classes: [getClass('rgb-form')],
                            attributes: {
                                'aria-label': translate('aria.color.picker'),
                            },
                        },
                        components: [
                            parts.field(
                                'red',
                                FormField.sketch(
                                    renderTextField(
                                        isRgbaComponent,
                                        'red',
                                        redStrings.label,
                                        redStrings.description,
                                        255,
                                    ),
                                ),
                            ),
                            parts.field(
                                'green',
                                FormField.sketch(
                                    renderTextField(
                                        isRgbaComponent,
                                        'green',
                                        greenStrings.label,
                                        greenStrings.description,
                                        255,
                                    ),
                                ),
                            ),
                            parts.field(
                                'blue',
                                FormField.sketch(
                                    renderTextField(
                                        isRgbaComponent,
                                        'blue',
                                        blueStrings.label,
                                        blueStrings.description,
                                        255,
                                    ),
                                ),
                            ),
                            parts.field(
                                'hex',
                                FormField.sketch(
                                    renderTextField(
                                        isHexString,
                                        'hex',
                                        hexStrings.label,
                                        hexStrings.description,
                                        'ffffff',
                                    ),
                                ),
                            ),
                            memPreview.asSpec(),
                        ],
                        formBehaviours: derive$1([
                            Invalidating.config({
                                invalidClass: getClass('form-invalid'),
                            }),
                            config('rgb-form-events', [
                                run(validInput, onValidInput),
                                run(invalidInput, onInvalidInput),
                                run(validatingInput, onInvalidInput),
                            ]),
                        ]),
                    };
                }),
                {
                    apis: {
                        updateHex(form, hex) {
                            Representing.setValue(form, { hex: hex.value() });
                            copyHexToRgb(form, hex);
                            updatePreview(form, hex);
                        },
                    },
                },
            );
        };
        const rgbFormSketcher = single$2({
            factory,
            name: 'RgbForm',
            configFields: [],
            apis: {
                updateHex(apis, form, hex) {
                    apis.updateHex(form, hex);
                },
            },
            extraApis: {},
        });
        return rgbFormSketcher;
    };
    const RgbForm = { rgbFormFactory };

    const paletteFactory = function(_translate, getClass) {
        const spectrumPart = Slider.parts().spectrum({
            dom: {
                tag: 'canvas',
                attributes: { role: 'presentation' },
                classes: [getClass('sv-palette-spectrum')],
            },
        });
        const thumbPart = Slider.parts().thumb({
            dom: {
                tag: 'div',
                attributes: { role: 'presentation' },
                classes: [getClass('sv-palette-thumb')],
                innerHtml: `<div class=${getClass(
                    'sv-palette-inner-thumb',
                )} role="presentation"></div>`,
            },
        });
        const setColour = function(canvas, rgba) {
            const { width } = canvas;
            const { height } = canvas;
            const ctx = canvas.getContext('2d');
            if (ctx === null) {
                return;
            }
            ctx.fillStyle = rgba;
            ctx.fillRect(0, 0, width, height);
            const grdWhite = ctx.createLinearGradient(0, 0, width, 0);
            grdWhite.addColorStop(0, 'rgba(255,255,255,1)');
            grdWhite.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grdWhite;
            ctx.fillRect(0, 0, width, height);
            const grdBlack = ctx.createLinearGradient(0, 0, 0, height);
            grdBlack.addColorStop(0, 'rgba(0,0,0,0)');
            grdBlack.addColorStop(1, 'rgba(0,0,0,1)');
            ctx.fillStyle = grdBlack;
            ctx.fillRect(0, 0, width, height);
        };
        const setSliderColour = function(slider, rgba) {
            const canvas = slider
                .components()[0]
                .element()
                .dom();
            setColour(canvas, toString(rgba));
        };
        const factory = function(_detail) {
            const getInitialValue = constant({
                x: constant(0),
                y: constant(0),
            });
            const onChange = function(slider, _thumb, value) {
                emitWith(slider, paletteUpdate(), { value });
            };
            const onInit = function(_slider, _thumb, spectrum, _value) {
                setColour(spectrum.element().dom(), toString(redColour()));
            };
            const sliderBehaviours = derive$1([
                Composing.config({ find: Option.some }),
                Focusing.config({}),
            ]);
            return Slider.sketch({
                dom: {
                    tag: 'div',
                    attributes: { role: 'presentation' },
                    classes: [getClass('sv-palette')],
                },
                model: {
                    mode: 'xy',
                    getInitialValue,
                },
                rounded: false,
                components: [spectrumPart, thumbPart],
                onChange,
                onInit,
                sliderBehaviours,
            });
        };
        const saturationBrightnessPaletteSketcher = single$2({
            factory,
            name: 'SaturationBrightnessPalette',
            configFields: [],
            apis: {
                setRgba(_apis, slider, rgba) {
                    setSliderColour(slider, rgba);
                },
            },
            extraApis: {},
        });
        return saturationBrightnessPaletteSketcher;
    };
    const SaturationBrightnessPalette = { paletteFactory };

    const makeFactory = function(translate, getClass) {
        const factory = function(detail) {
            const rgbForm = RgbForm.rgbFormFactory(
                translate,
                getClass,
                detail.onValidHex,
                detail.onInvalidHex,
            );
            const sbPalette = SaturationBrightnessPalette.paletteFactory(
                translate,
                getClass,
            );
            const state = { paletteRgba: constant(Cell(redColour())) };
            const memPalette = record(sbPalette.sketch({}));
            const memRgb = record(rgbForm.sketch({}));
            const updatePalette = function(anyInSystem, hex) {
                memPalette.getOpt(anyInSystem).each(function(palette) {
                    const rgba = fromHex(hex);
                    state.paletteRgba().set(rgba);
                    sbPalette.setRgba(palette, rgba);
                });
            };
            const updateFields = function(anyInSystem, hex) {
                memRgb.getOpt(anyInSystem).each(function(form) {
                    rgbForm.updateHex(form, hex);
                });
            };
            const runUpdates = function(anyInSystem, hex, updates) {
                each(updates, function(update) {
                    update(anyInSystem, hex);
                });
            };
            const paletteUpdates = function() {
                const updates = [updateFields];
                return function(form, simulatedEvent) {
                    const value = simulatedEvent.event().value();
                    const oldRgb = state.paletteRgba().get();
                    const hsvColour$1 = fromRgb(oldRgb);
                    const newHsvColour = hsvColour(
                        hsvColour$1.hue(),
                        value.x(),
                        100 - value.y(),
                    );
                    const rgb = fromHsv(newHsvColour);
                    const nuHex = fromRgba(rgb);
                    runUpdates(form, nuHex, updates);
                };
            };
            const sliderUpdates = function() {
                const updates = [updatePalette, updateFields];
                return function(form, simulatedEvent) {
                    const value = simulatedEvent.event().value();
                    const hex = calcHex(value.y());
                    runUpdates(form, hex, updates);
                };
            };
            return {
                uid: detail.uid,
                dom: detail.dom,
                components: [
                    memPalette.asSpec(),
                    HueSlider.sliderFactory(translate, getClass),
                    memRgb.asSpec(),
                ],
                behaviours: derive$1([
                    config('colour-picker-events', [
                        run(paletteUpdate(), paletteUpdates()),
                        run(sliderUpdate(), sliderUpdates()),
                    ]),
                    Composing.config({
                        find(comp) {
                            return memRgb.getOpt(comp);
                        },
                    }),
                    Keying.config({ mode: 'acyclic' }),
                ]),
            };
        };
        const colourPickerSketcher = single$2({
            name: 'ColourPicker',
            configFields: [
                strict$1('dom'),
                defaulted$1('onValidHex', noop),
                defaulted$1('onInvalidHex', noop),
            ],
            factory,
        });
        return colourPickerSketcher;
    };
    const ColourPicker = { makeFactory };

    const self$1 = function() {
        return Composing.config({ find: Option.some });
    };
    const memento = function(mem) {
        return Composing.config({ find: mem.getOpt });
    };
    const childAt = function(index) {
        return Composing.config({
            find(comp) {
                return child(comp.element(), index).bind(function(element) {
                    return comp
                        .getSystem()
                        .getByDom(element)
                        .toOption();
                });
            },
        });
    };
    const ComposingConfigs = {
        self: self$1,
        memento,
        childAt,
    };

    const english = {
        'colorcustom.rgb.red.label': 'R',
        'colorcustom.rgb.red.description': 'Red component',
        'colorcustom.rgb.green.label': 'G',
        'colorcustom.rgb.green.description': 'Green component',
        'colorcustom.rgb.blue.label': 'B',
        'colorcustom.rgb.blue.description': 'Blue component',
        'colorcustom.rgb.hex.label': '#',
        'colorcustom.rgb.hex.description': 'Hex color code',
        'colorcustom.rgb.range': 'Range 0 to 255',
        'colorcustom.sb.saturation': 'Saturation',
        'colorcustom.sb.brightness': 'Brightness',
        'colorcustom.sb.picker': 'Saturation and Brightness Picker',
        'colorcustom.sb.palette': 'Saturation and Brightness Palette',
        'colorcustom.sb.instructions':
            'Use arrow keys to select saturation and brightness, on x and y axes',
        'colorcustom.hue.hue': 'Hue',
        'colorcustom.hue.slider': 'Hue Slider',
        'colorcustom.hue.palette': 'Hue Palette',
        'colorcustom.hue.instructions': 'Use arrow keys to select a hue',
        'aria.color.picker': 'Color Picker',
        'aria.input.invalid': 'Invalid input',
    };
    const getEnglishText = function(key) {
        return english[key];
    };
    const translate$1 = function(key) {
        return getEnglishText(key);
    };
    const renderColorPicker = function(spec) {
        const getClass = function(key) {
            return `tox-${key}`;
        };
        const colourPickerFactory = ColourPicker.makeFactory(
            translate$1,
            getClass,
        );
        const onValidHex = function(form) {
            emitWith(form, formActionEvent, {
                name: 'hex-valid',
                value: true,
            });
        };
        const onInvalidHex = function(form) {
            emitWith(form, formActionEvent, {
                name: 'hex-valid',
                value: false,
            });
        };
        const memPicker = record(
            colourPickerFactory.sketch({
                dom: {
                    tag: 'div',
                    classes: [getClass('color-picker-container')],
                    attributes: { role: 'presentation' },
                },
                onValidHex,
                onInvalidHex,
            }),
        );
        return {
            dom: { tag: 'div' },
            components: [memPicker.asSpec()],
            behaviours: derive$1([
                Representing.config({
                    store: {
                        mode: 'manual',
                        getValue(comp) {
                            const picker = memPicker.get(comp);
                            const optRgbForm = Composing.getCurrent(picker);
                            const optHex = optRgbForm.bind(function(rgbForm) {
                                const formValues = Representing.getValue(
                                    rgbForm,
                                );
                                return formValues.hex;
                            });
                            return optHex
                                .map(function(hex) {
                                    return `#${hex}`;
                                })
                                .getOr('');
                        },
                        setValue(comp, newValue) {
                            const pattern = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/;
                            const m = pattern.exec(newValue);
                            const picker = memPicker.get(comp);
                            const optRgbForm = Composing.getCurrent(picker);
                            optRgbForm.fold(
                                function() {
                                    domGlobals.console.log('Can not find form');
                                },
                                function(rgbForm) {
                                    Representing.setValue(rgbForm, {
                                        hex: Option.from(m[1]).getOr(''),
                                    });
                                    Form.getField(rgbForm, 'hex').each(function(
                                        hexField,
                                    ) {
                                        emit(hexField, input());
                                    });
                                },
                            );
                        },
                    },
                }),
                ComposingConfigs.self(),
            ]),
        };
    };

    const global$a = tinymce.util.Tools.resolve('tinymce.Resource');

    const isOldCustomEditor = function(spec) {
        return Object.prototype.hasOwnProperty.call(spec, 'init');
    };
    const renderCustomEditor = function(spec) {
        const editorApi = Cell(Option.none());
        const memReplaced = record({ dom: { tag: spec.tag } });
        const initialValue = Cell(Option.none());
        return {
            dom: {
                tag: 'div',
                classes: ['tox-custom-editor'],
            },
            behaviours: derive$1([
                config('editor-foo-events', [
                    runOnAttached(function(component) {
                        memReplaced.getOpt(component).each(function(ta) {
                            (isOldCustomEditor(spec)
                                ? spec.init(ta.element().dom())
                                : global$a
                                      .load(spec.scriptId, spec.scriptUrl)
                                      .then(function(init) {
                                          return init(
                                              ta.element().dom(),
                                              spec.settings,
                                          );
                                      })
                            ).then(function(ea) {
                                initialValue.get().each(function(cvalue) {
                                    ea.setValue(cvalue);
                                });
                                initialValue.set(Option.none());
                                editorApi.set(Option.some(ea));
                            });
                        });
                    }),
                ]),
                Representing.config({
                    store: {
                        mode: 'manual',
                        getValue() {
                            return editorApi.get().fold(
                                function() {
                                    return initialValue.get().getOr('');
                                },
                                function(ed) {
                                    return ed.getValue();
                                },
                            );
                        },
                        setValue(component, value) {
                            editorApi.get().fold(
                                function() {
                                    initialValue.set(Option.some(value));
                                },
                                function(ed) {
                                    return ed.setValue(value);
                                },
                            );
                        },
                    },
                }),
                ComposingConfigs.self(),
            ]),
            components: [memReplaced.asSpec()],
        };
    };

    const processors = objOf([
        defaulted$1('preprocess', identity),
        defaulted$1('postprocess', identity),
    ]);
    const memento$1 = function(mem, rawProcessors) {
        const ps = asRawOrDie(
            'RepresentingConfigs.memento processors',
            processors,
            rawProcessors,
        );
        return Representing.config({
            store: {
                mode: 'manual',
                getValue(comp) {
                    const other = mem.get(comp);
                    const rawValue = Representing.getValue(other);
                    return ps.postprocess(rawValue);
                },
                setValue(comp, rawValue) {
                    const newValue = ps.preprocess(rawValue);
                    const other = mem.get(comp);
                    Representing.setValue(other, newValue);
                },
            },
        });
    };
    const withComp = function(optInitialValue, getter, setter) {
        return Representing.config(
            deepMerge(
                {
                    store: {
                        mode: 'manual',
                        getValue: getter,
                        setValue: setter,
                    },
                },
                optInitialValue
                    .map(function(initialValue) {
                        return { store: { initialValue } };
                    })
                    .getOr({}),
            ),
        );
    };
    const withElement = function(initialValue, getter, setter) {
        return withComp(
            initialValue,
            function(c) {
                return getter(c.element());
            },
            function(c, v) {
                return setter(c.element(), v);
            },
        );
    };
    const domValue = function(optInitialValue) {
        return withElement(optInitialValue, get$5, set$3);
    };
    const domHtml = function(optInitialValue) {
        return withElement(optInitialValue, get$1, set);
    };
    const memory$1 = function(initialValue) {
        return Representing.config({
            store: {
                mode: 'memory',
                initialValue,
            },
        });
    };
    const RepresentingConfigs = {
        memento: memento$1,
        withElement,
        withComp,
        domValue,
        domHtml,
        memory: memory$1,
    };

    const extensionsAccepted = '.jpg,.jpeg,.png,.gif';
    const filterByExtension = function(files) {
        const re = new RegExp(
            `(${extensionsAccepted.split(/\s*,\s*/).join('|')})$`,
            'i',
        );
        return filter(from$1(files), function(file) {
            return re.test(file.name);
        });
    };
    const renderDropZone = function(spec, providersBackstage) {
        const stopper = function(_, se) {
            se.stop();
        };
        const sequence = function(actions) {
            return function(comp, se) {
                each(actions, function(a) {
                    a(comp, se);
                });
            };
        };
        const onDrop = function(comp, se) {
            if (!Disabling.isDisabled(comp)) {
                const transferEvent = se.event().raw();
                handleFiles(comp, transferEvent.dataTransfer.files);
            }
        };
        const onSelect = function(component, simulatedEvent) {
            const { files } = simulatedEvent.event().raw().target;
            handleFiles(component, files);
        };
        var handleFiles = function(component, files) {
            Representing.setValue(component, filterByExtension(files));
            emitWith(component, formChangeEvent, { name: spec.name });
        };
        const memInput = record({
            dom: {
                tag: 'input',
                attributes: {
                    type: 'file',
                    accept: 'image/*',
                },
                styles: { display: 'none' },
            },
            behaviours: derive$1([
                config('input-file-events', [cutter(click()), cutter(tap())]),
            ]),
        });
        const renderField = function(s) {
            return {
                uid: s.uid,
                dom: {
                    tag: 'div',
                    classes: ['tox-dropzone-container'],
                },
                behaviours: derive$1([
                    RepresentingConfigs.memory([]),
                    ComposingConfigs.self(),
                    Disabling.config({}),
                    Toggling.config({
                        toggleClass: 'dragenter',
                        toggleOnExecute: false,
                    }),
                    config('dropzone-events', [
                        run('dragenter', sequence([stopper, Toggling.toggle])),
                        run('dragleave', sequence([stopper, Toggling.toggle])),
                        run('dragover', stopper),
                        run('drop', sequence([stopper, onDrop])),
                        run(change(), onSelect),
                    ]),
                ]),
                components: [
                    {
                        dom: {
                            tag: 'div',
                            classes: ['tox-dropzone'],
                            styles: {},
                        },
                        components: [
                            {
                                dom: {
                                    tag: 'p',
                                    innerHtml: providersBackstage.translate(
                                        'Drop an image here',
                                    ),
                                },
                            },
                            Button.sketch({
                                dom: {
                                    tag: 'button',
                                    innerHtml: providersBackstage.translate(
                                        'Browse for an image',
                                    ),
                                    styles: { position: 'relative' },
                                    classes: [
                                        'tox-button',
                                        'tox-button--secondary',
                                    ],
                                },
                                components: [memInput.asSpec()],
                                action(comp) {
                                    const inputComp = memInput.get(comp);
                                    inputComp
                                        .element()
                                        .dom()
                                        .click();
                                },
                                buttonBehaviours: derive$1([
                                    Tabstopping.config({}),
                                ]),
                            }),
                        ],
                    },
                ],
            };
        };
        const pLabel = spec.label.map(function(label) {
            return renderLabel(label, providersBackstage);
        });
        const pField = FormField.parts().field({
            factory: { sketch: renderField },
        });
        return renderFormFieldWith(
            pLabel,
            pField,
            ['tox-form__group--stretched'],
            [],
        );
    };

    const renderGrid = function(spec, backstage) {
        return {
            dom: {
                tag: 'div',
                classes: [
                    'tox-form__grid',
                    `tox-form__grid--${spec.columns}col`,
                ],
            },
            components: map(spec.items, backstage.interpreter),
        };
    };

    const beforeObject = generate$1('alloy-fake-before-tabstop');
    const afterObject = generate$1('alloy-fake-after-tabstop');
    const craftWithClasses = function(classes) {
        return {
            dom: {
                tag: 'div',
                styles: {
                    width: '1px',
                    height: '1px',
                    outline: 'none',
                },
                attributes: { tabindex: '0' },
                classes,
            },
            behaviours: derive$1([
                Focusing.config({ ignore: true }),
                Tabstopping.config({}),
            ]),
        };
    };
    const craft = function(spec) {
        return {
            dom: {
                tag: 'div',
                classes: ['tox-navobj'],
            },
            components: [
                craftWithClasses([beforeObject]),
                spec,
                craftWithClasses([afterObject]),
            ],
            behaviours: derive$1([ComposingConfigs.childAt(1)]),
        };
    };
    const triggerTab = function(placeholder, shiftKey) {
        emitWith(placeholder, keydown(), {
            raw: {
                which: 9,
                shiftKey,
            },
        });
    };
    const onFocus$1 = function(container, targetComp) {
        const target = targetComp.element();
        if (has$2(target, beforeObject)) {
            triggerTab(container, true);
        } else if (has$2(target, afterObject)) {
            triggerTab(container, false);
        }
    };
    const isPseudoStop = function(element) {
        return closest$4(
            element,
            [`.${beforeObject}`, `.${afterObject}`].join(','),
            constant(false),
        );
    };
    const NavigableObject = {
        isPseudoStop,
        onFocus: onFocus$1,
        craft,
    };

    const platformNeedsSandboxing = !(
        detect$3().browser.isIE() || detect$3().browser.isEdge()
    );
    const getDynamicSource = function(isSandbox) {
        const cachedValue = Cell('');
        return {
            getValue(frameComponent) {
                return cachedValue.get();
            },
            setValue(frameComponent, html) {
                if (!isSandbox) {
                    set$1(frameComponent.element(), 'src', "javascript:''");
                    const doc = frameComponent.element().dom().contentWindow
                        .document;
                    doc.open();
                    doc.write(html);
                    doc.close();
                } else {
                    set$1(frameComponent.element(), 'srcdoc', html);
                }
                cachedValue.set(html);
            },
        };
    };
    const renderIFrame = function(spec, providersBackstage) {
        const isSandbox = platformNeedsSandboxing && spec.sandboxed;
        const attributes = {
            ...spec.label
                .map(function(title) {
                    return { title };
                })
                .getOr({}),
            ...(isSandbox
                ? { sandbox: 'allow-scripts allow-same-origin' }
                : {}),
        };
        const sourcing = getDynamicSource(isSandbox);
        const pLabel = spec.label.map(function(label) {
            return renderLabel(label, providersBackstage);
        });
        const factory = function(newSpec) {
            return NavigableObject.craft({
                uid: newSpec.uid,
                dom: {
                    tag: 'iframe',
                    attributes,
                },
                behaviours: derive$1([
                    Tabstopping.config({}),
                    Focusing.config({}),
                    RepresentingConfigs.withComp(
                        Option.none(),
                        sourcing.getValue,
                        sourcing.setValue,
                    ),
                ]),
            });
        };
        const pField = FormField.parts().field({
            factory: { sketch: factory },
        });
        return renderFormFieldWith(
            pLabel,
            pField,
            ['tox-form__group--stretched'],
            [],
        );
    };

    function create$5(width, height) {
        return resize(
            domGlobals.document.createElement('canvas'),
            width,
            height,
        );
    }
    function clone$1(canvas) {
        const tCanvas = create$5(canvas.width, canvas.height);
        const ctx = get2dContext(tCanvas);
        ctx.drawImage(canvas, 0, 0);
        return tCanvas;
    }
    function get2dContext(canvas) {
        return canvas.getContext('2d');
    }
    function resize(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        return canvas;
    }

    function getWidth(image) {
        return image.naturalWidth || image.width;
    }
    function getHeight(image) {
        return image.naturalHeight || image.height;
    }

    const promise = function() {
        const Promise = function(fn) {
            if (typeof this !== 'object') {
                throw new TypeError('Promises must be constructed via new');
            }
            if (typeof fn !== 'function') {
                throw new TypeError('not a function');
            }
            this._state = null;
            this._value = null;
            this._deferreds = [];
            doResolve(fn, bind(resolve, this), bind(reject, this));
        };
        const asap =
            Promise.immediateFn ||
            (typeof window.setImmediate === 'function' &&
                window.setImmediate) ||
            function(fn) {
                domGlobals.setTimeout(fn, 1);
            };
        function bind(fn, thisArg) {
            return function() {
                return fn.apply(thisArg, arguments);
            };
        }
        const isArray =
            Array.isArray ||
            function(value) {
                return (
                    Object.prototype.toString.call(value) === '[object Array]'
                );
            };
        function handle(deferred) {
            const me = this;
            if (this._state === null) {
                this._deferreds.push(deferred);
                return;
            }
            asap(function() {
                const cb = me._state
                    ? deferred.onFulfilled
                    : deferred.onRejected;
                if (cb === null) {
                    (me._state ? deferred.resolve : deferred.reject)(me._value);
                    return;
                }
                let ret;
                try {
                    ret = cb(me._value);
                } catch (e) {
                    deferred.reject(e);
                    return;
                }
                deferred.resolve(ret);
            });
        }
        function resolve(newValue) {
            try {
                if (newValue === this) {
                    throw new TypeError(
                        'A promise cannot be resolved with itself.',
                    );
                }
                if (
                    newValue &&
                    (typeof newValue === 'object' ||
                        typeof newValue === 'function')
                ) {
                    const { then } = newValue;
                    if (typeof then === 'function') {
                        doResolve(
                            bind(then, newValue),
                            bind(resolve, this),
                            bind(reject, this),
                        );
                        return;
                    }
                }
                this._state = true;
                this._value = newValue;
                finale.call(this);
            } catch (e) {
                reject.call(this, e);
            }
        }
        function reject(newValue) {
            this._state = false;
            this._value = newValue;
            finale.call(this);
        }
        function finale() {
            for (let _i = 0, _a = this._deferreds; _i < _a.length; _i++) {
                const deferred = _a[_i];
                handle.call(this, deferred);
            }
            this._deferreds = [];
        }
        function Handler(onFulfilled, onRejected, resolve, reject) {
            this.onFulfilled =
                typeof onFulfilled === 'function' ? onFulfilled : null;
            this.onRejected =
                typeof onRejected === 'function' ? onRejected : null;
            this.resolve = resolve;
            this.reject = reject;
        }
        function doResolve(fn, onFulfilled, onRejected) {
            let done = false;
            try {
                fn(
                    function(value) {
                        if (done) {
                            return;
                        }
                        done = true;
                        onFulfilled(value);
                    },
                    function(reason) {
                        if (done) {
                            return;
                        }
                        done = true;
                        onRejected(reason);
                    },
                );
            } catch (ex) {
                if (done) {
                    return;
                }
                done = true;
                onRejected(ex);
            }
        }
        Promise.prototype.catch = function(onRejected) {
            return this.then(null, onRejected);
        };
        Promise.prototype.then = function(onFulfilled, onRejected) {
            const me = this;
            return new Promise(function(resolve, reject) {
                handle.call(
                    me,
                    new Handler(onFulfilled, onRejected, resolve, reject),
                );
            });
        };
        Promise.all = function() {
            const values = [];
            for (let _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            const args = Array.prototype.slice.call(
                values.length === 1 && isArray(values[0]) ? values[0] : values,
            );
            return new Promise(function(resolve, reject) {
                if (args.length === 0) {
                    return resolve([]);
                }
                let remaining = args.length;
                function res(i, val) {
                    try {
                        if (
                            val &&
                            (typeof val === 'object' ||
                                typeof val === 'function')
                        ) {
                            const { then } = val;
                            if (typeof then === 'function') {
                                then.call(
                                    val,
                                    function(val) {
                                        res(i, val);
                                    },
                                    reject,
                                );
                                return;
                            }
                        }
                        args[i] = val;
                        if (--remaining === 0) {
                            resolve(args);
                        }
                    } catch (ex) {
                        reject(ex);
                    }
                }
                for (let i = 0; i < args.length; i++) {
                    res(i, args[i]);
                }
            });
        };
        Promise.resolve = function(value) {
            if (
                value &&
                typeof value === 'object' &&
                value.constructor === Promise
            ) {
                return value;
            }
            return new Promise(function(resolve) {
                resolve(value);
            });
        };
        Promise.reject = function(reason) {
            return new Promise(function(resolve, reject) {
                reject(reason);
            });
        };
        Promise.race = function(values) {
            return new Promise(function(resolve, reject) {
                for (
                    let _i = 0, values_1 = values;
                    _i < values_1.length;
                    _i++
                ) {
                    const value = values_1[_i];
                    value.then(resolve, reject);
                }
            });
        };
        return Promise;
    };
    const Promise$1 = window.Promise ? window.Promise : promise();

    function blobToImage(blob) {
        return new Promise$1(function(resolve, reject) {
            const blobUrl = domGlobals.URL.createObjectURL(blob);
            const image = new domGlobals.Image();
            const removeListeners = function() {
                image.removeEventListener('load', loaded);
                image.removeEventListener('error', error);
            };
            function loaded() {
                removeListeners();
                resolve(image);
            }
            function error() {
                removeListeners();
                reject(`Unable to load data of type ${blob.type}: ${blobUrl}`);
            }
            image.addEventListener('load', loaded);
            image.addEventListener('error', error);
            image.src = blobUrl;
            if (image.complete) {
                loaded();
            }
        });
    }
    function dataUriToBlobSync(uri) {
        const data = uri.split(',');
        const matches = /data:([^;]+)/.exec(data[0]);
        if (!matches) {
            return Option.none();
        }
        const mimetype = matches[1];
        const base64 = data[1];
        const sliceSize = 1024;
        const byteCharacters = domGlobals.atob(base64);
        const bytesLength = byteCharacters.length;
        const slicesCount = Math.ceil(bytesLength / sliceSize);
        const byteArrays = new Array(slicesCount);
        for (let sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
            const begin = sliceIndex * sliceSize;
            const end = Math.min(begin + sliceSize, bytesLength);
            const bytes = new Array(end - begin);
            for (let offset = begin, i = 0; offset < end; ++i, ++offset) {
                bytes[i] = byteCharacters[offset].charCodeAt(0);
            }
            byteArrays[sliceIndex] = new Uint8Array(bytes);
        }
        return Option.some(new domGlobals.Blob(byteArrays, { type: mimetype }));
    }
    function dataUriToBlob(uri) {
        return new Promise$1(function(resolve, reject) {
            dataUriToBlobSync(uri).fold(function() {
                reject(`uri is not base64: ${uri}`);
            }, resolve);
        });
    }
    function canvasToBlob(canvas, type, quality) {
        type = type || 'image/png';
        if (domGlobals.HTMLCanvasElement.prototype.toBlob) {
            return new Promise$1(function(resolve, reject) {
                canvas.toBlob(
                    function(blob) {
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject();
                        }
                    },
                    type,
                    quality,
                );
            });
        }
        return dataUriToBlob(canvas.toDataURL(type, quality));
    }
    function canvasToDataURL(canvas, type, quality) {
        type = type || 'image/png';
        return canvas.toDataURL(type, quality);
    }
    function blobToCanvas(blob) {
        return blobToImage(blob).then(function(image) {
            revokeImageUrl(image);
            const canvas = create$5(getWidth(image), getHeight(image));
            const context = get2dContext(canvas);
            context.drawImage(image, 0, 0);
            return canvas;
        });
    }
    function blobToDataUri(blob) {
        return new Promise$1(function(resolve) {
            const reader = new domGlobals.FileReader();
            reader.onloadend = function() {
                resolve(reader.result);
            };
            reader.readAsDataURL(blob);
        });
    }
    function revokeImageUrl(image) {
        domGlobals.URL.revokeObjectURL(image.src);
    }

    function create$6(getCanvas, blob, uri) {
        const initialType = blob.type;
        const getType = constant(initialType);
        function toBlob() {
            return Promise$1.resolve(blob);
        }
        function toDataURL() {
            return uri;
        }
        function toBase64() {
            return uri.split(',')[1];
        }
        function toAdjustedBlob(type, quality) {
            return getCanvas.then(function(canvas) {
                return canvasToBlob(canvas, type, quality);
            });
        }
        function toAdjustedDataURL(type, quality) {
            return getCanvas.then(function(canvas) {
                return canvasToDataURL(canvas, type, quality);
            });
        }
        function toAdjustedBase64(type, quality) {
            return toAdjustedDataURL(type, quality).then(function(dataurl) {
                return dataurl.split(',')[1];
            });
        }
        function toCanvas() {
            return getCanvas.then(clone$1);
        }
        return {
            getType,
            toBlob,
            toDataURL,
            toBase64,
            toAdjustedBlob,
            toAdjustedDataURL,
            toAdjustedBase64,
            toCanvas,
        };
    }
    function fromBlob(blob) {
        return blobToDataUri(blob).then(function(uri) {
            return create$6(blobToCanvas(blob), blob, uri);
        });
    }
    function fromCanvas(canvas, type) {
        return canvasToBlob(canvas, type).then(function(blob) {
            return create$6(
                Promise$1.resolve(canvas),
                blob,
                canvas.toDataURL(),
            );
        });
    }

    const blobToImageResult = function(blob) {
        return fromBlob(blob);
    };

    function clamp(value, min, max) {
        let parsedValue = typeof value === 'string' ? parseFloat(value) : value;
        if (parsedValue > max) {
            parsedValue = max;
        } else if (parsedValue < min) {
            parsedValue = min;
        }
        return parsedValue;
    }
    function identity$1() {
        return [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
        ];
    }
    const DELTA_INDEX = [
        0,
        0.01,
        0.02,
        0.04,
        0.05,
        0.06,
        0.07,
        0.08,
        0.1,
        0.11,
        0.12,
        0.14,
        0.15,
        0.16,
        0.17,
        0.18,
        0.2,
        0.21,
        0.22,
        0.24,
        0.25,
        0.27,
        0.28,
        0.3,
        0.32,
        0.34,
        0.36,
        0.38,
        0.4,
        0.42,
        0.44,
        0.46,
        0.48,
        0.5,
        0.53,
        0.56,
        0.59,
        0.62,
        0.65,
        0.68,
        0.71,
        0.74,
        0.77,
        0.8,
        0.83,
        0.86,
        0.89,
        0.92,
        0.95,
        0.98,
        1,
        1.06,
        1.12,
        1.18,
        1.24,
        1.3,
        1.36,
        1.42,
        1.48,
        1.54,
        1.6,
        1.66,
        1.72,
        1.78,
        1.84,
        1.9,
        1.96,
        2,
        2.12,
        2.25,
        2.37,
        2.5,
        2.62,
        2.75,
        2.87,
        3,
        3.2,
        3.4,
        3.6,
        3.8,
        4,
        4.3,
        4.7,
        4.9,
        5,
        5.5,
        6,
        6.5,
        6.8,
        7,
        7.3,
        7.5,
        7.8,
        8,
        8.4,
        8.7,
        9,
        9.4,
        9.6,
        9.8,
        10,
    ];
    function multiply(matrix1, matrix2) {
        const col = [];
        const out = new Array(25);
        let val;
        for (let i = 0; i < 5; i++) {
            for (var j = 0; j < 5; j++) {
                col[j] = matrix2[j + i * 5];
            }
            for (var j = 0; j < 5; j++) {
                val = 0;
                for (let k = 0; k < 5; k++) {
                    val += matrix1[j + k * 5] * col[k];
                }
                out[j + i * 5] = val;
            }
        }
        return out;
    }
    function adjustContrast(matrix, value) {
        let x;
        value = clamp(value, -1, 1);
        value *= 100;
        if (value < 0) {
            x = 127 + (value / 100) * 127;
        } else {
            x = value % 1;
            if (x === 0) {
                x = DELTA_INDEX[value];
            } else {
                x =
                    DELTA_INDEX[Math.floor(value)] * (1 - x) +
                    DELTA_INDEX[Math.floor(value) + 1] * x;
            }
            x = x * 127 + 127;
        }
        return multiply(matrix, [
            x / 127,
            0,
            0,
            0,
            0.5 * (127 - x),
            0,
            x / 127,
            0,
            0,
            0.5 * (127 - x),
            0,
            0,
            x / 127,
            0,
            0.5 * (127 - x),
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
        ]);
    }
    function adjustBrightness(matrix, value) {
        value = clamp(255 * value, -255, 255);
        return multiply(matrix, [
            1,
            0,
            0,
            0,
            value,
            0,
            1,
            0,
            0,
            value,
            0,
            0,
            1,
            0,
            value,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
        ]);
    }
    function adjustColors(matrix, adjustR, adjustG, adjustB) {
        adjustR = clamp(adjustR, 0, 2);
        adjustG = clamp(adjustG, 0, 2);
        adjustB = clamp(adjustB, 0, 2);
        return multiply(matrix, [
            adjustR,
            0,
            0,
            0,
            0,
            0,
            adjustG,
            0,
            0,
            0,
            0,
            0,
            adjustB,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
        ]);
    }

    function colorFilter(ir, matrix) {
        return ir.toCanvas().then(function(canvas) {
            return applyColorFilter(canvas, ir.getType(), matrix);
        });
    }
    function applyColorFilter(canvas, type, matrix) {
        const context = get2dContext(canvas);
        function applyMatrix(pixelsData, m) {
            let r;
            let g;
            let b;
            let a;
            const { data } = pixelsData;
            const m0 = m[0];
            const m1 = m[1];
            const m2 = m[2];
            const m3 = m[3];
            const m4 = m[4];
            const m5 = m[5];
            const m6 = m[6];
            const m7 = m[7];
            const m8 = m[8];
            const m9 = m[9];
            const m10 = m[10];
            const m11 = m[11];
            const m12 = m[12];
            const m13 = m[13];
            const m14 = m[14];
            const m15 = m[15];
            const m16 = m[16];
            const m17 = m[17];
            const m18 = m[18];
            const m19 = m[19];
            for (let i = 0; i < data.length; i += 4) {
                r = data[i];
                g = data[i + 1];
                b = data[i + 2];
                a = data[i + 3];
                data[i] = r * m0 + g * m1 + b * m2 + a * m3 + m4;
                data[i + 1] = r * m5 + g * m6 + b * m7 + a * m8 + m9;
                data[i + 2] = r * m10 + g * m11 + b * m12 + a * m13 + m14;
                data[i + 3] = r * m15 + g * m16 + b * m17 + a * m18 + m19;
            }
            return pixelsData;
        }
        const pixels = applyMatrix(
            context.getImageData(0, 0, canvas.width, canvas.height),
            matrix,
        );
        context.putImageData(pixels, 0, 0);
        return fromCanvas(canvas, type);
    }
    function convoluteFilter(ir, matrix) {
        return ir.toCanvas().then(function(canvas) {
            return applyConvoluteFilter(canvas, ir.getType(), matrix);
        });
    }
    function applyConvoluteFilter(canvas, type, matrix) {
        const context = get2dContext(canvas);
        function applyMatrix(pIn, pOut, aMatrix) {
            function clamp(value, min, max) {
                if (value > max) {
                    value = max;
                } else if (value < min) {
                    value = min;
                }
                return value;
            }
            const side = Math.round(Math.sqrt(aMatrix.length));
            const halfSide = Math.floor(side / 2);
            const rgba = pIn.data;
            const drgba = pOut.data;
            const w = pIn.width;
            const h = pIn.height;
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    let r = 0;
                    let g = 0;
                    let b = 0;
                    for (let cy = 0; cy < side; cy++) {
                        for (let cx = 0; cx < side; cx++) {
                            const scx = clamp(x + cx - halfSide, 0, w - 1);
                            const scy = clamp(y + cy - halfSide, 0, h - 1);
                            const innerOffset = (scy * w + scx) * 4;
                            const wt = aMatrix[cy * side + cx];
                            r += rgba[innerOffset] * wt;
                            g += rgba[innerOffset + 1] * wt;
                            b += rgba[innerOffset + 2] * wt;
                        }
                    }
                    const offset = (y * w + x) * 4;
                    drgba[offset] = clamp(r, 0, 255);
                    drgba[offset + 1] = clamp(g, 0, 255);
                    drgba[offset + 2] = clamp(b, 0, 255);
                }
            }
            return pOut;
        }
        const pixelsIn = context.getImageData(
            0,
            0,
            canvas.width,
            canvas.height,
        );
        let pixelsOut = context.getImageData(0, 0, canvas.width, canvas.height);
        pixelsOut = applyMatrix(pixelsIn, pixelsOut, matrix);
        context.putImageData(pixelsOut, 0, 0);
        return fromCanvas(canvas, type);
    }
    function functionColorFilter(colorFn) {
        const filterImpl = function(canvas, type, value) {
            const context = get2dContext(canvas);
            const lookup = new Array(256);
            function applyLookup(pixelsData, lookupData) {
                const { data } = pixelsData;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = lookupData[data[i]];
                    data[i + 1] = lookupData[data[i + 1]];
                    data[i + 2] = lookupData[data[i + 2]];
                }
                return pixelsData;
            }
            for (let i = 0; i < lookup.length; i++) {
                lookup[i] = colorFn(i, value);
            }
            const pixels = applyLookup(
                context.getImageData(0, 0, canvas.width, canvas.height),
                lookup,
            );
            context.putImageData(pixels, 0, 0);
            return fromCanvas(canvas, type);
        };
        return function(ir, value) {
            return ir.toCanvas().then(function(canvas) {
                return filterImpl(canvas, ir.getType(), value);
            });
        };
    }
    function complexAdjustableColorFilter(matrixAdjustFn) {
        return function(ir, adjust) {
            return colorFilter(ir, matrixAdjustFn(identity$1(), adjust));
        };
    }
    function basicColorFilter(matrix) {
        return function(ir) {
            return colorFilter(ir, matrix);
        };
    }
    function basicConvolutionFilter(kernel) {
        return function(ir) {
            return convoluteFilter(ir, kernel);
        };
    }
    const invert = basicColorFilter([
        -1,
        0,
        0,
        0,
        255,
        0,
        -1,
        0,
        0,
        255,
        0,
        0,
        -1,
        0,
        255,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
    ]);
    const brightness = complexAdjustableColorFilter(adjustBrightness);
    const contrast = complexAdjustableColorFilter(adjustContrast);
    const colorize = function(ir, adjustR, adjustG, adjustB) {
        return colorFilter(
            ir,
            adjustColors(identity$1(), adjustR, adjustG, adjustB),
        );
    };
    const sharpen = basicConvolutionFilter([0, -1, 0, -1, 5, -1, 0, -1, 0]);
    const gamma = functionColorFilter(function(color, value) {
        return Math.pow(color / 255, 1 - value) * 255;
    });

    function scale(image, dW, dH) {
        const sW = getWidth(image);
        const sH = getHeight(image);
        let wRatio = dW / sW;
        let hRatio = dH / sH;
        let scaleCapped = false;
        if (wRatio < 0.5 || wRatio > 2) {
            wRatio = wRatio < 0.5 ? 0.5 : 2;
            scaleCapped = true;
        }
        if (hRatio < 0.5 || hRatio > 2) {
            hRatio = hRatio < 0.5 ? 0.5 : 2;
            scaleCapped = true;
        }
        const scaled = _scale(image, wRatio, hRatio);
        return !scaleCapped
            ? scaled
            : scaled.then(function(tCanvas) {
                  return scale(tCanvas, dW, dH);
              });
    }
    function _scale(image, wRatio, hRatio) {
        return new Promise$1(function(resolve) {
            const sW = getWidth(image);
            const sH = getHeight(image);
            const dW = Math.floor(sW * wRatio);
            const dH = Math.floor(sH * hRatio);
            const canvas = create$5(dW, dH);
            const context = get2dContext(canvas);
            context.drawImage(image, 0, 0, sW, sH, 0, 0, dW, dH);
            resolve(canvas);
        });
    }

    function rotate(ir, angle) {
        return ir.toCanvas().then(function(canvas) {
            return applyRotate(canvas, ir.getType(), angle);
        });
    }
    function applyRotate(image, type, angle) {
        const canvas = create$5(image.width, image.height);
        const context = get2dContext(canvas);
        let translateX = 0;
        let translateY = 0;
        angle = angle < 0 ? 360 + angle : angle;
        if (angle === 90 || angle === 270) {
            resize(canvas, canvas.height, canvas.width);
        }
        if (angle === 90 || angle === 180) {
            translateX = canvas.width;
        }
        if (angle === 270 || angle === 180) {
            translateY = canvas.height;
        }
        context.translate(translateX, translateY);
        context.rotate((angle * Math.PI) / 180);
        context.drawImage(image, 0, 0);
        return fromCanvas(canvas, type);
    }
    function flip(ir, axis) {
        return ir.toCanvas().then(function(canvas) {
            return applyFlip(canvas, ir.getType(), axis);
        });
    }
    function applyFlip(image, type, axis) {
        const canvas = create$5(image.width, image.height);
        const context = get2dContext(canvas);
        if (axis === 'v') {
            context.scale(1, -1);
            context.drawImage(image, 0, -canvas.height);
        } else {
            context.scale(-1, 1);
            context.drawImage(image, -canvas.width, 0);
        }
        return fromCanvas(canvas, type);
    }
    function crop(ir, x, y, w, h) {
        return ir.toCanvas().then(function(canvas) {
            return applyCrop(canvas, ir.getType(), x, y, w, h);
        });
    }
    function applyCrop(image, type, x, y, w, h) {
        const canvas = create$5(w, h);
        const context = get2dContext(canvas);
        context.drawImage(image, -x, -y);
        return fromCanvas(canvas, type);
    }
    function resize$1(ir, w, h) {
        return ir.toCanvas().then(function(canvas) {
            return scale(canvas, w, h).then(function(newCanvas) {
                return fromCanvas(newCanvas, ir.getType());
            });
        });
    }

    const invert$1 = function(ir) {
        return invert(ir);
    };
    const sharpen$1 = function(ir) {
        return sharpen(ir);
    };
    const gamma$1 = function(ir, value) {
        return gamma(ir, value);
    };
    const colorize$1 = function(ir, adjustR, adjustG, adjustB) {
        return colorize(ir, adjustR, adjustG, adjustB);
    };
    const brightness$1 = function(ir, adjust) {
        return brightness(ir, adjust);
    };
    const contrast$1 = function(ir, adjust) {
        return contrast(ir, adjust);
    };
    const flip$1 = function(ir, axis) {
        return flip(ir, axis);
    };
    const crop$1 = function(ir, x, y, w, h) {
        return crop(ir, x, y, w, h);
    };
    const resize$2 = function(ir, w, h) {
        return resize$1(ir, w, h);
    };
    const rotate$1 = function(ir, angle) {
        return rotate(ir, angle);
    };

    const renderIcon$1 = function(iconHtml, behaviours) {
        return {
            dom: {
                tag: 'span',
                innerHtml: iconHtml,
                classes: ['tox-icon', 'tox-tbtn__icon-wrap'],
            },
            ...behaviours,
        };
    };
    const renderIconFromPack = function(iconName, iconsProvider) {
        return renderIcon$1(get$c(iconName, iconsProvider), {});
    };
    const renderReplacableIconFromPack = function(iconName, iconsProvider) {
        return renderIcon$1(get$c(iconName, iconsProvider), {
            behaviours: derive$1([Replacing.config({})]),
        });
    };
    const renderLabel$1 = function(text, prefix, providersBackstage) {
        return {
            dom: {
                tag: 'span',
                innerHtml: providersBackstage.translate(text),
                classes: [`${prefix}__select-label`],
            },
            behaviours: derive$1([Replacing.config({})]),
        };
    };

    const internalToolbarButtonExecute = generate$1('toolbar.button.execute');
    const onToolbarButtonExecute = function(info) {
        return runOnExecute(function(comp, simulatedEvent) {
            runWithApi(
                info,
                comp,
            )(function(itemApi) {
                emitWith(comp, internalToolbarButtonExecute, {
                    buttonApi: itemApi,
                });
                info.onAction(itemApi);
            });
        });
    };
    const toolbarButtonEventOrder = {
        'alloy.execute': [
            'disabling',
            'alloy.base.behaviour',
            'toggling',
            'toolbar-button-events',
        ],
    };

    const updateMenuText = generate$1('update-menu-text');
    const updateMenuIcon = generate$1('update-menu-icon');
    const renderCommonDropdown = function(spec, prefix, sharedBackstage) {
        const editorOffCell = Cell(noop);
        const optMemDisplayText = spec.text.map(function(text) {
            return record(
                renderLabel$1(text, prefix, sharedBackstage.providers),
            );
        });
        const optMemDisplayIcon = spec.icon.map(function(iconName) {
            return record(
                renderReplacableIconFromPack(
                    iconName,
                    sharedBackstage.providers.icons,
                ),
            );
        });
        const onLeftOrRightInMenu = function(comp, se) {
            const dropdown = Representing.getValue(comp);
            Focusing.focus(dropdown);
            emitWith(dropdown, 'keydown', { raw: se.event().raw() });
            Dropdown.close(dropdown);
            return Option.some(true);
        };
        const role = spec.role.fold(
            function() {
                return {};
            },
            function(role) {
                return { role };
            },
        );
        const tooltipAttributes = spec.tooltip.fold(
            function() {
                return {};
            },
            function(tooltip) {
                const translatedTooltip = sharedBackstage.providers.translate(
                    tooltip,
                );
                return {
                    title: translatedTooltip,
                    'aria-label': translatedTooltip,
                };
            },
        );
        const memDropdown = record(
            Dropdown.sketch({
                ...role,
                dom: {
                    tag: 'button',
                    classes: [prefix, `${prefix}--select`].concat(
                        map(spec.classes, function(c) {
                            return `${prefix}--${c}`;
                        }),
                    ),
                    attributes: { ...tooltipAttributes },
                },
                components: componentRenderPipeline([
                    optMemDisplayIcon.map(function(mem) {
                        return mem.asSpec();
                    }),
                    optMemDisplayText.map(function(mem) {
                        return mem.asSpec();
                    }),
                    Option.some({
                        dom: {
                            tag: 'div',
                            classes: [`${prefix}__select-chevron`],
                            innerHtml: get$c(
                                'chevron-down',
                                sharedBackstage.providers.icons,
                            ),
                        },
                    }),
                ]),
                matchWidth: true,
                useMinWidth: true,
                dropdownBehaviours: derive$1(
                    __spreadArrays(spec.dropdownBehaviours, [
                        DisablingConfigs.button(spec.disabled),
                        Unselecting.config({}),
                        Replacing.config({}),
                        config('dropdown-events', [
                            onControlAttached(spec, editorOffCell),
                            onControlDetached(spec, editorOffCell),
                        ]),
                        config('menubutton-update-display-text', [
                            run(updateMenuText, function(comp, se) {
                                optMemDisplayText
                                    .bind(function(mem) {
                                        return mem.getOpt(comp);
                                    })
                                    .each(function(displayText) {
                                        Replacing.set(displayText, [
                                            text(
                                                sharedBackstage.providers.translate(
                                                    se.event().text(),
                                                ),
                                            ),
                                        ]);
                                    });
                            }),
                            run(updateMenuIcon, function(comp, se) {
                                optMemDisplayIcon
                                    .bind(function(mem) {
                                        return mem.getOpt(comp);
                                    })
                                    .each(function(displayIcon) {
                                        Replacing.set(displayIcon, [
                                            renderReplacableIconFromPack(
                                                se.event().icon(),
                                                sharedBackstage.providers.icons,
                                            ),
                                        ]);
                                    });
                            }),
                        ]),
                    ]),
                ),
                eventOrder: deepMerge(toolbarButtonEventOrder, {
                    mousedown: [
                        'focusing',
                        'alloy.base.behaviour',
                        'item-type-events',
                        'normal-dropdown-events',
                    ],
                }),
                sandboxBehaviours: derive$1([
                    Keying.config({
                        mode: 'special',
                        onLeft: onLeftOrRightInMenu,
                        onRight: onLeftOrRightInMenu,
                    }),
                ]),
                lazySink: sharedBackstage.getSink,
                toggleClass: `${prefix}--active`,
                parts: { menu: part(false, spec.columns, spec.presets) },
                fetch() {
                    return Future.nu(spec.fetch);
                },
            }),
        );
        return memDropdown.asSpec();
    };

    const isMenuItemReference = function(item) {
        return isString(item);
    };
    const isSeparator = function(item) {
        return item.type === 'separator';
    };
    const isExpandingMenuItem = function(item) {
        return has(item, 'getSubmenuItems');
    };
    const separator$1 = { type: 'separator' };
    const unwrapReferences = function(items, menuItems) {
        const realItems = foldl(
            items,
            function(acc, item) {
                if (isMenuItemReference(item)) {
                    if (item === '') {
                        return acc;
                    }
                    if (item === '|') {
                        return acc.length > 0 &&
                            !isSeparator(acc[acc.length - 1])
                            ? acc.concat([separator$1])
                            : acc;
                    }
                    if (has(menuItems, item.toLowerCase())) {
                        return acc.concat([menuItems[item.toLowerCase()]]);
                    }
                    return acc;
                }
                return acc.concat([item]);
            },
            [],
        );
        if (
            realItems.length > 0 &&
            isSeparator(realItems[realItems.length - 1])
        ) {
            realItems.pop();
        }
        return realItems;
    };
    const getFromExpandingItem = function(item, menuItems) {
        const submenuItems = item.getSubmenuItems();
        const rest = expand(submenuItems, menuItems);
        const newMenus = deepMerge(rest.menus, wrap$1(item.value, rest.items));
        const newExpansions = deepMerge(
            rest.expansions,
            wrap$1(item.value, item.value),
        );
        return {
            item,
            menus: newMenus,
            expansions: newExpansions,
        };
    };
    const getFromItem = function(item, menuItems) {
        return isExpandingMenuItem(item)
            ? getFromExpandingItem(item, menuItems)
            : {
                  item,
                  menus: {},
                  expansions: {},
              };
    };
    const generateValueIfRequired = function(item) {
        if (isSeparator(item)) {
            return item;
        }
        const itemValue = readOptFrom$1(item, 'value').getOrThunk(function() {
            return generate$1('generated-menu-item');
        });
        return deepMerge({ value: itemValue }, item);
    };
    var expand = function(items, menuItems) {
        const realItems = unwrapReferences(
            isString(items) ? items.split(' ') : items,
            menuItems,
        );
        return foldr(
            realItems,
            function(acc, item) {
                const itemWithValue = generateValueIfRequired(item);
                const newData = getFromItem(itemWithValue, menuItems);
                return {
                    menus: deepMerge(acc.menus, newData.menus),
                    items: [newData.item].concat(acc.items),
                    expansions: deepMerge(acc.expansions, newData.expansions),
                };
            },
            {
                menus: {},
                expansions: {},
                items: [],
            },
        );
    };

    const build$2 = function(items, itemResponse, backstage, isHorizontalMenu) {
        const primary = generate$1('primary-menu');
        const data = expand(items, backstage.shared.providers.menuItems());
        if (data.items.length === 0) {
            return Option.none();
        }
        const mainMenu = createPartialMenu(
            primary,
            data.items,
            itemResponse,
            backstage,
            isHorizontalMenu,
        );
        const submenus = map$1(data.menus, function(menuItems, menuName) {
            return createPartialMenu(
                menuName,
                menuItems,
                itemResponse,
                backstage,
                false,
            );
        });
        const menus = deepMerge(submenus, wrap$1(primary, mainMenu));
        return Option.from(
            tieredMenu.tieredData(primary, menus, data.expansions),
        );
    };

    const getMenuButtonApi = function(component) {
        return {
            isDisabled() {
                return Disabling.isDisabled(component);
            },
            setDisabled(state) {
                return Disabling.set(component, state);
            },
            setActive(state) {
                const elm = component.element();
                if (state) {
                    add$2(elm, 'tox-tbtn--enabled');
                    set$1(elm, 'aria-pressed', true);
                } else {
                    remove$4(elm, 'tox-tbtn--enabled');
                    remove$1(elm, 'aria-pressed');
                }
            },
            isActive() {
                return has$2(component.element(), 'tox-tbtn--enabled');
            },
        };
    };
    const renderMenuButton = function(spec, prefix, backstage, role) {
        return renderCommonDropdown(
            {
                text: spec.text,
                icon: spec.icon,
                tooltip: spec.tooltip,
                role,
                fetch(callback) {
                    spec.fetch(function(items) {
                        callback(
                            build$2(
                                items,
                                ItemResponse$1.CLOSE_ON_EXECUTE,
                                backstage,
                                false,
                            ),
                        );
                    });
                },
                onSetup: spec.onSetup,
                getApi: getMenuButtonApi,
                columns: 1,
                presets: 'normal',
                classes: [],
                dropdownBehaviours: [Tabstopping.config({})],
            },
            prefix,
            backstage.shared,
        );
    };
    const getFetch$1 = function(items, getButton, backstage) {
        const getMenuItemAction = function(item) {
            return function(api) {
                const newValue = !api.isActive();
                api.setActive(newValue);
                item.storage.set(newValue);
                backstage.shared.getSink().each(function(sink) {
                    getButton()
                        .getOpt(sink)
                        .each(function(orig) {
                            focus$1(orig.element());
                            emitWith(orig, formActionEvent, {
                                name: item.name,
                                value: item.storage.get(),
                            });
                        });
                });
            };
        };
        const getMenuItemSetup = function(item) {
            return function(api) {
                api.setActive(item.storage.get());
            };
        };
        return function(success) {
            success(
                map(items, function(item) {
                    const text = item.text.fold(
                        function() {
                            return {};
                        },
                        function(text) {
                            return { text };
                        },
                    );
                    return {
                        type: item.type,
                        ...text,
                        onAction: getMenuItemAction(item),
                        onSetup: getMenuItemSetup(item),
                    };
                }),
            );
        };
    };

    const renderCommonSpec = function(
        spec,
        actionOpt,
        extraBehaviours,
        dom,
        components,
    ) {
        if (extraBehaviours === void 0) {
            extraBehaviours = [];
        }
        const action = actionOpt.fold(
            function() {
                return {};
            },
            function(action) {
                return { action };
            },
        );
        const common = {
            buttonBehaviours: derive$1(
                [
                    DisablingConfigs.button(spec.disabled),
                    Tabstopping.config({}),
                    config('button press', [
                        preventDefault('click'),
                        preventDefault('mousedown'),
                    ]),
                ].concat(extraBehaviours),
            ),
            eventOrder: {
                click: ['button press', 'alloy.base.behaviour'],
                mousedown: ['button press', 'alloy.base.behaviour'],
            },
            ...action,
        };
        const domFinal = deepMerge(common, { dom });
        return deepMerge(domFinal, { components });
    };
    const renderIconButtonSpec = function(
        spec,
        action,
        providersBackstage,
        extraBehaviours,
    ) {
        if (extraBehaviours === void 0) {
            extraBehaviours = [];
        }
        const tooltipAttributes = spec.tooltip
            .map(function(tooltip) {
                return {
                    'aria-label': providersBackstage.translate(tooltip),
                    title: providersBackstage.translate(tooltip),
                };
            })
            .getOr({});
        const dom = {
            tag: 'button',
            classes: ['tox-tbtn'],
            attributes: tooltipAttributes,
        };
        const icon = spec.icon.map(function(iconName) {
            return renderIconFromPack(iconName, providersBackstage.icons);
        });
        const components = componentRenderPipeline([icon]);
        return renderCommonSpec(spec, action, extraBehaviours, dom, components);
    };
    const renderIconButton = function(
        spec,
        action,
        providersBackstage,
        extraBehaviours,
    ) {
        if (extraBehaviours === void 0) {
            extraBehaviours = [];
        }
        const iconButtonSpec = renderIconButtonSpec(
            spec,
            Option.some(action),
            providersBackstage,
            extraBehaviours,
        );
        return Button.sketch(iconButtonSpec);
    };
    const renderButtonSpec = function(
        spec,
        action,
        providersBackstage,
        extraBehaviours,
        extraClasses,
    ) {
        if (extraBehaviours === void 0) {
            extraBehaviours = [];
        }
        if (extraClasses === void 0) {
            extraClasses = [];
        }
        const translatedText = providersBackstage.translate(spec.text);
        const icon = spec.icon
            ? spec.icon.map(function(iconName) {
                  return renderIconFromPack(iconName, providersBackstage.icons);
              })
            : Option.none();
        const components = icon.isSome() ? componentRenderPipeline([icon]) : [];
        const innerHtml = icon.isSome() ? {} : { innerHtml: translatedText };
        const classes = __spreadArrays(
            !spec.primary && !spec.borderless
                ? ['tox-button', 'tox-button--secondary']
                : ['tox-button'],
            icon.isSome() ? ['tox-button--icon'] : [],
            spec.borderless ? ['tox-button--naked'] : [],
            extraClasses,
        );
        const dom = {
            tag: 'button',
            classes,
            ...innerHtml,
            attributes: { title: translatedText },
        };
        return renderCommonSpec(spec, action, extraBehaviours, dom, components);
    };
    const renderButton = function(
        spec,
        action,
        providersBackstage,
        extraBehaviours,
        extraClasses,
    ) {
        if (extraBehaviours === void 0) {
            extraBehaviours = [];
        }
        if (extraClasses === void 0) {
            extraClasses = [];
        }
        const buttonSpec = renderButtonSpec(
            spec,
            Option.some(action),
            providersBackstage,
            extraBehaviours,
            extraClasses,
        );
        return Button.sketch(buttonSpec);
    };
    const getAction = function(name, buttonType) {
        return function(comp) {
            if (buttonType === 'custom') {
                emitWith(comp, formActionEvent, {
                    name,
                    value: {},
                });
            } else if (buttonType === 'submit') {
                emit(comp, formSubmitEvent);
            } else if (buttonType === 'cancel') {
                emit(comp, formCancelEvent);
            } else {
                domGlobals.console.error('Unknown button type: ', buttonType);
            }
        };
    };
    const isMenuFooterButtonSpec = function(spec, buttonType) {
        return buttonType === 'menu';
    };
    const isNormalFooterButtonSpec = function(spec, buttonType) {
        return (
            buttonType === 'custom' ||
            buttonType === 'cancel' ||
            buttonType === 'submit'
        );
    };
    const renderFooterButton = function(spec, buttonType, backstage) {
        if (isMenuFooterButtonSpec(spec, buttonType)) {
            const getButton = function() {
                return memButton_1;
            };
            const menuButtonSpec = spec;
            const fixedSpec = {
                ...spec,
                fetch: getFetch$1(menuButtonSpec.items, getButton, backstage),
            };
            var memButton_1 = record(
                renderMenuButton(
                    fixedSpec,
                    'tox-tbtn',
                    backstage,
                    Option.none(),
                ),
            );
            return memButton_1.asSpec();
        }
        if (isNormalFooterButtonSpec(spec, buttonType)) {
            const action = getAction(spec.name, buttonType);
            const buttonSpec = { ...spec, borderless: false };
            return renderButton(
                buttonSpec,
                action,
                backstage.shared.providers,
                [],
            );
        }
        domGlobals.console.error('Unknown footer button type: ', buttonType);
    };
    const renderDialogButton = function(spec, providersBackstage) {
        const action = getAction(spec.name, 'custom');
        return renderFormField(
            Option.none(),
            FormField.parts().field({
                factory: Button,
                ...renderButtonSpec(
                    spec,
                    Option.some(action),
                    providersBackstage,
                    [RepresentingConfigs.memory(''), ComposingConfigs.self()],
                ),
            }),
        );
    };

    const schema$i = constant([
        defaulted$1('field1Name', 'field1'),
        defaulted$1('field2Name', 'field2'),
        onStrictHandler('onLockedChange'),
        markers(['lockClass']),
        defaulted$1('locked', false),
        SketchBehaviours.field('coupledFieldBehaviours', [
            Composing,
            Representing,
        ]),
    ]);
    const getField = function(comp, detail, partName) {
        return getPart(comp, detail, partName).bind(Composing.getCurrent);
    };
    const coupledPart = function(selfName, otherName) {
        return required({
            factory: FormField,
            name: selfName,
            overrides(detail) {
                return {
                    fieldBehaviours: derive$1([
                        config('coupled-input-behaviour', [
                            run(input(), function(me) {
                                getField(me, detail, otherName).each(function(
                                    other,
                                ) {
                                    getPart(me, detail, 'lock').each(function(
                                        lock,
                                    ) {
                                        if (Toggling.isOn(lock)) {
                                            detail.onLockedChange(
                                                me,
                                                other,
                                                lock,
                                            );
                                        }
                                    });
                                });
                            }),
                        ]),
                    ]),
                };
            },
        });
    };
    const parts$5 = constant([
        coupledPart('field1', 'field2'),
        coupledPart('field2', 'field1'),
        required({
            factory: Button,
            schema: [strict$1('dom')],
            name: 'lock',
            overrides(detail) {
                return {
                    buttonBehaviours: derive$1([
                        Toggling.config({
                            selected: detail.locked,
                            toggleClass: detail.markers.lockClass,
                            aria: { mode: 'pressed' },
                        }),
                    ]),
                };
            },
        }),
    ]);

    const factory$7 = function(detail, components, spec, externals) {
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: SketchBehaviours.augment(
                detail.coupledFieldBehaviours,
                [
                    Composing.config({ find: Option.some }),
                    Representing.config({
                        store: {
                            mode: 'manual',
                            getValue(comp) {
                                let _a;
                                const parts = getPartsOrDie(comp, detail, [
                                    'field1',
                                    'field2',
                                ]);
                                return (
                                    (_a = {}),
                                    (_a[
                                        detail.field1Name
                                    ] = Representing.getValue(parts.field1())),
                                    (_a[
                                        detail.field2Name
                                    ] = Representing.getValue(parts.field2())),
                                    _a
                                );
                            },
                            setValue(comp, value) {
                                const parts = getPartsOrDie(comp, detail, [
                                    'field1',
                                    'field2',
                                ]);
                                if (hasKey$1(value, detail.field1Name)) {
                                    Representing.setValue(
                                        parts.field1(),
                                        value[detail.field1Name],
                                    );
                                }
                                if (hasKey$1(value, detail.field2Name)) {
                                    Representing.setValue(
                                        parts.field2(),
                                        value[detail.field2Name],
                                    );
                                }
                            },
                        },
                    }),
                ],
            ),
            apis: {
                getField1(component) {
                    return getPart(component, detail, 'field1');
                },
                getField2(component) {
                    return getPart(component, detail, 'field2');
                },
                getLock(component) {
                    return getPart(component, detail, 'lock');
                },
            },
        };
    };
    const FormCoupledInputs = composite$1({
        name: 'FormCoupledInputs',
        configFields: schema$i(),
        partFields: parts$5(),
        factory: factory$7,
        apis: {
            getField1(apis, component) {
                return apis.getField1(component);
            },
            getField2(apis, component) {
                return apis.getField2(component);
            },
            getLock(apis, component) {
                return apis.getLock(component);
            },
        },
    });

    const formatSize = function(size) {
        const unitDec = {
            '': 0,
            px: 0,
            pt: 1,
            mm: 1,
            pc: 2,
            ex: 2,
            em: 2,
            ch: 2,
            rem: 2,
            cm: 3,
            in: 4,
            '%': 4,
        };
        const maxDecimal = function(unit) {
            return unit in unitDec ? unitDec[unit] : 1;
        };
        let numText = size.value.toFixed(maxDecimal(size.unit));
        if (numText.indexOf('.') !== -1) {
            numText = numText.replace(/\.?0*$/, '');
        }
        return numText + size.unit;
    };
    const parseSize = function(sizeText) {
        const numPattern = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/;
        const match = numPattern.exec(sizeText);
        if (match !== null) {
            const value = parseFloat(match[1]);
            const unit = match[2];
            return Result.value({
                value,
                unit,
            });
        }
        return Result.error(sizeText);
    };
    const convertUnit = function(size, unit) {
        const inInch = {
            '': 96,
            px: 96,
            pt: 72,
            cm: 2.54,
            pc: 12,
            mm: 25.4,
            in: 1,
        };
        const supported = function(u) {
            return Object.prototype.hasOwnProperty.call(inInch, u);
        };
        if (size.unit === unit) {
            return Option.some(size.value);
        }
        if (supported(size.unit) && supported(unit)) {
            if (inInch[size.unit] === inInch[unit]) {
                return Option.some(size.value);
            }
            return Option.some((size.value / inInch[size.unit]) * inInch[unit]);
        }
        return Option.none();
    };
    const noSizeConversion = function(input) {
        return Option.none();
    };
    const ratioSizeConversion = function(scale, unit) {
        return function(size) {
            return convertUnit(size, unit).map(function(value) {
                return {
                    value: value * scale,
                    unit,
                };
            });
        };
    };
    const makeRatioConverter = function(currentFieldText, otherFieldText) {
        const cValue = parseSize(currentFieldText).toOption();
        const oValue = parseSize(otherFieldText).toOption();
        return lift2(cValue, oValue, function(cSize, oSize) {
            return convertUnit(cSize, oSize.unit)
                .map(function(val) {
                    return oSize.value / val;
                })
                .map(function(r) {
                    return ratioSizeConversion(r, oSize.unit);
                })
                .getOr(noSizeConversion);
        }).getOr(noSizeConversion);
    };

    const renderSizeInput = function(spec, providersBackstage) {
        let converter = noSizeConversion;
        const ratioEvent = generate$1('ratio-event');
        const pLock = FormCoupledInputs.parts().lock({
            dom: {
                tag: 'button',
                classes: [
                    'tox-lock',
                    'tox-button',
                    'tox-button--naked',
                    'tox-button--icon',
                ],
                attributes: {
                    title: providersBackstage.translate(
                        spec.label.getOr('Constrain proportions'),
                    ),
                },
            },
            components: [
                {
                    dom: {
                        tag: 'span',
                        classes: ['tox-icon', 'tox-lock-icon__lock'],
                        innerHtml: get$c('lock', providersBackstage.icons),
                    },
                },
                {
                    dom: {
                        tag: 'span',
                        classes: ['tox-icon', 'tox-lock-icon__unlock'],
                        innerHtml: get$c('unlock', providersBackstage.icons),
                    },
                },
            ],
            buttonBehaviours: derive$1([
                DisablingConfigs.button(spec.disabled),
                Tabstopping.config({}),
            ]),
        });
        const formGroup = function(components) {
            return {
                dom: {
                    tag: 'div',
                    classes: ['tox-form__group'],
                },
                components,
            };
        };
        const getFieldPart = function(isField1) {
            return FormField.parts().field({
                factory: Input,
                inputClasses: ['tox-textfield'],
                inputBehaviours: derive$1([
                    Disabling.config({ disabled: spec.disabled }),
                    Tabstopping.config({}),
                    config('size-input-events', [
                        run(focusin(), function(component, simulatedEvent) {
                            emitWith(component, ratioEvent, {
                                isField1,
                            });
                        }),
                        run(change(), function(component, simulatedEvent) {
                            emitWith(component, formChangeEvent, {
                                name: spec.name,
                            });
                        }),
                    ]),
                ]),
                selectOnFocus: false,
            });
        };
        const getLabel = function(label) {
            return {
                dom: {
                    tag: 'label',
                    classes: ['tox-label'],
                    innerHtml: providersBackstage.translate(label),
                },
            };
        };
        const widthField = FormCoupledInputs.parts().field1(
            formGroup([
                FormField.parts().label(getLabel('Width')),
                getFieldPart(true),
            ]),
        );
        const heightField = FormCoupledInputs.parts().field2(
            formGroup([
                FormField.parts().label(getLabel('Height')),
                getFieldPart(false),
            ]),
        );
        return FormCoupledInputs.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-form__group'],
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-form__controls-h-stack'],
                    },
                    components: [
                        widthField,
                        heightField,
                        formGroup([getLabel('&nbsp;'), pLock]),
                    ],
                },
            ],
            field1Name: 'width',
            field2Name: 'height',
            locked: true,
            markers: { lockClass: 'tox-locked' },
            onLockedChange(current, other, lock) {
                parseSize(Representing.getValue(current)).each(function(size) {
                    converter(size).each(function(newSize) {
                        Representing.setValue(other, formatSize(newSize));
                    });
                });
            },
            coupledFieldBehaviours: derive$1([
                Disabling.config({
                    disabled: spec.disabled,
                    onDisabled(comp) {
                        FormCoupledInputs.getField1(comp)
                            .bind(FormField.getField)
                            .each(Disabling.disable);
                        FormCoupledInputs.getField2(comp)
                            .bind(FormField.getField)
                            .each(Disabling.disable);
                        FormCoupledInputs.getLock(comp).each(Disabling.disable);
                    },
                    onEnabled(comp) {
                        FormCoupledInputs.getField1(comp)
                            .bind(FormField.getField)
                            .each(Disabling.enable);
                        FormCoupledInputs.getField2(comp)
                            .bind(FormField.getField)
                            .each(Disabling.enable);
                        FormCoupledInputs.getLock(comp).each(Disabling.enable);
                    },
                }),
                config('size-input-events2', [
                    run(ratioEvent, function(component, simulatedEvent) {
                        const isField1 = simulatedEvent.event().isField1();
                        const optCurrent = isField1
                            ? FormCoupledInputs.getField1(component)
                            : FormCoupledInputs.getField2(component);
                        const optOther = isField1
                            ? FormCoupledInputs.getField2(component)
                            : FormCoupledInputs.getField1(component);
                        const value1 = optCurrent
                            .map(Representing.getValue)
                            .getOr('');
                        const value2 = optOther
                            .map(Representing.getValue)
                            .getOr('');
                        converter = makeRatioConverter(value1, value2);
                    }),
                ]),
            ]),
        });
    };

    const undo = constant(generate$1('undo'));
    const redo = constant(generate$1('redo'));
    const zoom = constant(generate$1('zoom'));
    const back = constant(generate$1('back'));
    const apply = constant(generate$1('apply'));
    const swap = constant(generate$1('swap'));
    const transform = constant(generate$1('transform'));
    const tempTransform = constant(generate$1('temp-transform'));
    const transformApply = constant(generate$1('transform-apply'));
    const internal = {
        undo,
        redo,
        zoom,
        back,
        apply,
        swap,
        transform,
        tempTransform,
        transformApply,
    };
    const saveState = constant('save-state');
    const disable$1 = constant('disable');
    const enable$1 = constant('enable');
    const external$2 = {
        formActionEvent,
        saveState,
        disable: disable$1,
        enable: enable$1,
    };

    const renderEditPanel = function(imagePanel, providersBackstage) {
        const createButton = function(text, action, disabled, primary) {
            return record(
                renderButton(
                    {
                        name: text,
                        text,
                        disabled,
                        primary,
                        icon: Option.none(),
                        borderless: false,
                    },
                    action,
                    providersBackstage,
                ),
            );
        };
        const createIconButton = function(icon, tooltip, action, disabled) {
            return record(
                renderIconButton(
                    {
                        name: icon,
                        icon: Option.some(icon),
                        tooltip: Option.some(tooltip),
                        disabled,
                        primary: false,
                        borderless: false,
                    },
                    action,
                    providersBackstage,
                ),
            );
        };
        const disableAllComponents = function(comps, eventcomp) {
            comps.map(function(mem) {
                const component = mem.get(eventcomp);
                if (component.hasConfigured(Disabling)) {
                    Disabling.disable(component);
                }
            });
        };
        const enableAllComponents = function(comps, eventcomp) {
            comps.map(function(mem) {
                const component = mem.get(eventcomp);
                if (component.hasConfigured(Disabling)) {
                    Disabling.enable(component);
                }
            });
        };
        const panelDom = {
            tag: 'div',
            classes: ['tox-image-tools__toolbar', 'tox-image-tools-edit-panel'],
        };
        const noop$1 = noop;
        const emit$1 = function(comp, event, data) {
            emitWith(comp, event, data);
        };
        const emitDisable = function(component) {
            return emit(component, external$2.disable());
        };
        const emitEnable = function(component) {
            return emit(component, external$2.enable());
        };
        const emitTransform = function(comp, transform) {
            emitDisable(comp);
            emit$1(comp, internal.transform(), { transform });
            emitEnable(comp);
        };
        const emitTempTransform = function(comp, transform) {
            emitDisable(comp);
            emit$1(comp, internal.tempTransform(), { transform });
            emitEnable(comp);
        };
        const getBackSwap = function(anyInSystem) {
            return function() {
                memContainer.getOpt(anyInSystem).each(function(container) {
                    Replacing.set(container, [ButtonPanel]);
                });
            };
        };
        const emitTransformApply = function(comp, transform) {
            emitDisable(comp);
            emit$1(comp, internal.transformApply(), {
                transform,
                swap: getBackSwap(comp),
            });
            emitEnable(comp);
        };
        const createBackButton = function() {
            return createButton(
                'Back',
                function(button) {
                    return emit$1(button, internal.back(), {
                        swap: getBackSwap(button),
                    });
                },
                false,
                false,
            );
        };
        const createSpacer = function() {
            return record({
                dom: {
                    tag: 'div',
                    classes: ['tox-spacer'],
                },
                behaviours: derive$1([Disabling.config({})]),
            });
        };
        const createApplyButton = function() {
            return createButton(
                'Apply',
                function(button) {
                    return emit$1(button, internal.apply(), {
                        swap: getBackSwap(button),
                    });
                },
                true,
                true,
            );
        };
        const makeCropTransform = function() {
            return function(ir) {
                const rect = imagePanel.getRect();
                return crop$1(ir, rect.x, rect.y, rect.w, rect.h);
            };
        };
        const cropPanelComponents = [
            createBackButton(),
            createSpacer(),
            createButton(
                'Apply',
                function(button) {
                    const transform = makeCropTransform();
                    emitTransformApply(button, transform);
                    imagePanel.hideCrop();
                },
                false,
                true,
            ),
        ];
        const CropPanel = Container.sketch({
            dom: panelDom,
            components: cropPanelComponents.map(function(mem) {
                return mem.asSpec();
            }),
            containerBehaviours: derive$1([
                config('image-tools-crop-buttons-events', [
                    run(external$2.disable(), function(comp, se) {
                        disableAllComponents(cropPanelComponents, comp);
                    }),
                    run(external$2.enable(), function(comp, se) {
                        enableAllComponents(cropPanelComponents, comp);
                    }),
                ]),
            ]),
        });
        const memSize = record(
            renderSizeInput(
                {
                    name: 'size',
                    label: Option.none(),
                    constrain: true,
                    disabled: false,
                },
                providersBackstage,
            ),
        );
        const makeResizeTransform = function(width, height) {
            return function(ir) {
                return resize$2(ir, width, height);
            };
        };
        const resizePanelComponents = [
            createBackButton(),
            createSpacer(),
            memSize,
            createSpacer(),
            createButton(
                'Apply',
                function(button) {
                    memSize.getOpt(button).each(function(sizeInput) {
                        const value = Representing.getValue(sizeInput);
                        const width = parseInt(value.width, 10);
                        const height = parseInt(value.height, 10);
                        const transform = makeResizeTransform(width, height);
                        emitTransformApply(button, transform);
                    });
                },
                false,
                true,
            ),
        ];
        const ResizePanel = Container.sketch({
            dom: panelDom,
            components: resizePanelComponents.map(function(mem) {
                return mem.asSpec();
            }),
            containerBehaviours: derive$1([
                config('image-tools-resize-buttons-events', [
                    run(external$2.disable(), function(comp, se) {
                        disableAllComponents(resizePanelComponents, comp);
                    }),
                    run(external$2.enable(), function(comp, se) {
                        enableAllComponents(resizePanelComponents, comp);
                    }),
                ]),
            ]),
        });
        const makeValueTransform = function(transform, value) {
            return function(ir) {
                return transform(ir, value);
            };
        };
        const horizontalFlip = makeValueTransform(flip$1, 'h');
        const verticalFlip = makeValueTransform(flip$1, 'v');
        const counterclockwiseRotate = makeValueTransform(rotate$1, -90);
        const clockwiseRotate = makeValueTransform(rotate$1, 90);
        const flipRotateOnAction = function(comp, operation) {
            emitTempTransform(comp, operation);
        };
        const flipRotateComponents = [
            createBackButton(),
            createSpacer(),
            createIconButton(
                'flip-horizontally',
                'Flip horizontally',
                function(button) {
                    flipRotateOnAction(button, horizontalFlip);
                },
                false,
            ),
            createIconButton(
                'flip-vertically',
                'Flip vertically',
                function(button) {
                    flipRotateOnAction(button, verticalFlip);
                },
                false,
            ),
            createIconButton(
                'rotate-left',
                'Rotate counterclockwise',
                function(button) {
                    flipRotateOnAction(button, counterclockwiseRotate);
                },
                false,
            ),
            createIconButton(
                'rotate-right',
                'Rotate clockwise',
                function(button) {
                    flipRotateOnAction(button, clockwiseRotate);
                },
                false,
            ),
            createSpacer(),
            createApplyButton(),
        ];
        const FlipRotatePanel = Container.sketch({
            dom: panelDom,
            components: flipRotateComponents.map(function(mem) {
                return mem.asSpec();
            }),
            containerBehaviours: derive$1([
                config('image-tools-fliprotate-buttons-events', [
                    run(external$2.disable(), function(comp, se) {
                        disableAllComponents(flipRotateComponents, comp);
                    }),
                    run(external$2.enable(), function(comp, se) {
                        enableAllComponents(flipRotateComponents, comp);
                    }),
                ]),
            ]),
        });
        const makeSlider = function(label, onChoose, min, value, max) {
            const labelPart = Slider.parts().label({
                dom: {
                    tag: 'label',
                    classes: ['tox-label'],
                    innerHtml: providersBackstage.translate(label),
                },
            });
            const spectrum = Slider.parts().spectrum({
                dom: {
                    tag: 'div',
                    classes: ['tox-slider__rail'],
                    attributes: { role: 'presentation' },
                },
            });
            const thumb = Slider.parts().thumb({
                dom: {
                    tag: 'div',
                    classes: ['tox-slider__handle'],
                    attributes: { role: 'presentation' },
                },
            });
            return record(
                Slider.sketch({
                    dom: {
                        tag: 'div',
                        classes: ['tox-slider'],
                        attributes: { role: 'presentation' },
                    },
                    model: {
                        mode: 'x',
                        minX: min,
                        maxX: max,
                        getInitialValue: constant({ x: constant(value) }),
                    },
                    components: [labelPart, spectrum, thumb],
                    sliderBehaviours: derive$1([Focusing.config({})]),
                    onChoose,
                }),
            );
        };
        const makeVariableSlider = function(label, transform, min, value, max) {
            const onChoose = function(slider, thumb, value) {
                const valTransform = makeValueTransform(
                    transform,
                    value.x() / 100,
                );
                emitTransform(slider, valTransform);
            };
            return makeSlider(label, onChoose, min, value, max);
        };
        const variableFilterPanelComponents = function(
            label,
            transform,
            min,
            value,
            max,
        ) {
            return [
                createBackButton(),
                makeVariableSlider(label, transform, min, value, max),
                createApplyButton(),
            ];
        };
        const createVariableFilterPanel = function(
            label,
            transform,
            min,
            value,
            max,
        ) {
            const filterPanelComponents = variableFilterPanelComponents(
                label,
                transform,
                min,
                value,
                max,
            );
            return Container.sketch({
                dom: panelDom,
                components: filterPanelComponents.map(function(mem) {
                    return mem.asSpec();
                }),
                containerBehaviours: derive$1([
                    config('image-tools-filter-panel-buttons-events', [
                        run(external$2.disable(), function(comp, se) {
                            disableAllComponents(filterPanelComponents, comp);
                        }),
                        run(external$2.enable(), function(comp, se) {
                            enableAllComponents(filterPanelComponents, comp);
                        }),
                    ]),
                ]),
            });
        };
        const filterPanelComponents = [
            createBackButton(),
            createSpacer(),
            createApplyButton(),
        ];
        const FilterPanel = Container.sketch({
            dom: panelDom,
            components: filterPanelComponents.map(function(mem) {
                return mem.asSpec();
            }),
        });
        const BrightnessPanel = createVariableFilterPanel(
            'Brightness',
            brightness$1,
            -100,
            0,
            100,
        );
        const ContrastPanel = createVariableFilterPanel(
            'Contrast',
            contrast$1,
            -100,
            0,
            100,
        );
        const GammaPanel = createVariableFilterPanel(
            'Gamma',
            gamma$1,
            -100,
            0,
            100,
        );
        const makeColorTransform = function(red, green, blue) {
            return function(ir) {
                return colorize$1(ir, red, green, blue);
            };
        };
        const makeColorSlider = function(label) {
            const onChoose = function(slider, thumb, value) {
                const redOpt = memRed.getOpt(slider);
                const blueOpt = memBlue.getOpt(slider);
                const greenOpt = memGreen.getOpt(slider);
                redOpt.each(function(red) {
                    blueOpt.each(function(blue) {
                        greenOpt.each(function(green) {
                            const r = Representing.getValue(red).x() / 100;
                            const g = Representing.getValue(green).x() / 100;
                            const b = Representing.getValue(blue).x() / 100;
                            const transform = makeColorTransform(r, g, b);
                            emitTransform(slider, transform);
                        });
                    });
                });
            };
            return makeSlider(label, onChoose, 0, 100, 200);
        };
        var memRed = makeColorSlider('R');
        var memGreen = makeColorSlider('G');
        var memBlue = makeColorSlider('B');
        const colorizePanelComponents = [
            createBackButton(),
            memRed,
            memGreen,
            memBlue,
            createApplyButton(),
        ];
        const ColorizePanel = Container.sketch({
            dom: panelDom,
            components: colorizePanelComponents.map(function(mem) {
                return mem.asSpec();
            }),
        });
        const getTransformPanelEvent = function(panel, transform, update) {
            return function(button) {
                const swap = function() {
                    memContainer.getOpt(button).each(function(container) {
                        Replacing.set(container, [panel]);
                        update(container);
                    });
                };
                emit$1(button, internal.swap(), {
                    transform,
                    swap,
                });
            };
        };
        const cropPanelUpdate = function(_anyInSystem) {
            imagePanel.showCrop();
        };
        const resizePanelUpdate = function(anyInSystem) {
            memSize.getOpt(anyInSystem).each(function(sizeInput) {
                const measurements = imagePanel.getMeasurements();
                const { width } = measurements;
                const { height } = measurements;
                Representing.setValue(sizeInput, {
                    width,
                    height,
                });
            });
        };
        const sharpenTransform = Option.some(sharpen$1);
        const invertTransform = Option.some(invert$1);
        const buttonPanelComponents = [
            createIconButton(
                'crop',
                'Crop',
                getTransformPanelEvent(
                    CropPanel,
                    Option.none(),
                    cropPanelUpdate,
                ),
                false,
            ),
            createIconButton(
                'resize',
                'Resize',
                getTransformPanelEvent(
                    ResizePanel,
                    Option.none(),
                    resizePanelUpdate,
                ),
                false,
            ),
            createIconButton(
                'orientation',
                'Orientation',
                getTransformPanelEvent(FlipRotatePanel, Option.none(), noop$1),
                false,
            ),
            createIconButton(
                'brightness',
                'Brightness',
                getTransformPanelEvent(BrightnessPanel, Option.none(), noop$1),
                false,
            ),
            createIconButton(
                'sharpen',
                'Sharpen',
                getTransformPanelEvent(FilterPanel, sharpenTransform, noop$1),
                false,
            ),
            createIconButton(
                'contrast',
                'Contrast',
                getTransformPanelEvent(ContrastPanel, Option.none(), noop$1),
                false,
            ),
            createIconButton(
                'color-levels',
                'Color levels',
                getTransformPanelEvent(ColorizePanel, Option.none(), noop$1),
                false,
            ),
            createIconButton(
                'gamma',
                'Gamma',
                getTransformPanelEvent(GammaPanel, Option.none(), noop$1),
                false,
            ),
            createIconButton(
                'invert',
                'Invert',
                getTransformPanelEvent(FilterPanel, invertTransform, noop$1),
                false,
            ),
        ];
        var ButtonPanel = Container.sketch({
            dom: panelDom,
            components: buttonPanelComponents.map(function(mem) {
                return mem.asSpec();
            }),
        });
        const container = Container.sketch({
            dom: { tag: 'div' },
            components: [ButtonPanel],
            containerBehaviours: derive$1([Replacing.config({})]),
        });
        var memContainer = record(container);
        const getApplyButton = function(anyInSystem) {
            return memContainer.getOpt(anyInSystem).map(function(container) {
                const panel = container.components()[0];
                return panel.components()[panel.components().length - 1];
            });
        };
        return {
            memContainer,
            getApplyButton,
        };
    };

    const global$b = tinymce.util.Tools.resolve('tinymce.dom.DomQuery');

    const global$c = tinymce.util.Tools.resolve('tinymce.geom.Rect');

    const global$d = tinymce.util.Tools.resolve('tinymce.util.Observable');

    const global$e = tinymce.util.Tools.resolve('tinymce.util.Tools');

    const global$f = tinymce.util.Tools.resolve('tinymce.util.VK');

    function getDocumentSize(doc) {
        let documentElement;
        let body;
        let scrollWidth;
        let clientWidth;
        let offsetWidth;
        let scrollHeight;
        let clientHeight;
        let offsetHeight;
        const { max } = Math;
        documentElement = doc.documentElement;
        body = doc.body;
        scrollWidth = max(documentElement.scrollWidth, body.scrollWidth);
        clientWidth = max(documentElement.clientWidth, body.clientWidth);
        offsetWidth = max(documentElement.offsetWidth, body.offsetWidth);
        scrollHeight = max(documentElement.scrollHeight, body.scrollHeight);
        clientHeight = max(documentElement.clientHeight, body.clientHeight);
        offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);
        return {
            width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,
            height: scrollHeight < offsetHeight ? clientHeight : scrollHeight,
        };
    }
    function updateWithTouchData(e) {
        let keys;
        let i;
        if (e.changedTouches) {
            keys = 'screenX screenY pageX pageY clientX clientY'.split(' ');
            for (i = 0; i < keys.length; i++) {
                e[keys[i]] = e.changedTouches[0][keys[i]];
            }
        }
    }
    function DragHelper(id, settings) {
        let $eventOverlay;
        const doc = settings.document || domGlobals.document;
        let downButton;
        let start;
        let stop;
        let drag;
        let startX;
        let startY;
        settings = settings || {};
        const handleElement = doc.getElementById(settings.handle || id);
        start = function(e) {
            const docSize = getDocumentSize(doc);
            let handleElm;
            let cursor;
            updateWithTouchData(e);
            e.preventDefault();
            downButton = e.button;
            handleElm = handleElement;
            startX = e.screenX;
            startY = e.screenY;
            if (domGlobals.window.getComputedStyle) {
                cursor = domGlobals.window
                    .getComputedStyle(handleElm, null)
                    .getPropertyValue('cursor');
            } else {
                cursor = handleElm.runtimeStyle.cursor;
            }
            $eventOverlay = global$b('<div></div>')
                .css({
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    width: docSize.width,
                    height: docSize.height,
                    zIndex: 2147483647,
                    opacity: 0.0001,
                    cursor,
                })
                .appendTo(doc.body);
            global$b(doc)
                .on('mousemove touchmove', drag)
                .on('mouseup touchend', stop);
            settings.start(e);
        };
        drag = function(e) {
            updateWithTouchData(e);
            if (e.button !== downButton) {
                return stop(e);
            }
            e.deltaX = e.screenX - startX;
            e.deltaY = e.screenY - startY;
            e.preventDefault();
            settings.drag(e);
        };
        stop = function(e) {
            updateWithTouchData(e);
            global$b(doc)
                .off('mousemove touchmove', drag)
                .off('mouseup touchend', stop);
            $eventOverlay.remove();
            if (settings.stop) {
                settings.stop(e);
            }
        };
        this.destroy = function() {
            global$b(handleElement).off();
        };
        global$b(handleElement).on('mousedown touchstart', start);
    }

    let count = 0;
    const create$7 = function(
        currentRect,
        viewPortRect,
        clampRect,
        containerElm,
        action,
    ) {
        let instance;
        let dragHelpers;
        let blockers;
        const prefix = 'tox-';
        const id = `${prefix}crid-${count++}`;
        const handles = [
            {
                name: 'move',
                xMul: 0,
                yMul: 0,
                deltaX: 1,
                deltaY: 1,
                deltaW: 0,
                deltaH: 0,
                label: 'Crop Mask',
            },
            {
                name: 'nw',
                xMul: 0,
                yMul: 0,
                deltaX: 1,
                deltaY: 1,
                deltaW: -1,
                deltaH: -1,
                label: 'Top Left Crop Handle',
            },
            {
                name: 'ne',
                xMul: 1,
                yMul: 0,
                deltaX: 0,
                deltaY: 1,
                deltaW: 1,
                deltaH: -1,
                label: 'Top Right Crop Handle',
            },
            {
                name: 'sw',
                xMul: 0,
                yMul: 1,
                deltaX: 1,
                deltaY: 0,
                deltaW: -1,
                deltaH: 1,
                label: 'Bottom Left Crop Handle',
            },
            {
                name: 'se',
                xMul: 1,
                yMul: 1,
                deltaX: 0,
                deltaY: 0,
                deltaW: 1,
                deltaH: 1,
                label: 'Bottom Right Crop Handle',
            },
        ];
        blockers = ['top', 'right', 'bottom', 'left'];
        const getAbsoluteRect = function(outerRect, relativeRect) {
            return {
                x: relativeRect.x + outerRect.x,
                y: relativeRect.y + outerRect.y,
                w: relativeRect.w,
                h: relativeRect.h,
            };
        };
        const getRelativeRect = function(outerRect, innerRect) {
            return {
                x: innerRect.x - outerRect.x,
                y: innerRect.y - outerRect.y,
                w: innerRect.w,
                h: innerRect.h,
            };
        };
        const getInnerRect = function() {
            return getRelativeRect(clampRect, currentRect);
        };
        function moveRect(handle, startRect, deltaX, deltaY) {
            let x;
            let y;
            let w;
            let h;
            let rect;
            x = startRect.x;
            y = startRect.y;
            w = startRect.w;
            h = startRect.h;
            x += deltaX * handle.deltaX;
            y += deltaY * handle.deltaY;
            w += deltaX * handle.deltaW;
            h += deltaY * handle.deltaH;
            if (w < 20) {
                w = 20;
            }
            if (h < 20) {
                h = 20;
            }
            rect = currentRect = global$c.clamp(
                {
                    x,
                    y,
                    w,
                    h,
                },
                clampRect,
                handle.name === 'move',
            );
            rect = getRelativeRect(clampRect, rect);
            instance.fire('updateRect', { rect });
            setInnerRect(rect);
        }
        function render() {
            function createDragHelper(handle) {
                let startRect;
                return new DragHelper(id, {
                    document: containerElm.ownerDocument,
                    handle: `${id}-${handle.name}`,
                    start() {
                        startRect = currentRect;
                    },
                    drag(e) {
                        moveRect(handle, startRect, e.deltaX, e.deltaY);
                    },
                });
            }
            global$b(
                `<div id="${id}" class="${prefix}croprect-container"` +
                    ` role="grid" aria-dropeffect="execute">`,
            ).appendTo(containerElm);
            global$e.each(blockers, function(blocker) {
                global$b(`#${id}`, containerElm).append(
                    `<div id="${id}-${blocker}"class="${prefix}croprect-block" style="display: none" data-mce-bogus="all">`,
                );
            });
            global$e.each(handles, function(handle) {
                global$b(`#${id}`, containerElm).append(
                    `<div id="${id}-${handle.name}" class="${prefix}croprect-handle ${prefix}croprect-handle-${handle.name}"` +
                        `style="display: none" data-mce-bogus="all" role="gridcell" tabindex="-1"` +
                        ` aria-label="${handle.label}" aria-grabbed="false" title="${handle.label}">`,
                );
            });
            dragHelpers = global$e.map(handles, createDragHelper);
            repaint(currentRect);
            global$b(containerElm).on('focusin focusout', function(e) {
                global$b(e.target).attr(
                    'aria-grabbed',
                    e.type === 'focus' ? 'true' : 'false',
                );
            });
            global$b(containerElm).on('keydown', function(e) {
                let activeHandle;
                global$e.each(handles, function(handle) {
                    if (e.target.id === `${id}-${handle.name}`) {
                        activeHandle = handle;
                        return false;
                    }
                });
                function moveAndBlock(evt, handle, startRect, deltaX, deltaY) {
                    evt.stopPropagation();
                    evt.preventDefault();
                    moveRect(activeHandle, startRect, deltaX, deltaY);
                }
                switch (e.keyCode) {
                    case global$f.LEFT:
                        moveAndBlock(e, activeHandle, currentRect, -10, 0);
                        break;
                    case global$f.RIGHT:
                        moveAndBlock(e, activeHandle, currentRect, 10, 0);
                        break;
                    case global$f.UP:
                        moveAndBlock(e, activeHandle, currentRect, 0, -10);
                        break;
                    case global$f.DOWN:
                        moveAndBlock(e, activeHandle, currentRect, 0, 10);
                        break;
                    case global$f.ENTER:
                    case global$f.SPACEBAR:
                        e.preventDefault();
                        action();
                        break;
                }
            });
        }
        function toggleVisibility(state) {
            let selectors;
            selectors = global$e
                .map(handles, function(handle) {
                    return `#${id}-${handle.name}`;
                })
                .concat(
                    global$e.map(blockers, function(blocker) {
                        return `#${id}-${blocker}`;
                    }),
                )
                .join(',');
            if (state) {
                global$b(selectors, containerElm).show();
            } else {
                global$b(selectors, containerElm).hide();
            }
        }
        function repaint(rect) {
            function updateElementRect(name, rect) {
                if (rect.h < 0) {
                    rect.h = 0;
                }
                if (rect.w < 0) {
                    rect.w = 0;
                }
                global$b(`#${id}-${name}`, containerElm).css({
                    left: rect.x,
                    top: rect.y,
                    width: rect.w,
                    height: rect.h,
                });
            }
            global$e.each(handles, function(handle) {
                global$b(`#${id}-${handle.name}`, containerElm).css({
                    left: rect.w * handle.xMul + rect.x,
                    top: rect.h * handle.yMul + rect.y,
                });
            });
            updateElementRect('top', {
                x: viewPortRect.x,
                y: viewPortRect.y,
                w: viewPortRect.w,
                h: rect.y - viewPortRect.y,
            });
            updateElementRect('right', {
                x: rect.x + rect.w,
                y: rect.y,
                w: viewPortRect.w - rect.x - rect.w + viewPortRect.x,
                h: rect.h,
            });
            updateElementRect('bottom', {
                x: viewPortRect.x,
                y: rect.y + rect.h,
                w: viewPortRect.w,
                h: viewPortRect.h - rect.y - rect.h + viewPortRect.y,
            });
            updateElementRect('left', {
                x: viewPortRect.x,
                y: rect.y,
                w: rect.x - viewPortRect.x,
                h: rect.h,
            });
            updateElementRect('move', rect);
        }
        function setRect(rect) {
            currentRect = rect;
            repaint(currentRect);
        }
        function setViewPortRect(rect) {
            viewPortRect = rect;
            repaint(currentRect);
        }
        function setInnerRect(rect) {
            setRect(getAbsoluteRect(clampRect, rect));
        }
        function setClampRect(rect) {
            clampRect = rect;
            repaint(currentRect);
        }
        function destroy() {
            global$e.each(dragHelpers, function(helper) {
                helper.destroy();
            });
            dragHelpers = [];
        }
        render();
        instance = global$e.extend(
            {
                toggleVisibility,
                setClampRect,
                setRect,
                getInnerRect,
                setInnerRect,
                setViewPortRect,
                destroy,
            },
            global$d,
        );
        return instance;
    };
    const CropRect = { create: create$7 };

    const loadImage = function(image) {
        return new global$4(function(resolve) {
            var loaded = function() {
                image.removeEventListener('load', loaded);
                resolve(image);
            };
            if (image.complete) {
                resolve(image);
            } else {
                image.addEventListener('load', loaded);
            }
        });
    };
    const renderImagePanel = function(initialUrl) {
        const memBg = record({
            dom: {
                tag: 'div',
                classes: ['tox-image-tools__image-bg'],
                attributes: { role: 'presentation' },
            },
        });
        const zoomState = Cell(1);
        const cropRect = Cell(Option.none());
        const rectState = Cell({
            x: 0,
            y: 0,
            w: 1,
            h: 1,
        });
        const viewRectState = Cell({
            x: 0,
            y: 0,
            w: 1,
            h: 1,
        });
        const repaintImg = function(anyInSystem, img) {
            memContainer.getOpt(anyInSystem).each(function(panel) {
                const zoom = zoomState.get();
                const panelW = get$7(panel.element());
                const panelH = get$6(panel.element());
                const width = img.dom().naturalWidth * zoom;
                const height = img.dom().naturalHeight * zoom;
                const left = Math.max(0, panelW / 2 - width / 2);
                const top = Math.max(0, panelH / 2 - height / 2);
                const css = {
                    left: `${left.toString()}px`,
                    top: `${top.toString()}px`,
                    width: `${width.toString()}px`,
                    height: `${height.toString()}px`,
                    position: 'absolute',
                };
                setAll$1(img, css);
                memBg.getOpt(panel).each(function(bg) {
                    setAll$1(bg.element(), css);
                });
                cropRect.get().each(function(cRect) {
                    const rect = rectState.get();
                    cRect.setRect({
                        x: rect.x * zoom + left,
                        y: rect.y * zoom + top,
                        w: rect.w * zoom,
                        h: rect.h * zoom,
                    });
                    cRect.setClampRect({
                        x: left,
                        y: top,
                        w: width,
                        h: height,
                    });
                    cRect.setViewPortRect({
                        x: 0,
                        y: 0,
                        w: panelW,
                        h: panelH,
                    });
                });
            });
        };
        const zoomFit = function(anyInSystem, img) {
            memContainer.getOpt(anyInSystem).each(function(panel) {
                const panelW = get$7(panel.element());
                const panelH = get$6(panel.element());
                const width = img.dom().naturalWidth;
                const height = img.dom().naturalHeight;
                const zoom = Math.min(panelW / width, panelH / height);
                if (zoom >= 1) {
                    zoomState.set(1);
                } else {
                    zoomState.set(zoom);
                }
            });
        };
        const updateSrc = function(anyInSystem, url) {
            const img = Element.fromTag('img');
            set$1(img, 'src', url);
            return loadImage(img.dom()).then(function() {
                return memContainer.getOpt(anyInSystem).map(function(panel) {
                    const aImg = external({ element: img });
                    Replacing.replaceAt(panel, 1, Option.some(aImg));
                    const lastViewRect = viewRectState.get();
                    const viewRect = {
                        x: 0,
                        y: 0,
                        w: img.dom().naturalWidth,
                        h: img.dom().naturalHeight,
                    };
                    viewRectState.set(viewRect);
                    const rect = global$c.inflate(viewRect, -20, -20);
                    rectState.set(rect);
                    if (
                        lastViewRect.w !== viewRect.w ||
                        lastViewRect.h !== viewRect.h
                    ) {
                        zoomFit(panel, img);
                    }
                    repaintImg(panel, img);
                    return img;
                });
            });
        };
        const zoom = function(anyInSystem, direction) {
            const currentZoom = zoomState.get();
            const newZoom =
                direction > 0
                    ? Math.min(2, currentZoom + 0.1)
                    : Math.max(0.1, currentZoom - 0.1);
            zoomState.set(newZoom);
            memContainer.getOpt(anyInSystem).each(function(panel) {
                const img = panel.components()[1].element();
                repaintImg(panel, img);
            });
        };
        const showCrop = function() {
            cropRect.get().each(function(cRect) {
                cRect.toggleVisibility(true);
            });
        };
        const hideCrop = function() {
            cropRect.get().each(function(cRect) {
                cRect.toggleVisibility(false);
            });
        };
        const getRect = function() {
            return rectState.get();
        };
        const container = Container.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-image-tools__image'],
            },
            components: [
                memBg.asSpec(),
                {
                    dom: {
                        tag: 'img',
                        attributes: { src: initialUrl },
                    },
                },
                {
                    dom: { tag: 'div' },
                    behaviours: derive$1([
                        config('image-panel-crop-events', [
                            runOnAttached(function(comp) {
                                memContainer
                                    .getOpt(comp)
                                    .each(function(container) {
                                        const el = container.element().dom();
                                        const cRect = CropRect.create(
                                            {
                                                x: 10,
                                                y: 10,
                                                w: 100,
                                                h: 100,
                                            },
                                            {
                                                x: 0,
                                                y: 0,
                                                w: 200,
                                                h: 200,
                                            },
                                            {
                                                x: 0,
                                                y: 0,
                                                w: 200,
                                                h: 200,
                                            },
                                            el,
                                            function() {},
                                        );
                                        cRect.toggleVisibility(false);
                                        cRect.on('updateRect', function(e) {
                                            const { rect } = e;
                                            const zoom = zoomState.get();
                                            const newRect = {
                                                x: Math.round(rect.x / zoom),
                                                y: Math.round(rect.y / zoom),
                                                w: Math.round(rect.w / zoom),
                                                h: Math.round(rect.h / zoom),
                                            };
                                            rectState.set(newRect);
                                        });
                                        cropRect.set(Option.some(cRect));
                                    });
                            }),
                        ]),
                    ]),
                },
            ],
            containerBehaviours: derive$1([
                Replacing.config({}),
                config('image-panel-events', [
                    runOnAttached(function(comp) {
                        updateSrc(comp, initialUrl);
                    }),
                ]),
            ]),
        });
        var memContainer = record(container);
        const getMeasurements = function() {
            const viewRect = viewRectState.get();
            return {
                width: viewRect.w,
                height: viewRect.h,
            };
        };
        return {
            memContainer,
            updateSrc,
            zoom,
            showCrop,
            hideCrop,
            getRect,
            getMeasurements,
        };
    };

    const createButton = function(
        innerHtml,
        icon,
        disabled,
        action,
        providersBackstage,
    ) {
        return renderIconButton(
            {
                name: innerHtml,
                icon: Option.some(icon),
                disabled,
                tooltip: Option.some(innerHtml),
                primary: false,
                borderless: false,
            },
            action,
            providersBackstage,
        );
    };
    const setButtonEnabled = function(button, enabled) {
        if (enabled) {
            Disabling.enable(button);
        } else {
            Disabling.disable(button);
        }
    };
    const renderSideBar = function(providersBackstage) {
        const updateButtonUndoStates = function(
            anyInSystem,
            undoEnabled,
            redoEnabled,
        ) {
            memUndo.getOpt(anyInSystem).each(function(undo) {
                setButtonEnabled(undo, undoEnabled);
            });
            memRedo.getOpt(anyInSystem).each(function(redo) {
                setButtonEnabled(redo, redoEnabled);
            });
        };
        var memUndo = record(
            createButton(
                'Undo',
                'undo',
                true,
                function(button) {
                    emitWith(button, internal.undo(), { direction: 1 });
                },
                providersBackstage,
            ),
        );
        var memRedo = record(
            createButton(
                'Redo',
                'redo',
                true,
                function(button) {
                    emitWith(button, internal.redo(), { direction: 1 });
                },
                providersBackstage,
            ),
        );
        const container = Container.sketch({
            dom: {
                tag: 'div',
                classes: [
                    'tox-image-tools__toolbar',
                    'tox-image-tools__sidebar',
                ],
            },
            components: [
                memUndo.asSpec(),
                memRedo.asSpec(),
                createButton(
                    'Zoom in',
                    'zoom-in',
                    false,
                    function(button) {
                        emitWith(button, internal.zoom(), { direction: 1 });
                    },
                    providersBackstage,
                ),
                createButton(
                    'Zoom out',
                    'zoom-out',
                    false,
                    function(button) {
                        emitWith(button, internal.zoom(), { direction: -1 });
                    },
                    providersBackstage,
                ),
            ],
        });
        return {
            container,
            updateButtonUndoStates,
        };
    };

    function UndoStack() {
        const data = [];
        let index = -1;
        function add(state) {
            let removed;
            removed = data.splice(++index);
            data.push(state);
            return {
                state,
                removed,
            };
        }
        function undo() {
            if (canUndo()) {
                return data[--index];
            }
        }
        function redo() {
            if (canRedo()) {
                return data[++index];
            }
        }
        function canUndo() {
            return index > 0;
        }
        function canRedo() {
            return index !== -1 && index < data.length - 1;
        }
        return {
            data,
            add,
            undo,
            redo,
            canUndo,
            canRedo,
        };
    }

    const makeState = function(initialState) {
        const blobState = Cell(initialState);
        const tempState = Cell(Option.none());
        const undoStack = UndoStack();
        undoStack.add(initialState);
        const getBlobState = function() {
            return blobState.get();
        };
        const setBlobState = function(state) {
            blobState.set(state);
        };
        const getTempState = function() {
            return tempState.get().fold(
                function() {
                    return blobState.get();
                },
                function(temp) {
                    return temp;
                },
            );
        };
        const updateTempState = function(blob) {
            const newTempState = createState(blob);
            destroyTempState();
            tempState.set(Option.some(newTempState));
            return newTempState.url;
        };
        var createState = function(blob) {
            return {
                blob,
                url: domGlobals.URL.createObjectURL(blob),
            };
        };
        const destroyState = function(state) {
            domGlobals.URL.revokeObjectURL(state.url);
        };
        const destroyStates = function(states) {
            global$e.each(states, destroyState);
        };
        var destroyTempState = function() {
            tempState.get().each(destroyState);
            tempState.set(Option.none());
        };
        const addBlobState = function(blob) {
            const newState = createState(blob);
            setBlobState(newState);
            const { removed } = undoStack.add(newState);
            destroyStates(removed);
            return newState.url;
        };
        const addTempState = function(blob) {
            const newState = createState(blob);
            tempState.set(Option.some(newState));
            return newState.url;
        };
        const applyTempState = function(postApply) {
            return tempState.get().fold(
                function() {},
                function(temp) {
                    addBlobState(temp.blob);
                    postApply();
                },
            );
        };
        const undo = function() {
            const currentState = undoStack.undo();
            setBlobState(currentState);
            return currentState.url;
        };
        const redo = function() {
            const currentState = undoStack.redo();
            setBlobState(currentState);
            return currentState.url;
        };
        const getHistoryStates = function() {
            const undoEnabled = undoStack.canUndo();
            const redoEnabled = undoStack.canRedo();
            return {
                undoEnabled,
                redoEnabled,
            };
        };
        return {
            getBlobState,
            setBlobState,
            addBlobState,
            getTempState,
            updateTempState,
            addTempState,
            applyTempState,
            destroyTempState,
            undo,
            redo,
            getHistoryStates,
        };
    };

    const renderImageTools = function(detail, providersBackstage) {
        const state = makeState(detail.currentState);
        const zoom = function(anyInSystem, simulatedEvent) {
            const direction = simulatedEvent.event().direction();
            imagePanel.zoom(anyInSystem, direction);
        };
        const updateButtonUndoStates = function(anyInSystem) {
            const historyStates = state.getHistoryStates();
            sideBar.updateButtonUndoStates(
                anyInSystem,
                historyStates.undoEnabled,
                historyStates.redoEnabled,
            );
            emitWith(anyInSystem, external$2.formActionEvent, {
                name: external$2.saveState(),
                value: historyStates.undoEnabled,
            });
        };
        const disableUndoRedo = function(anyInSystem) {
            sideBar.updateButtonUndoStates(anyInSystem, false, false);
        };
        const undo = function(anyInSystem, _simulatedEvent) {
            const url = state.undo();
            updateSrc(anyInSystem, url).then(function(oImg) {
                unblock(anyInSystem);
                updateButtonUndoStates(anyInSystem);
            });
        };
        const redo = function(anyInSystem, _simulatedEvent) {
            const url = state.redo();
            updateSrc(anyInSystem, url).then(function(oImg) {
                unblock(anyInSystem);
                updateButtonUndoStates(anyInSystem);
            });
        };
        const imageResultToBlob = function(ir) {
            return ir.toBlob();
        };
        const block = function(anyInSystem) {
            emitWith(anyInSystem, external$2.formActionEvent, {
                name: external$2.disable(),
                value: {},
            });
        };
        var unblock = function(anyInSystem) {
            editPanel.getApplyButton(anyInSystem).each(function(applyButton) {
                Disabling.enable(applyButton);
            });
            emitWith(anyInSystem, external$2.formActionEvent, {
                name: external$2.enable(),
                value: {},
            });
        };
        var updateSrc = function(anyInSystem, src) {
            block(anyInSystem);
            return imagePanel.updateSrc(anyInSystem, src);
        };
        const blobManipulate = function(
            anyInSystem,
            blob,
            filter,
            action,
            swap,
        ) {
            block(anyInSystem);
            return blobToImageResult(blob)
                .then(filter)
                .then(imageResultToBlob)
                .then(action)
                .then(function(url) {
                    return updateSrc(anyInSystem, url).then(function(oImg) {
                        updateButtonUndoStates(anyInSystem);
                        swap();
                        unblock(anyInSystem);
                        return oImg;
                    });
                })
                .catch(function(err) {
                    domGlobals.console.log(err);
                    unblock(anyInSystem);
                    return err;
                });
        };
        const manipulate = function(anyInSystem, filter, swap) {
            const { blob } = state.getBlobState();
            const action = function(blob) {
                return state.updateTempState(blob);
            };
            blobManipulate(anyInSystem, blob, filter, action, swap);
        };
        const tempManipulate = function(anyInSystem, filter) {
            const { blob } = state.getTempState();
            const action = function(blob) {
                return state.addTempState(blob);
            };
            blobManipulate(anyInSystem, blob, filter, action, noop);
        };
        const manipulateApply = function(anyInSystem, filter, swap) {
            const { blob } = state.getBlobState();
            const action = function(blob) {
                const url = state.addBlobState(blob);
                destroyTempState(anyInSystem);
                return url;
            };
            blobManipulate(anyInSystem, blob, filter, action, swap);
        };
        const apply = function(anyInSystem, simulatedEvent) {
            const postApply = function() {
                destroyTempState(anyInSystem);
                const swap = simulatedEvent.event().swap();
                swap();
            };
            state.applyTempState(postApply);
        };
        var destroyTempState = function(anyInSystem) {
            const currentUrl = state.getBlobState().url;
            state.destroyTempState();
            updateButtonUndoStates(anyInSystem);
            return currentUrl;
        };
        const cancel = function(anyInSystem) {
            const currentUrl = destroyTempState(anyInSystem);
            updateSrc(anyInSystem, currentUrl).then(function(oImg) {
                unblock(anyInSystem);
            });
        };
        const back = function(anyInSystem, simulatedEvent) {
            cancel(anyInSystem);
            const swap = simulatedEvent.event().swap();
            swap();
            imagePanel.hideCrop();
        };
        const transform = function(anyInSystem, simulatedEvent) {
            return manipulate(
                anyInSystem,
                simulatedEvent.event().transform(),
                noop,
            );
        };
        const tempTransform = function(anyInSystem, simulatedEvent) {
            return tempManipulate(
                anyInSystem,
                simulatedEvent.event().transform(),
            );
        };
        const transformApply = function(anyInSystem, simulatedEvent) {
            return manipulateApply(
                anyInSystem,
                simulatedEvent.event().transform(),
                simulatedEvent.event().swap(),
            );
        };
        var imagePanel = renderImagePanel(detail.currentState.url);
        var sideBar = renderSideBar(providersBackstage);
        var editPanel = renderEditPanel(imagePanel, providersBackstage);
        const swap = function(anyInSystem, simulatedEvent) {
            disableUndoRedo(anyInSystem);
            const transform = simulatedEvent.event().transform();
            const swap = simulatedEvent.event().swap();
            transform.fold(
                function() {
                    swap();
                },
                function(transform) {
                    manipulate(anyInSystem, transform, swap);
                },
            );
        };
        return {
            dom: {
                tag: 'div',
                attributes: { role: 'presentation' },
            },
            components: [
                editPanel.memContainer.asSpec(),
                imagePanel.memContainer.asSpec(),
                sideBar.container,
            ],
            behaviours: derive$1([
                Representing.config({
                    store: {
                        mode: 'manual',
                        getValue() {
                            return state.getBlobState();
                        },
                    },
                }),
                config('image-tools-events', [
                    run(internal.undo(), undo),
                    run(internal.redo(), redo),
                    run(internal.zoom(), zoom),
                    run(internal.back(), back),
                    run(internal.apply(), apply),
                    run(internal.transform(), transform),
                    run(internal.tempTransform(), tempTransform),
                    run(internal.transformApply(), transformApply),
                    run(internal.swap(), swap),
                ]),
                ComposingConfigs.self(),
            ]),
        };
    };

    const factory$8 = function(detail, spec) {
        const options = map(detail.options, function(option) {
            return {
                dom: {
                    tag: 'option',
                    value: option.value,
                    innerHtml: option.text,
                },
            };
        });
        const initialValues = detail.data
            .map(function(v) {
                return wrap$1('initialValue', v);
            })
            .getOr({});
        return {
            uid: detail.uid,
            dom: {
                tag: 'select',
                classes: detail.selectClasses,
                attributes: detail.selectAttributes,
            },
            components: options,
            behaviours: augment(detail.selectBehaviours, [
                Focusing.config({}),
                Representing.config({
                    store: {
                        mode: 'manual',
                        getValue(select) {
                            return get$5(select.element());
                        },
                        setValue(select, newValue) {
                            const found = find(detail.options, function(opt) {
                                return opt.value === newValue;
                            });
                            if (found.isSome()) {
                                set$3(select.element(), newValue);
                            }
                        },
                        ...initialValues,
                    },
                }),
            ]),
        };
    };
    const HtmlSelect = single$2({
        name: 'HtmlSelect',
        configFields: [
            strict$1('options'),
            field$1('selectBehaviours', [Focusing, Representing]),
            defaulted$1('selectClasses', []),
            defaulted$1('selectAttributes', {}),
            option('data'),
        ],
        factory: factory$8,
    });

    const renderSelectBox = function(spec, providersBackstage) {
        const translatedOptions = map(spec.items, function(item) {
            return {
                text: providersBackstage.translate(item.text),
                value: item.value,
            };
        });
        const pLabel = spec.label.map(function(label) {
            return renderLabel(label, providersBackstage);
        });
        const pField = FormField.parts().field({
            dom: {},
            selectAttributes: { size: spec.size },
            options: translatedOptions,
            factory: HtmlSelect,
            selectBehaviours: derive$1([
                Disabling.config({ disabled: spec.disabled }),
                Tabstopping.config({}),
                config('selectbox-change', [
                    run(change(), function(component, _) {
                        emitWith(component, formChangeEvent, {
                            name: spec.name,
                        });
                    }),
                ]),
            ]),
        });
        const chevron =
            spec.size > 1
                ? Option.none()
                : Option.some({
                      dom: {
                          tag: 'div',
                          classes: ['tox-selectfield__icon-js'],
                          innerHtml: get$c(
                              'chevron-down',
                              providersBackstage.icons,
                          ),
                      },
                  });
        const selectWrap = {
            dom: {
                tag: 'div',
                classes: ['tox-selectfield'],
            },
            components: flatten([[pField], chevron.toArray()]),
        };
        return FormField.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-form__group'],
            },
            components: flatten([pLabel.toArray(), [selectWrap]]),
            fieldBehaviours: derive$1([
                Disabling.config({
                    disabled: spec.disabled,
                    onDisabled(comp) {
                        FormField.getField(comp).each(Disabling.disable);
                    },
                    onEnabled(comp) {
                        FormField.getField(comp).each(Disabling.enable);
                    },
                }),
            ]),
        });
    };

    const renderTextField = function(spec, providersBackstage) {
        const pLabel = spec.label.map(function(label) {
            return renderLabel(label, providersBackstage);
        });
        const baseInputBehaviours = [
            Disabling.config({ disabled: spec.disabled }),
            Keying.config({
                mode: 'execution',
                useEnter: spec.multiline !== true,
                useControlEnter: spec.multiline === true,
                execute(comp) {
                    emit(comp, formSubmitEvent);
                    return Option.some(true);
                },
            }),
            config('textfield-change', [
                run(input(), function(component, _) {
                    emitWith(component, formChangeEvent, { name: spec.name });
                }),
                run(postPaste(), function(component, _) {
                    emitWith(component, formChangeEvent, { name: spec.name });
                }),
            ]),
            Tabstopping.config({}),
        ];
        const validatingBehaviours = spec.validation
            .map(function(vl) {
                return Invalidating.config({
                    getRoot(input) {
                        return parent(input.element());
                    },
                    invalidClass: 'tox-invalid',
                    validator: {
                        validate(input) {
                            const v = Representing.getValue(input);
                            const result = vl.validator(v);
                            return Future.pure(
                                result === true
                                    ? Result.value(v)
                                    : Result.error(result),
                            );
                        },
                        validateOnLoad: vl.validateOnLoad,
                    },
                });
            })
            .toArray();
        const placeholder = spec.placeholder.fold(constant({}), function(p) {
            return { placeholder: providersBackstage.translate(p) };
        });
        const inputMode = spec.inputMode.fold(constant({}), function(mode) {
            return { inputmode: mode };
        });
        const inputAttributes = { ...placeholder, ...inputMode };
        const pField = FormField.parts().field({
            tag: spec.multiline === true ? 'textarea' : 'input',
            inputAttributes,
            inputClasses: [spec.classname],
            inputBehaviours: derive$1(
                flatten([baseInputBehaviours, validatingBehaviours]),
            ),
            selectOnFocus: false,
            factory: Input,
        });
        const extraClasses = spec.flex ? ['tox-form__group--stretched'] : [];
        const extraClasses2 = extraClasses.concat(
            spec.maximized ? ['tox-form-group--maximize'] : [],
        );
        const extraBehaviours = [
            Disabling.config({
                disabled: spec.disabled,
                onDisabled(comp) {
                    FormField.getField(comp).each(Disabling.disable);
                },
                onEnabled(comp) {
                    FormField.getField(comp).each(Disabling.enable);
                },
            }),
        ];
        return renderFormFieldWith(
            pLabel,
            pField,
            extraClasses2,
            extraBehaviours,
        );
    };
    const renderInput = function(spec, providersBackstage) {
        return renderTextField(
            {
                name: spec.name,
                multiline: false,
                label: spec.label,
                inputMode: spec.inputMode,
                placeholder: spec.placeholder,
                flex: false,
                disabled: spec.disabled,
                classname: 'tox-textfield',
                validation: Option.none(),
                maximized: spec.maximized,
            },
            providersBackstage,
        );
    };
    const renderTextarea = function(spec, providersBackstage) {
        return renderTextField(
            {
                name: spec.name,
                multiline: true,
                label: spec.label,
                inputMode: Option.none(),
                placeholder: spec.placeholder,
                flex: true,
                disabled: spec.disabled,
                classname: 'tox-textarea',
                validation: Option.none(),
                maximized: spec.maximized,
            },
            providersBackstage,
        );
    };

    const events$c = function(streamConfig, streamState) {
        const { streams } = streamConfig.stream;
        const processor = streams.setup(streamConfig, streamState);
        return derive(
            [
                run(streamConfig.event, processor),
                runOnDetached(function() {
                    return streamState.cancel();
                }),
            ].concat(
                streamConfig.cancelEvent
                    .map(function(e) {
                        return [
                            run(e, function() {
                                return streamState.cancel();
                            }),
                        ];
                    })
                    .getOr([]),
            ),
        );
    };

    const ActiveStreaming = /* #__PURE__ */ Object.freeze({
        events: events$c,
    });

    const throttle = function(_config) {
        const state = Cell(null);
        const readState = function() {
            return { timer: state.get() !== null ? 'set' : 'unset' };
        };
        const setTimer = function(t) {
            state.set(t);
        };
        const cancel = function() {
            const t = state.get();
            if (t !== null) {
                t.cancel();
            }
        };
        return nu$5({
            readState,
            setTimer,
            cancel,
        });
    };
    const init$6 = function(spec) {
        return spec.stream.streams.state(spec);
    };

    const StreamingState = /* #__PURE__ */ Object.freeze({
        throttle,
        init: init$6,
    });

    const setup$3 = function(streamInfo, streamState) {
        const sInfo = streamInfo.stream;
        const throttler = last$2(streamInfo.onStream, sInfo.delay);
        streamState.setTimer(throttler);
        return function(component, simulatedEvent) {
            throttler.throttle(component, simulatedEvent);
            if (sInfo.stopEvent) {
                simulatedEvent.stop();
            }
        };
    };
    const StreamingSchema = [
        strictOf(
            'stream',
            choose$1('mode', {
                throttle: [
                    strict$1('delay'),
                    defaulted$1('stopEvent', true),
                    output('streams', {
                        setup: setup$3,
                        state: throttle,
                    }),
                ],
            }),
        ),
        defaulted$1('event', 'input'),
        option('cancelEvent'),
        onStrictHandler('onStream'),
    ];

    const Streaming = create$1({
        fields: StreamingSchema,
        name: 'streaming',
        active: ActiveStreaming,
        state: StreamingState,
    });

    const setValueFromItem = function(model, input, item) {
        const itemData = Representing.getValue(item);
        Representing.setValue(input, itemData);
        setCursorAtEnd(input);
    };
    const setSelectionOn = function(input, f) {
        const el = input.element();
        const value = get$5(el);
        const node = el.dom();
        if (get$2(el, 'type') !== 'number') {
            f(node, value);
        }
    };
    var setCursorAtEnd = function(input) {
        setSelectionOn(input, function(node, value) {
            return node.setSelectionRange(value.length, value.length);
        });
    };
    const setSelectionToEnd = function(input, startOffset) {
        setSelectionOn(input, function(node, value) {
            return node.setSelectionRange(startOffset, value.length);
        });
    };
    const attemptSelectOver = function(model, input, item) {
        if (!model.selectsOver) {
            return Option.none();
        }
        const currentValue = Representing.getValue(input);
        const inputDisplay_1 = model.getDisplayText(currentValue);
        const itemValue = Representing.getValue(item);
        const itemDisplay = model.getDisplayText(itemValue);
        return itemDisplay.indexOf(inputDisplay_1) === 0
            ? Option.some(function() {
                  setValueFromItem(model, input, item);
                  setSelectionToEnd(input, inputDisplay_1.length);
              })
            : Option.none();
    };

    const itemExecute = constant('alloy.typeahead.itemexecute');

    const make$5 = function(detail, components, spec, externals) {
        const navigateList = function(comp, simulatedEvent, highlighter) {
            detail.previewing.set(false);
            const sandbox = Coupling.getCoupled(comp, 'sandbox');
            if (Sandboxing.isOpen(sandbox)) {
                Composing.getCurrent(sandbox).each(function(menu) {
                    Highlighting.getHighlighted(menu).fold(
                        function() {
                            highlighter(menu);
                        },
                        function() {
                            dispatchEvent(
                                sandbox,
                                menu.element(),
                                'keydown',
                                simulatedEvent,
                            );
                        },
                    );
                });
            } else {
                const onOpenSync = function(sandbox) {
                    Composing.getCurrent(sandbox).each(highlighter);
                };
                open$1(
                    detail,
                    mapFetch(comp),
                    comp,
                    sandbox,
                    externals,
                    onOpenSync,
                    HighlightOnOpen.HighlightFirst,
                ).get(noop);
            }
        };
        const focusBehaviours$1 = focusBehaviours(detail);
        var mapFetch = function(comp) {
            return function(tdata) {
                return tdata.map(function(data) {
                    const menus = values(data.menus);
                    const items = bind(menus, function(menu) {
                        return filter(menu.items, function(item) {
                            return item.type === 'item';
                        });
                    });
                    const repState = Representing.getState(comp);
                    repState.update(
                        map(items, function(item) {
                            return item.data;
                        }),
                    );
                    return data;
                });
            };
        };
        const behaviours = [
            Focusing.config({}),
            Representing.config({
                onSetValue: detail.onSetValue,
                store: {
                    mode: 'dataset',
                    getDataKey(comp) {
                        return get$5(comp.element());
                    },
                    getFallbackEntry(itemString) {
                        return {
                            value: itemString,
                            meta: {},
                        };
                    },
                    setValue(comp, data) {
                        set$3(
                            comp.element(),
                            detail.model.getDisplayText(data),
                        );
                    },
                    ...detail.initialData
                        .map(function(d) {
                            return wrap$1('initialValue', d);
                        })
                        .getOr({}),
                },
            }),
            Streaming.config({
                stream: {
                    mode: 'throttle',
                    delay: detail.responseTime,
                    stopEvent: false,
                },
                onStream(component, simulatedEvent) {
                    const sandbox = Coupling.getCoupled(component, 'sandbox');
                    const focusInInput = Focusing.isFocused(component);
                    if (focusInInput) {
                        if (
                            get$5(component.element()).length >= detail.minChars
                        ) {
                            const previousValue_1 = Composing.getCurrent(
                                sandbox,
                            ).bind(function(menu) {
                                return Highlighting.getHighlighted(menu).map(
                                    Representing.getValue,
                                );
                            });
                            detail.previewing.set(true);
                            const onOpenSync = function(_sandbox) {
                                Composing.getCurrent(sandbox).each(function(
                                    menu,
                                ) {
                                    previousValue_1.fold(
                                        function() {
                                            if (detail.model.selectsOver) {
                                                Highlighting.highlightFirst(
                                                    menu,
                                                );
                                            }
                                        },
                                        function(pv) {
                                            Highlighting.highlightBy(
                                                menu,
                                                function(item) {
                                                    const itemData = Representing.getValue(
                                                        item,
                                                    );
                                                    return (
                                                        itemData.value ===
                                                        pv.value
                                                    );
                                                },
                                            );
                                            Highlighting.getHighlighted(
                                                menu,
                                            ).orThunk(function() {
                                                Highlighting.highlightFirst(
                                                    menu,
                                                );
                                                return Option.none();
                                            });
                                        },
                                    );
                                });
                            };
                            open$1(
                                detail,
                                mapFetch(component),
                                component,
                                sandbox,
                                externals,
                                onOpenSync,
                                HighlightOnOpen.HighlightFirst,
                            ).get(noop);
                        }
                    }
                },
                cancelEvent: typeaheadCancel(),
            }),
            Keying.config({
                mode: 'special',
                onDown(comp, simulatedEvent) {
                    navigateList(
                        comp,
                        simulatedEvent,
                        Highlighting.highlightFirst,
                    );
                    return Option.some(true);
                },
                onEscape(comp) {
                    const sandbox = Coupling.getCoupled(comp, 'sandbox');
                    if (Sandboxing.isOpen(sandbox)) {
                        Sandboxing.close(sandbox);
                        return Option.some(true);
                    }
                    return Option.none();
                },
                onUp(comp, simulatedEvent) {
                    navigateList(
                        comp,
                        simulatedEvent,
                        Highlighting.highlightLast,
                    );
                    return Option.some(true);
                },
                onEnter(comp) {
                    const sandbox = Coupling.getCoupled(comp, 'sandbox');
                    const sandboxIsOpen = Sandboxing.isOpen(sandbox);
                    if (sandboxIsOpen && !detail.previewing.get()) {
                        return Composing.getCurrent(sandbox)
                            .bind(function(menu) {
                                return Highlighting.getHighlighted(menu);
                            })
                            .map(function(item) {
                                emitWith(comp, itemExecute(), { item });
                                return true;
                            });
                    }
                    const currentValue = Representing.getValue(comp);
                    emit(comp, typeaheadCancel());
                    detail.onExecute(sandbox, comp, currentValue);
                    if (sandboxIsOpen) {
                        Sandboxing.close(sandbox);
                    }
                    return Option.some(true);
                },
            }),
            Toggling.config({
                toggleClass: detail.markers.openClass,
                aria: { mode: 'expanded' },
            }),
            Coupling.config({
                others: {
                    sandbox(hotspot) {
                        return makeSandbox(detail, hotspot, {
                            onOpen() {
                                return Toggling.on(hotspot);
                            },
                            onClose() {
                                return Toggling.off(hotspot);
                            },
                        });
                    },
                },
            }),
            config(
                'typeaheadevents',
                [
                    runOnExecute(function(comp) {
                        const onOpenSync = noop;
                        togglePopup(
                            detail,
                            mapFetch(comp),
                            comp,
                            externals,
                            onOpenSync,
                            HighlightOnOpen.HighlightFirst,
                        ).get(noop);
                    }),
                    run(itemExecute(), function(comp, se) {
                        const sandbox = Coupling.getCoupled(comp, 'sandbox');
                        setValueFromItem(detail.model, comp, se.event().item());
                        emit(comp, typeaheadCancel());
                        detail.onItemExecute(
                            comp,
                            sandbox,
                            se.event().item(),
                            Representing.getValue(comp),
                        );
                        Sandboxing.close(sandbox);
                        setCursorAtEnd(comp);
                    }),
                ].concat(
                    detail.dismissOnBlur
                        ? [
                              run(postBlur(), function(typeahead) {
                                  const sandbox = Coupling.getCoupled(
                                      typeahead,
                                      'sandbox',
                                  );
                                  if (search(sandbox.element()).isNone()) {
                                      Sandboxing.close(sandbox);
                                  }
                              }),
                          ]
                        : [],
                ),
            ),
        ];
        return {
            uid: detail.uid,
            dom: dom$2(
                deepMerge(detail, {
                    inputAttributes: {
                        role: 'combobox',
                        'aria-autocomplete': 'list',
                        'aria-haspopup': 'true',
                    },
                }),
            ),
            behaviours: {
                ...focusBehaviours$1,
                ...augment(detail.typeaheadBehaviours, behaviours),
            },
            eventOrder: detail.eventOrder,
        };
    };

    const schema$j = constant(
        [
            option('lazySink'),
            strict$1('fetch'),
            defaulted$1('minChars', 5),
            defaulted$1('responseTime', 1000),
            onHandler('onOpen'),
            defaulted$1('getHotspot', Option.some),
            defaulted$1('getAnchorOverrides', constant({})),
            defaulted$1('layouts', Option.none()),
            defaulted$1('eventOrder', {}),
            defaultedObjOf('model', {}, [
                defaulted$1('getDisplayText', function(itemData) {
                    return itemData.meta !== undefined &&
                        itemData.meta.text !== undefined
                        ? itemData.meta.text
                        : itemData.value;
                }),
                defaulted$1('selectsOver', true),
                defaulted$1('populateFromBrowse', true),
            ]),
            onHandler('onSetValue'),
            onKeyboardHandler('onExecute'),
            onHandler('onItemExecute'),
            defaulted$1('inputClasses', []),
            defaulted$1('inputAttributes', {}),
            defaulted$1('inputStyles', {}),
            defaulted$1('matchWidth', true),
            defaulted$1('useMinWidth', false),
            defaulted$1('dismissOnBlur', true),
            markers(['openClass']),
            option('initialData'),
            field$1('typeaheadBehaviours', [
                Focusing,
                Representing,
                Streaming,
                Keying,
                Toggling,
                Coupling,
            ]),
            state$1('previewing', function() {
                return Cell(true);
            }),
        ]
            .concat(schema$f())
            .concat(sandboxFields()),
    );
    const parts$6 = constant([
        external$1({
            schema: [tieredMenuMarkers()],
            name: 'menu',
            overrides(detail) {
                return {
                    fakeFocus: true,
                    onHighlight(menu, item) {
                        if (!detail.previewing.get()) {
                            menu.getSystem()
                                .getByUid(detail.uid)
                                .each(function(input) {
                                    if (detail.model.populateFromBrowse) {
                                        setValueFromItem(
                                            detail.model,
                                            input,
                                            item,
                                        );
                                    }
                                });
                        } else {
                            menu.getSystem()
                                .getByUid(detail.uid)
                                .each(function(input) {
                                    attemptSelectOver(
                                        detail.model,
                                        input,
                                        item,
                                    ).fold(
                                        function() {
                                            return Highlighting.dehighlight(
                                                menu,
                                                item,
                                            );
                                        },
                                        function(fn) {
                                            return fn();
                                        },
                                    );
                                });
                        }
                        detail.previewing.set(false);
                    },
                    onExecute(menu, item) {
                        return menu
                            .getSystem()
                            .getByUid(detail.uid)
                            .toOption()
                            .map(function(typeahead) {
                                emitWith(typeahead, itemExecute(), {
                                    item,
                                });
                                return true;
                            });
                    },
                    onHover(menu, item) {
                        detail.previewing.set(false);
                        menu.getSystem()
                            .getByUid(detail.uid)
                            .each(function(input) {
                                if (detail.model.populateFromBrowse) {
                                    setValueFromItem(detail.model, input, item);
                                }
                            });
                    },
                };
            },
        }),
    ]);

    const Typeahead = composite$1({
        name: 'Typeahead',
        configFields: schema$j(),
        partFields: parts$6(),
        factory: make$5,
    });

    var wrap$2 = function(delegate) {
        const toCached = function() {
            return wrap$2(delegate.toCached());
        };
        const bindFuture = function(f) {
            return wrap$2(
                delegate.bind(function(resA) {
                    return resA.fold(
                        function(err) {
                            return Future.pure(Result.error(err));
                        },
                        function(a) {
                            return f(a);
                        },
                    );
                }),
            );
        };
        const bindResult = function(f) {
            return wrap$2(
                delegate.map(function(resA) {
                    return resA.bind(f);
                }),
            );
        };
        const mapResult = function(f) {
            return wrap$2(
                delegate.map(function(resA) {
                    return resA.map(f);
                }),
            );
        };
        const mapError = function(f) {
            return wrap$2(
                delegate.map(function(resA) {
                    return resA.mapError(f);
                }),
            );
        };
        const foldResult = function(whenError, whenValue) {
            return delegate.map(function(res) {
                return res.fold(whenError, whenValue);
            });
        };
        const withTimeout = function(timeout, errorThunk) {
            return wrap$2(
                Future.nu(function(callback) {
                    let timedOut = false;
                    const timer = domGlobals.setTimeout(function() {
                        timedOut = true;
                        callback(Result.error(errorThunk()));
                    }, timeout);
                    delegate.get(function(result) {
                        if (!timedOut) {
                            domGlobals.clearTimeout(timer);
                            callback(result);
                        }
                    });
                }),
            );
        };
        return {
            ...delegate,
            toCached,
            bindFuture,
            bindResult,
            mapResult,
            mapError,
            foldResult,
            withTimeout,
        };
    };
    const nu$c = function(worker) {
        return wrap$2(Future.nu(worker));
    };
    const value$2 = function(value) {
        return wrap$2(Future.pure(Result.value(value)));
    };
    const error$1 = function(error) {
        return wrap$2(Future.pure(Result.error(error)));
    };
    const fromResult$1 = function(result) {
        return wrap$2(Future.pure(result));
    };
    const fromFuture = function(future) {
        return wrap$2(future.map(Result.value));
    };
    const fromPromise = function(promise) {
        return nu$c(function(completer) {
            promise.then(
                function(value) {
                    completer(Result.value(value));
                },
                function(error) {
                    completer(Result.error(error));
                },
            );
        });
    };
    const FutureResult = {
        nu: nu$c,
        wrap: wrap$2,
        pure: value$2,
        value: value$2,
        error: error$1,
        fromResult: fromResult$1,
        fromFuture,
        fromPromise,
    };

    const separator$2 = { type: 'separator' };
    const toMenuItem = function(target) {
        return {
            type: 'menuitem',
            value: target.url,
            text: target.title,
            meta: { attach: target.attach },
            onAction() {},
        };
    };
    const staticMenuItem = function(title, url) {
        return {
            type: 'menuitem',
            value: url,
            text: title,
            meta: { attach: undefined },
            onAction() {},
        };
    };
    const toMenuItems = function(targets) {
        return map(targets, toMenuItem);
    };
    const filterLinkTargets = function(type, targets) {
        return filter(targets, function(target) {
            return target.type === type;
        });
    };
    const filteredTargets = function(type, targets) {
        return toMenuItems(filterLinkTargets(type, targets));
    };
    const headerTargets = function(linkInfo) {
        return filteredTargets('header', linkInfo.targets);
    };
    const anchorTargets = function(linkInfo) {
        return filteredTargets('anchor', linkInfo.targets);
    };
    const anchorTargetTop = function(linkInfo) {
        return Option.from(linkInfo.anchorTop)
            .map(function(url) {
                return staticMenuItem('<top>', url);
            })
            .toArray();
    };
    const anchorTargetBottom = function(linkInfo) {
        return Option.from(linkInfo.anchorBottom)
            .map(function(url) {
                return staticMenuItem('<bottom>', url);
            })
            .toArray();
    };
    const historyTargets = function(history) {
        return map(history, function(url) {
            return staticMenuItem(url, url);
        });
    };
    const joinMenuLists = function(items) {
        return foldl(
            items,
            function(a, b) {
                const bothEmpty = a.length === 0 || b.length === 0;
                return bothEmpty ? a.concat(b) : a.concat(separator$2, b);
            },
            [],
        );
    };
    const filterByQuery = function(term, menuItems) {
        const lowerCaseTerm = term.toLowerCase();
        return filter(menuItems, function(item) {
            const text =
                item.meta !== undefined && item.meta.text !== undefined
                    ? item.meta.text
                    : item.text;
            return (
                contains$1(text.toLowerCase(), lowerCaseTerm) ||
                contains$1(item.value.toLowerCase(), lowerCaseTerm)
            );
        });
    };

    const getItems = function(fileType, input, urlBackstage) {
        const urlInputValue = Representing.getValue(input);
        const term =
            urlInputValue.meta.text !== undefined
                ? urlInputValue.meta.text
                : urlInputValue.value;
        const info = urlBackstage.getLinkInformation();
        return info.fold(
            function() {
                return [];
            },
            function(linkInfo) {
                const history = filterByQuery(
                    term,
                    historyTargets(urlBackstage.getHistory(fileType)),
                );
                return fileType === 'file'
                    ? joinMenuLists([
                          history,
                          filterByQuery(term, headerTargets(linkInfo)),
                          filterByQuery(
                              term,
                              flatten([
                                  anchorTargetTop(linkInfo),
                                  anchorTargets(linkInfo),
                                  anchorTargetBottom(linkInfo),
                              ]),
                          ),
                      ])
                    : history;
            },
        );
    };
    const errorId = generate$1('aria-invalid');
    const renderUrlInput = function(spec, backstage, urlBackstage) {
        let _a;
        const providersBackstage = backstage.shared.providers;
        const updateHistory = function(component) {
            const urlEntry = Representing.getValue(component);
            urlBackstage.addToHistory(urlEntry.value, spec.filetype);
        };
        const pField = FormField.parts().field({
            factory: Typeahead,
            dismissOnBlur: true,
            inputClasses: ['tox-textfield'],
            sandboxClasses: ['tox-dialog__popups'],
            inputAttributes: {
                'aria-errormessage': errorId,
                type: 'url',
            },
            minChars: 0,
            responseTime: 0,
            fetch(input) {
                const items = getItems(spec.filetype, input, urlBackstage);
                const tdata = build$2(
                    items,
                    ItemResponse$1.BUBBLE_TO_SANDBOX,
                    backstage,
                    false,
                );
                return Future.pure(tdata);
            },
            getHotspot(comp) {
                return memUrlBox.getOpt(comp);
            },
            onSetValue(comp, newValue) {
                if (comp.hasConfigured(Invalidating)) {
                    Invalidating.run(comp).get(noop);
                }
            },
            typeaheadBehaviours: derive$1(
                flatten([
                    urlBackstage
                        .getValidationHandler()
                        .map(function(handler) {
                            return Invalidating.config({
                                getRoot(comp) {
                                    return parent(comp.element());
                                },
                                invalidClass:
                                    'tox-control-wrap--status-invalid',
                                notify: {
                                    onInvalid(comp, err) {
                                        memInvalidIcon
                                            .getOpt(comp)
                                            .each(function(invalidComp) {
                                                set$1(
                                                    invalidComp.element(),
                                                    'title',
                                                    providersBackstage.translate(
                                                        err,
                                                    ),
                                                );
                                            });
                                    },
                                },
                                validator: {
                                    validate(input) {
                                        const urlEntry = Representing.getValue(
                                            input,
                                        );
                                        return FutureResult.nu(function(
                                            completer,
                                        ) {
                                            handler(
                                                {
                                                    type: spec.filetype,
                                                    url: urlEntry.value,
                                                },
                                                function(validation) {
                                                    if (
                                                        validation.status ===
                                                        'invalid'
                                                    ) {
                                                        const err = Result.error(
                                                            validation.message,
                                                        );
                                                        completer(err);
                                                    } else {
                                                        const val = Result.value(
                                                            validation.message,
                                                        );
                                                        completer(val);
                                                    }
                                                },
                                            );
                                        });
                                    },
                                    validateOnLoad: false,
                                },
                            });
                        })
                        .toArray(),
                    [
                        Disabling.config({ disabled: spec.disabled }),
                        Tabstopping.config({}),
                        config(
                            'urlinput-events',
                            flatten([
                                spec.filetype === 'file'
                                    ? [
                                          run(input(), function(comp) {
                                              emitWith(comp, formChangeEvent, {
                                                  name: spec.name,
                                              });
                                          }),
                                      ]
                                    : [],
                                [
                                    run(change(), function(comp) {
                                        emitWith(comp, formChangeEvent, {
                                            name: spec.name,
                                        });
                                        updateHistory(comp);
                                    }),
                                    run(postPaste(), function(comp) {
                                        emitWith(comp, formChangeEvent, {
                                            name: spec.name,
                                        });
                                        updateHistory(comp);
                                    }),
                                ],
                            ]),
                        ),
                    ],
                ]),
            ),
            eventOrder:
                ((_a = {}),
                (_a[input()] = [
                    'streaming',
                    'urlinput-events',
                    'invalidating',
                ]),
                _a),
            model: {
                getDisplayText(itemData) {
                    return itemData.value;
                },
                selectsOver: false,
                populateFromBrowse: false,
            },
            markers: { openClass: 'tox-textfield--popup-open' },
            lazySink: backstage.shared.getSink,
            parts: { menu: part(false, 1, 'normal') },
            onExecute(_menu, component, _entry) {
                emitWith(component, formSubmitEvent, {});
            },
            onItemExecute(typeahead, _sandbox, _item, _value) {
                updateHistory(typeahead);
                emitWith(typeahead, formChangeEvent, { name: spec.name });
            },
        });
        const pLabel = spec.label.map(function(label) {
            return renderLabel(label, providersBackstage);
        });
        const makeIcon = function(name, errId, icon, label) {
            if (icon === void 0) {
                icon = name;
            }
            if (label === void 0) {
                label = name;
            }
            return {
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-icon',
                        `tox-control-wrap__status-icon-${name}`,
                    ],
                    innerHtml: get$c(icon, providersBackstage.icons),
                    attributes: {
                        title: providersBackstage.translate(label),
                        'aria-live': 'polite',
                        ...errId.fold(
                            function() {
                                return {};
                            },
                            function(id) {
                                return { id };
                            },
                        ),
                    },
                },
            };
        };
        var memInvalidIcon = record(
            makeIcon('invalid', Option.some(errorId), 'warning'),
        );
        const memStatus = record({
            dom: {
                tag: 'div',
                classes: ['tox-control-wrap__status-icon-wrap'],
            },
            components: [memInvalidIcon.asSpec()],
        });
        const optUrlPicker = urlBackstage.getUrlPicker(spec.filetype);
        const browseUrlEvent = generate$1('browser.url.event');
        var memUrlBox = record({
            dom: {
                tag: 'div',
                classes: ['tox-control-wrap'],
            },
            components: [pField, memStatus.asSpec()],
            behaviours: derive$1([
                Disabling.config({ disabled: spec.disabled }),
            ]),
        });
        const memUrlPickerButton = record(
            renderButton(
                {
                    name: spec.name,
                    icon: Option.some('browse'),
                    text: spec.label.getOr(''),
                    disabled: spec.disabled,
                    primary: false,
                    borderless: true,
                },
                function(component) {
                    return emit(component, browseUrlEvent);
                },
                providersBackstage,
                [],
                ['tox-browse-url'],
            ),
        );
        const controlHWrapper = function() {
            return {
                dom: {
                    tag: 'div',
                    classes: ['tox-form__controls-h-stack'],
                },
                components: flatten([
                    [memUrlBox.asSpec()],
                    optUrlPicker
                        .map(function() {
                            return memUrlPickerButton.asSpec();
                        })
                        .toArray(),
                ]),
            };
        };
        const openUrlPicker = function(comp) {
            Composing.getCurrent(comp).each(function(field) {
                const urlData = Representing.getValue(field);
                optUrlPicker.each(function(picker) {
                    picker(urlData).get(function(chosenData) {
                        Representing.setValue(field, chosenData);
                        emitWith(comp, formChangeEvent, { name: spec.name });
                    });
                });
            });
        };
        return FormField.sketch({
            dom: renderFormFieldDom(),
            components: pLabel.toArray().concat([controlHWrapper()]),
            fieldBehaviours: derive$1([
                Disabling.config({
                    disabled: spec.disabled,
                    onDisabled(comp) {
                        FormField.getField(comp).each(Disabling.disable);
                        memUrlPickerButton.getOpt(comp).each(Disabling.disable);
                    },
                    onEnabled(comp) {
                        FormField.getField(comp).each(Disabling.enable);
                        memUrlPickerButton.getOpt(comp).each(Disabling.enable);
                    },
                }),
                config('url-input-events', [
                    run(browseUrlEvent, openUrlPicker),
                ]),
            ]),
        });
    };

    const renderCheckbox = function(spec, providerBackstage) {
        const repBehaviour = Representing.config({
            store: {
                mode: 'manual',
                getValue(comp) {
                    const el = comp.element().dom();
                    return el.checked;
                },
                setValue(comp, value) {
                    const el = comp.element().dom();
                    el.checked = value;
                },
            },
        });
        const toggleCheckboxHandler = function(comp) {
            comp.element()
                .dom()
                .click();
            return Option.some(true);
        };
        const pField = FormField.parts().field({
            factory: { sketch: identity },
            dom: {
                tag: 'input',
                classes: ['tox-checkbox__input'],
                attributes: { type: 'checkbox' },
            },
            behaviours: derive$1([
                ComposingConfigs.self(),
                Disabling.config({ disabled: spec.disabled }),
                Tabstopping.config({}),
                Focusing.config({}),
                repBehaviour,
                Keying.config({
                    mode: 'special',
                    onEnter: toggleCheckboxHandler,
                    onSpace: toggleCheckboxHandler,
                    stopSpaceKeyup: true,
                }),
                config('checkbox-events', [
                    run(change(), function(component, _) {
                        emitWith(component, formChangeEvent, {
                            name: spec.name,
                        });
                    }),
                ]),
            ]),
        });
        const pLabel = FormField.parts().label({
            dom: {
                tag: 'span',
                classes: ['tox-checkbox__label'],
                innerHtml: providerBackstage.translate(spec.label),
            },
            behaviours: derive$1([Unselecting.config({})]),
        });
        const makeIcon = function(className) {
            const iconName =
                className === 'checked' ? 'selected' : 'unselected';
            return {
                dom: {
                    tag: 'span',
                    classes: ['tox-icon', `tox-checkbox-icon__${className}`],
                    innerHtml: get$c(iconName, providerBackstage.icons),
                },
            };
        };
        const memIcons = record({
            dom: {
                tag: 'div',
                classes: ['tox-checkbox__icons'],
            },
            components: [makeIcon('checked'), makeIcon('unchecked')],
        });
        return FormField.sketch({
            dom: {
                tag: 'label',
                classes: ['tox-checkbox'],
            },
            components: [pField, memIcons.asSpec(), pLabel],
            fieldBehaviours: derive$1([
                Disabling.config({
                    disabled: spec.disabled,
                    disableClass: 'tox-checkbox--disabled',
                    onDisabled(comp) {
                        FormField.getField(comp).each(Disabling.disable);
                    },
                    onEnabled(comp) {
                        FormField.getField(comp).each(Disabling.enable);
                    },
                }),
            ]),
        });
    };

    const renderHtmlPanel = function(spec) {
        if (spec.presets === 'presentation') {
            return Container.sketch({
                dom: {
                    tag: 'div',
                    classes: ['tox-form__group'],
                    innerHtml: spec.html,
                },
            });
        }
        return Container.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-form__group'],
                innerHtml: spec.html,
                attributes: { role: 'document' },
            },
            containerBehaviours: derive$1([
                Tabstopping.config({}),
                Focusing.config({}),
            ]),
        });
    };

    const renderLabel$2 = function(spec, backstageShared) {
        const label = {
            dom: {
                tag: 'label',
                innerHtml: backstageShared.providers.translate(spec.label),
                classes: ['tox-label'],
            },
        };
        const comps = map(spec.items, backstageShared.interpreter);
        return {
            dom: {
                tag: 'div',
                classes: ['tox-form__group'],
            },
            components: [label].concat(comps),
            behaviours: derive$1([
                ComposingConfigs.self(),
                Replacing.config({}),
                RepresentingConfigs.domHtml(Option.none()),
                Keying.config({ mode: 'acyclic' }),
            ]),
        };
    };

    const renderCollection = function(spec, providersBackstage) {
        const pLabel = spec.label.map(function(label) {
            return renderLabel(label, providersBackstage);
        });
        const runOnItem = function(f) {
            return function(comp, se) {
                closest$3(
                    se.event().target(),
                    '[data-collection-item-value]',
                ).each(function(target) {
                    f(
                        comp,
                        se,
                        target,
                        get$2(target, 'data-collection-item-value'),
                    );
                });
            };
        };
        const escapeAttribute = function(ch) {
            if (ch === '"') {
                return '&quot;';
            }
            return ch;
        };
        const setContents = function(comp, items) {
            const htmlLines = map(items, function(item) {
                const itemText = global$5.translate(item.text);
                const textContent =
                    spec.columns === 1
                        ? `<div class="tox-collection__item-label">${itemText}</div>`
                        : '';
                const iconContent = `<div class="tox-collection__item-icon">${item.icon}</div>`;
                const mapItemName = {
                    _: ' ',
                    ' - ': ' ',
                    '-': ' ',
                };
                const ariaLabel = itemText.replace(/\_| \- |\-/g, function(
                    match,
                ) {
                    return mapItemName[match];
                });
                return `<div class="tox-collection__item" tabindex="-1" data-collection-item-value="${escapeAttribute(
                    item.value,
                )}" title="${ariaLabel}" aria-label="${ariaLabel}">${iconContent}${textContent}</div>`;
            });
            const chunks =
                spec.columns > 1 && spec.columns !== 'auto'
                    ? chunk(htmlLines, spec.columns)
                    : [htmlLines];
            const html = map(chunks, function(ch) {
                return `<div class="tox-collection__group">${ch.join(
                    '',
                )}</div>`;
            });
            set(comp.element(), html.join(''));
        };
        const onClick = runOnItem(function(comp, se, tgt, itemValue) {
            se.stop();
            emitWith(comp, formActionEvent, {
                name: spec.name,
                value: itemValue,
            });
        });
        const collectionEvents = [
            run(
                mouseover(),
                runOnItem(function(comp, se, tgt) {
                    focus$1(tgt);
                }),
            ),
            run(click(), onClick),
            run(tap(), onClick),
            run(
                focusin(),
                runOnItem(function(comp, se, tgt) {
                    descendant$1(comp.element(), `.${activeClass}`).each(
                        function(currentActive) {
                            remove$4(currentActive, activeClass);
                        },
                    );
                    add$2(tgt, activeClass);
                }),
            ),
            run(
                focusout(),
                runOnItem(function(comp) {
                    descendant$1(comp.element(), `.${activeClass}`).each(
                        function(currentActive) {
                            remove$4(currentActive, activeClass);
                        },
                    );
                }),
            ),
            runOnExecute(
                runOnItem(function(comp, se, tgt, itemValue) {
                    emitWith(comp, formActionEvent, {
                        name: spec.name,
                        value: itemValue,
                    });
                }),
            ),
        ];
        const pField = FormField.parts().field({
            dom: {
                tag: 'div',
                classes: ['tox-collection'].concat(
                    spec.columns !== 1
                        ? ['tox-collection--grid']
                        : ['tox-collection--list'],
                ),
            },
            components: [],
            factory: { sketch: identity },
            behaviours: derive$1([
                Replacing.config({}),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: [],
                    },
                    onSetValue(comp, items) {
                        setContents(comp, items);
                        if (spec.columns === 'auto') {
                            detectSize(comp, 5, 'tox-collection__item').each(
                                function(_a) {
                                    const { numRows } = _a;
                                    const { numColumns } = _a;
                                    Keying.setGridSize(
                                        comp,
                                        numRows,
                                        numColumns,
                                    );
                                },
                            );
                        }
                        emit(comp, formResizeEvent);
                    },
                }),
                Tabstopping.config({}),
                Keying.config(deriveCollectionMovement(spec.columns, 'normal')),
                config('collection-events', collectionEvents),
            ]),
        });
        const extraClasses = ['tox-form__group--collection'];
        return renderFormFieldWith(pLabel, pField, extraClasses, []);
    };

    const renderTable = function(spec, providersBackstage) {
        const renderTh = function(text) {
            return {
                dom: {
                    tag: 'th',
                    innerHtml: providersBackstage.translate(text),
                },
            };
        };
        const renderHeader = function(header) {
            return {
                dom: { tag: 'thead' },
                components: [
                    {
                        dom: { tag: 'tr' },
                        components: map(header, renderTh),
                    },
                ],
            };
        };
        const renderTd = function(text) {
            return {
                dom: {
                    tag: 'td',
                    innerHtml: providersBackstage.translate(text),
                },
            };
        };
        const renderTr = function(row) {
            return {
                dom: { tag: 'tr' },
                components: map(row, renderTd),
            };
        };
        const renderRows = function(rows) {
            return {
                dom: { tag: 'tbody' },
                components: map(rows, renderTr),
            };
        };
        return {
            dom: {
                tag: 'table',
                classes: ['tox-dialog__table'],
            },
            components: [renderHeader(spec.header), renderRows(spec.cells)],
            behaviours: derive$1([Tabstopping.config({}), Focusing.config({})]),
        };
    };

    const renderPanel = function(spec, backstage) {
        return {
            dom: {
                tag: 'div',
                classes: spec.classes,
            },
            components: map(spec.items, backstage.shared.interpreter),
        };
    };

    const make$6 = function(render) {
        return function(parts, spec, backstage) {
            return readOptFrom$1(spec, 'name').fold(
                function() {
                    return render(spec, backstage);
                },
                function(fieldName) {
                    return parts.field(fieldName, render(spec, backstage));
                },
            );
        };
    };
    const makeIframe = function(render) {
        return function(parts, spec, backstage) {
            const iframeSpec = deepMerge(spec, { source: 'dynamic' });
            return make$6(render)(parts, iframeSpec, backstage);
        };
    };
    const factories = {
        bar: make$6(function(spec, backstage) {
            return renderBar(spec, backstage.shared);
        }),
        collection: make$6(function(spec, backstage) {
            return renderCollection(spec, backstage.shared.providers);
        }),
        alertbanner: make$6(function(spec, backstage) {
            return renderAlertBanner(spec, backstage.shared.providers);
        }),
        input: make$6(function(spec, backstage) {
            return renderInput(spec, backstage.shared.providers);
        }),
        textarea: make$6(function(spec, backstage) {
            return renderTextarea(spec, backstage.shared.providers);
        }),
        label: make$6(function(spec, backstage) {
            return renderLabel$2(spec, backstage.shared);
        }),
        iframe: makeIframe(function(spec, backstage) {
            return renderIFrame(spec, backstage.shared.providers);
        }),
        button: make$6(function(spec, backstage) {
            return renderDialogButton(spec, backstage.shared.providers);
        }),
        checkbox: make$6(function(spec, backstage) {
            return renderCheckbox(spec, backstage.shared.providers);
        }),
        colorinput: make$6(function(spec, backstage) {
            return renderColorInput(
                spec,
                backstage.shared,
                backstage.colorinput,
            );
        }),
        colorpicker: make$6(renderColorPicker),
        dropzone: make$6(function(spec, backstage) {
            return renderDropZone(spec, backstage.shared.providers);
        }),
        grid: make$6(function(spec, backstage) {
            return renderGrid(spec, backstage.shared);
        }),
        selectbox: make$6(function(spec, backstage) {
            return renderSelectBox(spec, backstage.shared.providers);
        }),
        sizeinput: make$6(function(spec, backstage) {
            return renderSizeInput(spec, backstage.shared.providers);
        }),
        urlinput: make$6(function(spec, backstage) {
            return renderUrlInput(spec, backstage, backstage.urlinput);
        }),
        customeditor: make$6(renderCustomEditor),
        htmlpanel: make$6(renderHtmlPanel),
        imagetools: make$6(function(spec, backstage) {
            return renderImageTools(spec, backstage.shared.providers);
        }),
        table: make$6(function(spec, backstage) {
            return renderTable(spec, backstage.shared.providers);
        }),
        panel: make$6(function(spec, backstage) {
            return renderPanel(spec, backstage);
        }),
    };
    const noFormParts = {
        field(_name, spec) {
            return spec;
        },
    };
    const interpretInForm = function(parts, spec, oldBackstage) {
        var newBackstage = deepMerge(oldBackstage, {
            shared: {
                interpreter(childSpec) {
                    return interpretParts(parts, childSpec, newBackstage);
                },
            },
        });
        return interpretParts(parts, spec, newBackstage);
    };
    var interpretParts = function(parts, spec, backstage) {
        return readOptFrom$1(factories, spec.type).fold(
            function() {
                domGlobals.console.error(
                    `Unknown factory type "${spec.type}", defaulting to container: `,
                    spec,
                );
                return spec;
            },
            function(factory) {
                return factory(parts, spec, backstage);
            },
        );
    };
    const interpretWithoutForm = function(spec, backstage) {
        const parts = noFormParts;
        return interpretParts(parts, spec, backstage);
    };

    const expandable$1 = constant(function(element, available) {
        setMax$1(element, Math.floor(available));
    });

    const bubbleAlignments = {
        valignCentre: [],
        alignCentre: [],
        alignLeft: [],
        alignRight: [],
        right: [],
        left: [],
        bottom: [],
        top: [],
    };
    const getToolbarAnchor = function(
        bodyElement,
        lazyAnchorbar,
        useFixedToolbarContainer,
    ) {
        const fixedToolbarAnchor = function() {
            return {
                anchor: 'node',
                root: bodyElement(),
                node: Option.from(bodyElement()),
                bubble: nu$8(-12, -12, bubbleAlignments),
                layouts: {
                    onRtl() {
                        return [northeast$3];
                    },
                    onLtr() {
                        return [northwest$3];
                    },
                },
                overrides: { maxHeightFunction: expandable() },
            };
        };
        const standardAnchor = function() {
            return {
                anchor: 'hotspot',
                hotspot: lazyAnchorbar(),
                bubble: nu$8(-12, 12, bubbleAlignments),
                layouts: {
                    onRtl() {
                        return [southeast$1];
                    },
                    onLtr() {
                        return [southwest$1];
                    },
                },
                overrides: { maxHeightFunction: expandable() },
            };
        };
        return useFixedToolbarContainer ? fixedToolbarAnchor : standardAnchor;
    };
    const getBannerAnchor = function(
        bodyElement,
        lazyAnchorbar,
        useFixedToolbarContainer,
    ) {
        const fixedToolbarAnchor = function() {
            return {
                anchor: 'node',
                root: bodyElement(),
                node: Option.from(bodyElement()),
                layouts: {
                    onRtl() {
                        return [north$3];
                    },
                    onLtr() {
                        return [north$3];
                    },
                },
            };
        };
        const standardAnchor = function() {
            return {
                anchor: 'hotspot',
                hotspot: lazyAnchorbar(),
                layouts: {
                    onRtl() {
                        return [south$1];
                    },
                    onLtr() {
                        return [south$1];
                    },
                },
            };
        };
        return useFixedToolbarContainer ? fixedToolbarAnchor : standardAnchor;
    };
    const getToolbarOverflowAnchor = function(lazyMoreButton) {
        return function() {
            return {
                anchor: 'hotspot',
                hotspot: lazyMoreButton(),
                overrides: { maxWidthFunction: expandable$1() },
                layouts: {
                    onRtl() {
                        return [southeast$1, southwest$1];
                    },
                    onLtr() {
                        return [southwest$1, southeast$1];
                    },
                },
            };
        };
    };
    const getCursorAnchor = function(editor, bodyElement) {
        return function() {
            return {
                anchor: 'selection',
                root: bodyElement(),
                getSelection() {
                    const rng = editor.selection.getRng();
                    return Option.some(
                        Selection.range(
                            Element.fromDom(rng.startContainer),
                            rng.startOffset,
                            Element.fromDom(rng.endContainer),
                            rng.endOffset,
                        ),
                    );
                },
            };
        };
    };
    const getNodeAnchor = function(bodyElement) {
        return function(element) {
            return {
                anchor: 'node',
                root: bodyElement(),
                node: element,
            };
        };
    };
    const getAnchors = function(editor, lazyAnchorbar, lazyMoreButton) {
        const useFixedToolbarContainer = useFixedContainer(editor);
        const bodyElement = function() {
            return Element.fromDom(editor.getBody());
        };
        return {
            toolbar: getToolbarAnchor(
                bodyElement,
                lazyAnchorbar,
                useFixedToolbarContainer,
            ),
            toolbarOverflow: getToolbarOverflowAnchor(lazyMoreButton),
            banner: getBannerAnchor(
                bodyElement,
                lazyAnchorbar,
                useFixedToolbarContainer,
            ),
            cursor: getCursorAnchor(editor, bodyElement),
            node: getNodeAnchor(bodyElement),
        };
    };
    const Anchors = { getAnchors };

    const colorPicker = function(editor) {
        return function(callback, value) {
            const dialog = ColorSwatch.colorPickerDialog(editor);
            dialog(callback, value);
        };
    };
    const hasCustomColors$1 = function(editor) {
        return function() {
            return Settings.hasCustomColors(editor);
        };
    };
    const getColors$1 = function(editor) {
        return function() {
            return Settings.getColors(editor);
        };
    };
    const getColorCols$2 = function(editor) {
        return function() {
            return ColorSwatch.getColorCols(editor);
        };
    };
    const ColorInputBackstage = function(editor) {
        return {
            colorPicker: colorPicker(editor),
            hasCustomColors: hasCustomColors$1(editor),
            getColors: getColors$1(editor),
            getColorCols: getColorCols$2(editor),
        };
    };

    const isDraggableModal$1 = function(editor) {
        return function() {
            return isDraggableModal(editor);
        };
    };
    const DialogBackstage = function(editor) {
        return { isDraggableModal: isDraggableModal$1(editor) };
    };

    const defaultStyleFormats = [
        {
            title: 'Headings',
            items: [
                {
                    title: 'Heading 1',
                    format: 'h1',
                },
                {
                    title: 'Heading 2',
                    format: 'h2',
                },
                {
                    title: 'Heading 3',
                    format: 'h3',
                },
                {
                    title: 'Heading 4',
                    format: 'h4',
                },
                {
                    title: 'Heading 5',
                    format: 'h5',
                },
                {
                    title: 'Heading 6',
                    format: 'h6',
                },
            ],
        },
        {
            title: 'Inline',
            items: [
                {
                    title: 'Bold',
                    icon: 'bold',
                    format: 'bold',
                },
                {
                    title: 'Italic',
                    icon: 'italic',
                    format: 'italic',
                },
                {
                    title: 'Underline',
                    icon: 'underline',
                    format: 'underline',
                },
                {
                    title: 'Strikethrough',
                    icon: 'strike-through',
                    format: 'strikethrough',
                },
                {
                    title: 'Superscript',
                    icon: 'superscript',
                    format: 'superscript',
                },
                {
                    title: 'Subscript',
                    icon: 'subscript',
                    format: 'subscript',
                },
                {
                    title: 'Code',
                    icon: 'code',
                    format: 'code',
                },
            ],
        },
        {
            title: 'Blocks',
            items: [
                {
                    title: 'Paragraph',
                    format: 'p',
                },
                {
                    title: 'Blockquote',
                    format: 'blockquote',
                },
                {
                    title: 'Div',
                    format: 'div',
                },
                {
                    title: 'Pre',
                    format: 'pre',
                },
            ],
        },
        {
            title: 'Align',
            items: [
                {
                    title: 'Left',
                    icon: 'align-left',
                    format: 'alignleft',
                },
                {
                    title: 'Center',
                    icon: 'align-center',
                    format: 'aligncenter',
                },
                {
                    title: 'Right',
                    icon: 'align-right',
                    format: 'alignright',
                },
                {
                    title: 'Justify',
                    icon: 'align-justify',
                    format: 'alignjustify',
                },
            ],
        },
    ];
    const isNestedFormat = function(format) {
        return has(format, 'items');
    };
    const isBlockFormat = function(format) {
        return has(format, 'block');
    };
    const isInlineFormat = function(format) {
        return has(format, 'inline');
    };
    const isSelectorFormat = function(format) {
        return has(format, 'selector');
    };
    var mapFormats = function(userFormats) {
        return foldl(
            userFormats,
            function(acc, fmt) {
                if (isNestedFormat(fmt)) {
                    const result = mapFormats(fmt.items);
                    return {
                        customFormats: acc.customFormats.concat(
                            result.customFormats,
                        ),
                        formats: acc.formats.concat([
                            {
                                title: fmt.title,
                                items: result.formats,
                            },
                        ]),
                    };
                }
                if (
                    isInlineFormat(fmt) ||
                    isBlockFormat(fmt) ||
                    isSelectorFormat(fmt)
                ) {
                    const formatName = `custom-${fmt.title.toLowerCase()}`;
                    return {
                        customFormats: acc.customFormats.concat([
                            {
                                name: formatName,
                                format: fmt,
                            },
                        ]),
                        formats: acc.formats.concat([
                            {
                                title: fmt.title,
                                format: formatName,
                                icon: fmt.icon,
                            },
                        ]),
                    };
                }
                return { ...acc, formats: acc.formats.concat(fmt) };
            },
            {
                customFormats: [],
                formats: [],
            },
        );
    };
    const registerCustomFormats = function(editor, userFormats) {
        const result = mapFormats(userFormats);
        const registerFormats = function(customFormats) {
            each(customFormats, function(fmt) {
                if (!editor.formatter.has(fmt.name)) {
                    editor.formatter.register(fmt.name, fmt.format);
                }
            });
        };
        if (editor.formatter) {
            registerFormats(result.customFormats);
        } else {
            editor.on('init', function() {
                registerFormats(result.customFormats);
            });
        }
        return result.formats;
    };
    const getStyleFormats = function(editor) {
        return getUserStyleFormats(editor)
            .map(function(userFormats) {
                const registeredUserFormats = registerCustomFormats(
                    editor,
                    userFormats,
                );
                return isMergeStyleFormats(editor)
                    ? defaultStyleFormats.concat(registeredUserFormats)
                    : registeredUserFormats;
            })
            .getOr(defaultStyleFormats);
    };

    const processBasic = function(item, isSelectedFor, getPreviewFor) {
        const formatterSpec = {
            type: 'formatter',
            isSelected: isSelectedFor(item.format),
            getStylePreview: getPreviewFor(item.format),
        };
        return deepMerge(item, formatterSpec);
    };
    const register$3 = function(editor, formats, isSelectedFor, getPreviewFor) {
        const enrichSupported = function(item) {
            return processBasic(item, isSelectedFor, getPreviewFor);
        };
        const enrichMenu = function(item) {
            const submenuSpec = {
                type: 'submenu',
                isSelected: constant(false),
                getStylePreview() {
                    return Option.none();
                },
            };
            return deepMerge(item, submenuSpec);
        };
        const enrichCustom = function(item) {
            const formatName = generate$1(item.title);
            const customSpec = {
                type: 'formatter',
                format: formatName,
                isSelected: isSelectedFor(formatName),
                getStylePreview: getPreviewFor(formatName),
            };
            const newItem = deepMerge(item, customSpec);
            editor.formatter.register(formatName, newItem);
            return newItem;
        };
        var doEnrich = function(items) {
            return map(items, function(item) {
                const keys$1 = keys(item);
                if (hasKey$1(item, 'items')) {
                    const newItems_1 = doEnrich(item.items);
                    return deepMerge(enrichMenu(item), {
                        getStyleItems() {
                            return newItems_1;
                        },
                    });
                }
                if (hasKey$1(item, 'format')) {
                    return enrichSupported(item);
                }
                if (keys$1.length === 1 && contains(keys$1, 'title')) {
                    return deepMerge(item, { type: 'separator' });
                }
                return enrichCustom(item);
            });
        };
        return doEnrich(formats);
    };

    const init$7 = function(editor) {
        const isSelectedFor = function(format) {
            return function() {
                return editor.formatter.match(format);
            };
        };
        const getPreviewFor = function(format) {
            return function() {
                const fmt = editor.formatter.get(format);
                return fmt !== undefined
                    ? Option.some({
                          tag:
                              fmt.length > 0
                                  ? fmt[0].inline || fmt[0].block || 'div'
                                  : 'div',
                          styleAttr: editor.formatter.getCssText(format),
                      })
                    : Option.none();
            };
        };
        var flatten = function(fmt) {
            const subs = fmt.items;
            return subs !== undefined && subs.length > 0
                ? bind(subs, flatten)
                : [fmt.format];
        };
        const settingsFormats = Cell([]);
        const settingsFlattenedFormats = Cell([]);
        const eventsFormats = Cell([]);
        const eventsFlattenedFormats = Cell([]);
        const replaceSettings = Cell(false);
        editor.on('init', function() {
            const formats = getStyleFormats(editor);
            const enriched = register$3(
                editor,
                formats,
                isSelectedFor,
                getPreviewFor,
            );
            settingsFormats.set(enriched);
            settingsFlattenedFormats.set(bind(enriched, flatten));
        });
        editor.on('addStyleModifications', function(e) {
            const modifications = register$3(
                editor,
                e.items,
                isSelectedFor,
                getPreviewFor,
            );
            eventsFormats.set(modifications);
            replaceSettings.set(e.replace);
            eventsFlattenedFormats.set(bind(modifications, flatten));
        });
        const getData = function() {
            const fromSettings = replaceSettings.get()
                ? []
                : settingsFormats.get();
            const fromEvents = eventsFormats.get();
            return fromSettings.concat(fromEvents);
        };
        const getFlattenedKeys = function() {
            const fromSettings = replaceSettings.get()
                ? []
                : settingsFlattenedFormats.get();
            const fromEvents = eventsFlattenedFormats.get();
            return fromSettings.concat(fromEvents);
        };
        return {
            getData,
            getFlattenedKeys,
        };
    };

    const trim$1 = global$e.trim;
    const hasContentEditableState = function(value) {
        return function(node) {
            if (node && node.nodeType === 1) {
                if (node.contentEditable === value) {
                    return true;
                }
                if (node.getAttribute('data-mce-contenteditable') === value) {
                    return true;
                }
            }
            return false;
        };
    };
    const isContentEditableTrue = hasContentEditableState('true');
    const isContentEditableFalse = hasContentEditableState('false');
    const create$8 = function(type, title, url, level, attach) {
        return {
            type,
            title,
            url,
            level,
            attach,
        };
    };
    const isChildOfContentEditableTrue = function(node) {
        while ((node = node.parentNode)) {
            const value = node.contentEditable;
            if (value && value !== 'inherit') {
                return isContentEditableTrue(node);
            }
        }
        return false;
    };
    const select = function(selector, root) {
        return map(descendants(Element.fromDom(root), selector), function(
            element,
        ) {
            return element.dom();
        });
    };
    const getElementText = function(elm) {
        return elm.innerText || elm.textContent;
    };
    const getOrGenerateId = function(elm) {
        return elm.id ? elm.id : generate$1('h');
    };
    const isAnchor = function(elm) {
        return (
            elm && elm.nodeName === 'A' && (elm.id || elm.name) !== undefined
        );
    };
    const isValidAnchor = function(elm) {
        return isAnchor(elm) && isEditable(elm);
    };
    const isHeader = function(elm) {
        return elm && /^(H[1-6])$/.test(elm.nodeName);
    };
    var isEditable = function(elm) {
        return (
            isChildOfContentEditableTrue(elm) && !isContentEditableFalse(elm)
        );
    };
    const isValidHeader = function(elm) {
        return isHeader(elm) && isEditable(elm);
    };
    const getLevel = function(elm) {
        return isHeader(elm) ? parseInt(elm.nodeName.substr(1), 10) : 0;
    };
    const headerTarget = function(elm) {
        const headerId = getOrGenerateId(elm);
        const attach = function() {
            elm.id = headerId;
        };
        return create$8(
            'header',
            getElementText(elm),
            `#${headerId}`,
            getLevel(elm),
            attach,
        );
    };
    const anchorTarget = function(elm) {
        const anchorId = elm.id || elm.name;
        const anchorText = getElementText(elm);
        return create$8(
            'anchor',
            anchorText || `#${anchorId}`,
            `#${anchorId}`,
            0,
            noop,
        );
    };
    const getHeaderTargets = function(elms) {
        return map(filter(elms, isValidHeader), headerTarget);
    };
    const getAnchorTargets = function(elms) {
        return map(filter(elms, isValidAnchor), anchorTarget);
    };
    const getTargetElements = function(elm) {
        const elms = select('h1,h2,h3,h4,h5,h6,a:not([href])', elm);
        return elms;
    };
    const hasTitle = function(target) {
        return trim$1(target.title).length > 0;
    };
    const find$5 = function(elm) {
        const elms = getTargetElements(elm);
        return filter(
            getHeaderTargets(elms).concat(getAnchorTargets(elms)),
            hasTitle,
        );
    };
    const LinkTargets = { find: find$5 };

    const STORAGE_KEY = 'tinymce-url-history';
    const HISTORY_LENGTH = 5;
    const isHttpUrl = function(url) {
        return isString(url) && /^https?/.test(url);
    };
    const isArrayOfUrl = function(a) {
        return isArray(a) && a.length <= HISTORY_LENGTH && forall(a, isHttpUrl);
    };
    const isRecordOfUrlArray = function(r) {
        return (
            isObject(r) &&
            find$1(r, function(value) {
                return !isArrayOfUrl(value);
            }).isNone()
        );
    };
    const getAllHistory = function() {
        const unparsedHistory = domGlobals.localStorage.getItem(STORAGE_KEY);
        if (unparsedHistory === null) {
            return {};
        }
        let history;
        try {
            history = JSON.parse(unparsedHistory);
        } catch (e) {
            if (e instanceof SyntaxError) {
                domGlobals.console.log(
                    `Local storage ${STORAGE_KEY} was not valid JSON`,
                    e,
                );
                return {};
            }
            throw e;
        }
        if (!isRecordOfUrlArray(history)) {
            domGlobals.console.log(
                `Local storage ${STORAGE_KEY} was not valid format`,
                history,
            );
            return {};
        }
        return history;
    };
    const setAllHistory = function(history) {
        if (!isRecordOfUrlArray(history)) {
            throw new Error(
                `Bad format for history:\n${JSON.stringify(history)}`,
            );
        }
        domGlobals.localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
    };
    const getHistory = function(fileType) {
        const history = getAllHistory();
        return Object.prototype.hasOwnProperty.call(history, fileType)
            ? history[fileType]
            : [];
    };
    const addToHistory = function(url, fileType) {
        if (!isHttpUrl(url)) {
            return;
        }
        const history = getAllHistory();
        const items = Object.prototype.hasOwnProperty.call(history, fileType)
            ? history[fileType]
            : [];
        const itemsWithoutUrl = filter(items, function(item) {
            return item !== url;
        });
        history[fileType] = [url]
            .concat(itemsWithoutUrl)
            .slice(0, HISTORY_LENGTH);
        setAllHistory(history);
    };

    const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    const isTruthy = function(value) {
        return !!value;
    };
    const makeMap = function(value) {
        return map$1(global$e.makeMap(value, /[, ]/), isTruthy);
    };
    const getOpt = function(obj, key) {
        return hasOwnProperty$2.call(obj, key)
            ? Option.some(obj[key])
            : Option.none();
    };
    const getTextSetting = function(settings, name, defaultValue) {
        const value = getOpt(settings, name).getOr(defaultValue);
        return isString(value) ? Option.some(value) : Option.none();
    };
    const getPicker = function(settings) {
        return Option.some(settings.file_picker_callback).filter(isFunction);
    };
    const getPickerTypes = function(settings) {
        const optFileTypes = Option.some(settings.file_picker_types).filter(
            isTruthy,
        );
        const optLegacyTypes = Option.some(
            settings.file_browser_callback_types,
        ).filter(isTruthy);
        const optTypes = optFileTypes.or(optLegacyTypes).map(makeMap);
        return getPicker(settings).fold(
            function() {
                return false;
            },
            function(_picker) {
                return optTypes.fold(
                    function() {
                        return true;
                    },
                    function(types) {
                        return keys(types).length > 0 ? types : false;
                    },
                );
            },
        );
    };
    const getPickerSetting = function(settings, filetype) {
        const pickerTypes = getPickerTypes(settings);
        if (isBoolean(pickerTypes)) {
            return pickerTypes ? getPicker(settings) : Option.none();
        }
        return pickerTypes[filetype] ? getPicker(settings) : Option.none();
    };
    const getUrlPicker = function(editor, filetype) {
        return getPickerSetting(editor.settings, filetype).map(function(
            picker,
        ) {
            return function(entry) {
                return Future.nu(function(completer) {
                    const handler = function(value, meta) {
                        if (!isString(value)) {
                            throw new Error('Expected value to be string');
                        }
                        if (meta !== undefined && !isObject(meta)) {
                            throw new Error('Expected meta to be a object');
                        }
                        const r = {
                            value,
                            meta,
                        };
                        completer(r);
                    };
                    const meta = global$e.extend(
                        { filetype },
                        Option.from(entry.meta).getOr({}),
                    );
                    picker.call(editor, handler, entry.value, meta);
                });
            };
        });
    };
    const getLinkInformation = function(editor) {
        if (editor.settings.typeahead_urls === false) {
            return Option.none();
        }
        return Option.some({
            targets: LinkTargets.find(editor.getBody()),
            anchorTop: getTextSetting(
                editor.settings,
                'anchor_top',
                '#top',
            ).getOrUndefined(),
            anchorBottom: getTextSetting(
                editor.settings,
                'anchor_bottom',
                '#bottom',
            ).getOrUndefined(),
        });
    };
    const getValidationHandler = function(editor) {
        const optValidator = Option.from(
            editor.settings.file_picker_validator_handler,
        ).filter(isFunction);
        return optValidator.orThunk(function() {
            return Option.from(
                editor.settings.filepicker_validator_handler,
            ).filter(isFunction);
        });
    };
    const UrlInputBackstage = function(editor) {
        return {
            getHistory,
            addToHistory,
            getLinkInformation() {
                return getLinkInformation(editor);
            },
            getValidationHandler() {
                return getValidationHandler(editor);
            },
            getUrlPicker(filetype) {
                return getUrlPicker(editor, filetype);
            },
        };
    };

    const init$8 = function(sink, editor, lazyAnchorbar, lazyMoreButton) {
        const contextMenuState = Cell(false);
        var backstage = {
            shared: {
                providers: {
                    icons() {
                        return editor.ui.registry.getAll().icons;
                    },
                    menuItems() {
                        return editor.ui.registry.getAll().menuItems;
                    },
                    translate: global$5.translate,
                },
                interpreter(s) {
                    return interpretWithoutForm(s, backstage);
                },
                anchors: Anchors.getAnchors(
                    editor,
                    lazyAnchorbar,
                    lazyMoreButton,
                ),
                getSink() {
                    return Result.value(sink);
                },
            },
            urlinput: UrlInputBackstage(editor),
            styleselect: init$7(editor),
            colorinput: ColorInputBackstage(editor),
            dialog: DialogBackstage(editor),
            isContextMenuOpen() {
                return contextMenuState.get();
            },
            setContextMenuState(state) {
                return contextMenuState.set(state);
            },
        };
        return backstage;
    };

    const showContextToolbarEvent = 'contexttoolbar-show';
    const hideContextToolbarEvent = 'contexttoolbar-hide';

    const schema$k = constant([
        strict$1('dom'),
        defaulted$1('shell', true),
        field$1('toolbarBehaviours', [Replacing]),
    ]);
    const enhanceGroups = function(detail) {
        return { behaviours: derive$1([Replacing.config({})]) };
    };
    const parts$7 = constant([
        optional({
            name: 'groups',
            overrides: enhanceGroups,
        }),
    ]);

    const factory$9 = function(detail, components, spec, _externals) {
        const setGroups = function(toolbar, groups) {
            getGroupContainer(toolbar).fold(
                function() {
                    domGlobals.console.error(
                        'Toolbar was defined to not be a shell, but no groups container was specified in components',
                    );
                    throw new Error(
                        'Toolbar was defined to not be a shell, but no groups container was specified in components',
                    );
                },
                function(container) {
                    Replacing.set(container, groups);
                },
            );
        };
        var getGroupContainer = function(component) {
            return detail.shell
                ? Option.some(component)
                : getPart(component, detail, 'groups');
        };
        const extra = detail.shell
            ? {
                  behaviours: [Replacing.config({})],
                  components: [],
              }
            : {
                  behaviours: [],
                  components,
              };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components: extra.components,
            behaviours: augment(detail.toolbarBehaviours, extra.behaviours),
            apis: { setGroups },
            domModification: { attributes: { role: 'group' } },
        };
    };
    const Toolbar = composite$1({
        name: 'Toolbar',
        configFields: schema$k(),
        partFields: parts$7(),
        factory: factory$9,
        apis: {
            setGroups(apis, toolbar, groups) {
                apis.setGroups(toolbar, groups);
            },
        },
    });

    const generate$6 = function(xs, f) {
        const init = {
            len: 0,
            list: [],
        };
        const r = foldl(
            xs,
            function(b, a) {
                const value = f(a, b.len);
                return value.fold(constant(b), function(v) {
                    return {
                        len: v.finish(),
                        list: b.list.concat([v]),
                    };
                });
            },
            init,
        );
        return r.list;
    };

    const output$1 = Immutable('within', 'extra', 'withinWidth');
    const apportion = function(units, total, len) {
        const parray = generate$6(units, function(unit, current) {
            const width = len(unit);
            return Option.some({
                element: constant(unit),
                start: constant(current),
                finish: constant(current + width),
                width: constant(width),
            });
        });
        const within = filter(parray, function(unit) {
            return unit.finish() <= total;
        });
        const withinWidth = foldr(
            within,
            function(acc, el) {
                return acc + el.width();
            },
            0,
        );
        const extra = parray.slice(within.length);
        return {
            within: constant(within),
            extra: constant(extra),
            withinWidth: constant(withinWidth),
        };
    };
    const toUnit = function(parray) {
        return map(parray, function(unit) {
            return unit.element();
        });
    };
    const fitLast = function(within, extra, withinWidth) {
        const fits = toUnit(within.concat(extra));
        return output$1(fits, [], withinWidth);
    };
    const overflow = function(within, extra, overflower, withinWidth) {
        const fits = toUnit(within).concat([overflower]);
        return output$1(fits, toUnit(extra), withinWidth);
    };
    const fitAll = function(within, extra, withinWidth) {
        return output$1(toUnit(within), [], withinWidth);
    };
    const tryFit = function(total, units, len) {
        const divide = apportion(units, total, len);
        return divide.extra().length === 0
            ? Option.some(divide)
            : Option.none();
    };
    const partition$3 = function(total, units, len, overflower) {
        const divide = tryFit(total, units, len).getOrThunk(function() {
            return apportion(units, total - len(overflower), len);
        });
        const within = divide.within();
        const extra = divide.extra();
        const withinWidth = divide.withinWidth();
        if (extra.length === 1 && extra[0].width() <= len(overflower)) {
            return fitLast(within, extra, withinWidth);
        }
        if (extra.length >= 1) {
            return overflow(within, extra, overflower, withinWidth);
        }
        return fitAll(within, extra, withinWidth);
    };

    const setStoredGroups = function(toolbar, storedGroups) {
        const bGroups = map(storedGroups, function(g) {
            return premade$1(g);
        });
        Toolbar.setGroups(toolbar, bGroups);
    };
    const findFocusedComp = function(overflow, overflowButton) {
        return overflow
            .bind(function(overf) {
                return search(overf.element()).bind(function(focusedElm) {
                    return overf
                        .getSystem()
                        .getByDom(focusedElm)
                        .toOption();
                });
            })
            .orThunk(function() {
                return overflowButton.filter(Focusing.isFocused);
            });
    };
    const refresh = function(toolbar, detail, overflow, isOpen) {
        const primary = getPartOrDie(toolbar, detail, 'primary');
        const overflowButton = getPart(toolbar, detail, 'overflow-button');
        const overflowGroup = Coupling.getCoupled(toolbar, 'overflowGroup');
        set$2(primary.element(), 'visibility', 'hidden');
        const focusedComp = findFocusedComp(overflow, overflowButton);
        overflow.each(function(overf) {
            Toolbar.setGroups(overf, []);
        });
        const groups = detail.builtGroups.get();
        setStoredGroups(primary, groups.concat([overflowGroup]));
        const total = get$7(primary.element());
        const overflows = partition$3(
            total,
            groups,
            function(comp) {
                return get$7(comp.element());
            },
            overflowGroup,
        );
        if (overflows.extra().length === 0) {
            Replacing.remove(primary, overflowGroup);
            overflow.each(function(overf) {
                Toolbar.setGroups(overf, []);
            });
        } else {
            setStoredGroups(primary, overflows.within());
            overflow.each(function(overf) {
                setStoredGroups(overf, overflows.extra());
            });
        }
        remove$6(primary.element(), 'visibility');
        reflow(primary.element());
        overflow.each(function(overf) {
            overflowButton.each(function(button) {
                return Toggling.set(button, isOpen(overf));
            });
            focusedComp.each(Focusing.focus);
        });
    };

    const schema$l = constant([
        strict$1('items'),
        markers(['itemSelector']),
        field$1('tgroupBehaviours', [Keying]),
    ]);
    const parts$8 = constant([
        group({
            name: 'items',
            unit: 'item',
        }),
    ]);

    const factory$a = function(detail, components, spec, _externals) {
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.tgroupBehaviours, [
                Keying.config({
                    mode: 'flow',
                    selector: detail.markers.itemSelector,
                }),
            ]),
            domModification: { attributes: { role: 'toolbar' } },
        };
    };
    const ToolbarGroup = composite$1({
        name: 'ToolbarGroup',
        configFields: schema$l(),
        partFields: parts$8(),
        factory: factory$a,
    });

    const schema$m = constant([
        field$1('splitToolbarBehaviours', [Coupling]),
        state$1('builtGroups', function() {
            return Cell([]);
        }),
    ]);
    const spec = function(detail, components, spec, externals, extras) {
        const toolbarToggleEvent = 'alloy.toolbar.toggle';
        const doSetGroups = function(toolbar, groups) {
            const built = map(groups, toolbar.getSystem().build);
            detail.builtGroups.set(built);
        };
        const setGroups = function(toolbar, groups) {
            doSetGroups(toolbar, groups);
            extras.apis.refresh(toolbar);
        };
        const getMoreButton = function(toolbar) {
            return getPart(toolbar, detail, 'overflow-button');
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.splitToolbarBehaviours, [
                Coupling.config({
                    others: {
                        ...extras.coupling,
                        overflowGroup(toolbar) {
                            return ToolbarGroup.sketch({
                                ...externals['overflow-group'](),
                                items: [
                                    Button.sketch({
                                        ...externals['overflow-button'](),
                                        action(_button) {
                                            emit(toolbar, toolbarToggleEvent);
                                        },
                                    }),
                                ],
                            });
                        },
                    },
                }),
                config('toolbar-toggle-events', [
                    run(toolbarToggleEvent, function(toolbar) {
                        extras.apis.toggle(toolbar);
                    }),
                ]),
            ]),
            apis: {
                setGroups,
                getMoreButton(toolbar) {
                    return getMoreButton(toolbar);
                },
                ...extras.apis,
            },
            domModification: { attributes: { role: 'group' } },
        };
    };

    const schema$n = constant(
        [
            markers(['overflowToggledClass']),
            strict$1('getAnchor'),
            optionFunction('getOverflowBounds'),
            strict$1('lazySink'),
        ].concat(schema$m()),
    );
    const parts$9 = constant([
        required({
            factory: Toolbar,
            schema: schema$k(),
            name: 'primary',
        }),
        external$1({
            factory: Toolbar,
            schema: schema$k(),
            name: 'overflow',
            overrides(detail) {
                return {
                    toolbarBehaviours: derive$1([
                        Keying.config({
                            mode: 'cyclic',
                            onEscape(comp) {
                                getPart(comp, detail, 'overflow-button').each(
                                    Focusing.focus,
                                );
                                return Option.none();
                            },
                        }),
                    ]),
                };
            },
        }),
        external$1({
            name: 'overflow-button',
            overrides(detail) {
                return {
                    dom: { attributes: { 'aria-haspopup': 'true' } },
                    buttonBehaviours: derive$1([
                        Toggling.config({
                            toggleClass: detail.markers.overflowToggledClass,
                            aria: { mode: 'expanded' },
                            toggleOnExecute: false,
                        }),
                    ]),
                };
            },
        }),
        external$1({ name: 'overflow-group' }),
    ]);

    const toggleToolbar = function(toolbar, detail, externals) {
        const sandbox = Coupling.getCoupled(toolbar, 'sandbox');
        if (Sandboxing.isOpen(sandbox)) {
            Sandboxing.close(sandbox);
        } else {
            Sandboxing.open(sandbox, externals.overflow());
        }
    };
    const isOpen$1 = function(over) {
        return over.getSystem().isConnected();
    };
    const position$2 = function(toolbar, detail, overf) {
        const sink = detail.lazySink(toolbar).getOrDie();
        const anchor = detail.getAnchor(toolbar);
        const bounds = detail.getOverflowBounds.map(function(bounder) {
            return bounder();
        });
        Positioning.positionWithinBounds(sink, anchor, overf, bounds);
    };
    const refresh$1 = function(toolbar, detail) {
        const overflow = Sandboxing.getState(
            Coupling.getCoupled(toolbar, 'sandbox'),
        );
        refresh(toolbar, detail, overflow, isOpen$1);
        overflow.each(function(overf) {
            return position$2(toolbar, detail, overf);
        });
    };
    const reposition$1 = function(toolbar, detail) {
        const overflow = Sandboxing.getState(
            Coupling.getCoupled(toolbar, 'sandbox'),
        );
        overflow.each(function(overf) {
            return position$2(toolbar, detail, overf);
        });
    };
    const makeSandbox$1 = function(toolbar, detail) {
        const ariaOwner = manager();
        const onOpen = function(sandbox, overf) {
            refresh$1(toolbar, detail);
            getPart(toolbar, detail, 'overflow-button').each(function(button) {
                Toggling.on(button);
                ariaOwner.link(button.element());
            });
            Keying.focusIn(overf);
        };
        const onClose = function() {
            getPart(toolbar, detail, 'overflow-button').each(function(button) {
                Toggling.off(button);
                Focusing.focus(button);
                ariaOwner.unlink(button.element());
            });
        };
        return {
            dom: {
                tag: 'div',
                attributes: { id: ariaOwner.id() },
            },
            behaviours: derive$1([
                Keying.config({
                    mode: 'special',
                    onEscape(comp) {
                        Sandboxing.close(comp);
                        return Option.some(true);
                    },
                }),
                Sandboxing.config({
                    onOpen,
                    onClose,
                    isPartOf(container, data, queryElem) {
                        return (
                            isPartOf(data, queryElem) ||
                            isPartOf(toolbar, queryElem)
                        );
                    },
                    getAttachPoint() {
                        return detail.lazySink(toolbar).getOrDie();
                    },
                }),
                Receiving.config({
                    channels: {
                        ...receivingChannel$1({
                            isExtraPart: constant(false),
                            doReposition() {
                                return reposition$1(toolbar, detail);
                            },
                        }),
                    },
                }),
            ]),
        };
    };
    const factory$b = function(detail, components, spec$1, externals) {
        return spec(detail, components, spec$1, externals, {
            coupling: {
                sandbox(toolbar) {
                    return makeSandbox$1(toolbar, detail);
                },
            },
            apis: {
                refresh(toolbar) {
                    return refresh$1(toolbar, detail);
                },
                toggle(toolbar) {
                    return toggleToolbar(toolbar, detail, externals);
                },
                getOverflow(toolbar) {
                    return Sandboxing.getState(
                        Coupling.getCoupled(toolbar, 'sandbox'),
                    );
                },
                reposition(toolbar) {
                    return reposition$1(toolbar, detail);
                },
            },
        });
    };
    const SplitFloatingToolbar = composite$1({
        name: 'SplitFloatingToolbar',
        configFields: schema$n(),
        partFields: parts$9(),
        factory: factory$b,
        apis: {
            setGroups(apis, toolbar, groups) {
                apis.setGroups(toolbar, groups);
            },
            refresh(apis, toolbar) {
                apis.refresh(toolbar);
            },
            reposition(apis, toolbar) {
                apis.reposition(toolbar);
            },
            getMoreButton(apis, toolbar) {
                return apis.getMoreButton(toolbar);
            },
            getOverflow(apis, toolbar) {
                return apis.getOverflow(toolbar);
            },
            toggle(apis, toolbar) {
                apis.toggle(toolbar);
            },
        },
    });

    const getAnimationRoot = function(component, slideConfig) {
        return slideConfig.getAnimationRoot.fold(
            function() {
                return component.element();
            },
            function(get) {
                return get(component);
            },
        );
    };

    const getDimensionProperty = function(slideConfig) {
        return slideConfig.dimension.property;
    };
    const getDimension = function(slideConfig, elem) {
        return slideConfig.dimension.getDimension(elem);
    };
    const disableTransitions = function(component, slideConfig) {
        const root = getAnimationRoot(component, slideConfig);
        remove$5(root, [slideConfig.shrinkingClass, slideConfig.growingClass]);
    };
    const setShrunk = function(component, slideConfig) {
        remove$4(component.element(), slideConfig.openClass);
        add$2(component.element(), slideConfig.closedClass);
        set$2(component.element(), getDimensionProperty(slideConfig), '0px');
        reflow(component.element());
    };
    const setGrown = function(component, slideConfig) {
        remove$4(component.element(), slideConfig.closedClass);
        add$2(component.element(), slideConfig.openClass);
        remove$6(component.element(), getDimensionProperty(slideConfig));
    };
    const doImmediateShrink = function(
        component,
        slideConfig,
        slideState,
        _calculatedSize,
    ) {
        slideState.setCollapsed();
        set$2(
            component.element(),
            getDimensionProperty(slideConfig),
            getDimension(slideConfig, component.element()),
        );
        reflow(component.element());
        disableTransitions(component, slideConfig);
        setShrunk(component, slideConfig);
        slideConfig.onStartShrink(component);
        slideConfig.onShrunk(component);
    };
    const doStartShrink = function(
        component,
        slideConfig,
        slideState,
        calculatedSize,
    ) {
        const size = calculatedSize.getOrThunk(function() {
            return getDimension(slideConfig, component.element());
        });
        slideState.setCollapsed();
        set$2(component.element(), getDimensionProperty(slideConfig), size);
        reflow(component.element());
        const root = getAnimationRoot(component, slideConfig);
        remove$4(root, slideConfig.growingClass);
        add$2(root, slideConfig.shrinkingClass);
        setShrunk(component, slideConfig);
        slideConfig.onStartShrink(component);
    };
    const doStartSmartShrink = function(component, slideConfig, slideState) {
        const size = getDimension(slideConfig, component.element());
        const shrinker = size === '0px' ? doImmediateShrink : doStartShrink;
        shrinker(component, slideConfig, slideState, Option.some(size));
    };
    const doStartGrow = function(component, slideConfig, slideState) {
        const root = getAnimationRoot(component, slideConfig);
        const wasShrinking = has$2(root, slideConfig.shrinkingClass);
        const beforeSize = getDimension(slideConfig, component.element());
        setGrown(component, slideConfig);
        const fullSize = getDimension(slideConfig, component.element());
        const startPartialGrow = function() {
            set$2(
                component.element(),
                getDimensionProperty(slideConfig),
                beforeSize,
            );
            reflow(component.element());
        };
        const startCompleteGrow = function() {
            setShrunk(component, slideConfig);
        };
        const setStartSize = wasShrinking
            ? startPartialGrow
            : startCompleteGrow;
        setStartSize();
        remove$4(root, slideConfig.shrinkingClass);
        add$2(root, slideConfig.growingClass);
        setGrown(component, slideConfig);
        set$2(component.element(), getDimensionProperty(slideConfig), fullSize);
        slideState.setExpanded();
        slideConfig.onStartGrow(component);
    };
    const refresh$2 = function(component, slideConfig, slideState) {
        if (slideState.isExpanded()) {
            remove$6(component.element(), getDimensionProperty(slideConfig));
            const fullSize = getDimension(slideConfig, component.element());
            set$2(
                component.element(),
                getDimensionProperty(slideConfig),
                fullSize,
            );
        }
    };
    const grow = function(component, slideConfig, slideState) {
        if (!slideState.isExpanded()) {
            doStartGrow(component, slideConfig, slideState);
        }
    };
    const shrink = function(component, slideConfig, slideState) {
        if (slideState.isExpanded()) {
            doStartSmartShrink(component, slideConfig, slideState);
        }
    };
    const immediateShrink = function(component, slideConfig, slideState) {
        if (slideState.isExpanded()) {
            doImmediateShrink(component, slideConfig, slideState);
        }
    };
    const hasGrown = function(component, slideConfig, slideState) {
        return slideState.isExpanded();
    };
    const hasShrunk = function(component, slideConfig, slideState) {
        return slideState.isCollapsed();
    };
    const isGrowing = function(component, slideConfig, slideState) {
        const root = getAnimationRoot(component, slideConfig);
        return has$2(root, slideConfig.growingClass) === true;
    };
    const isShrinking = function(component, slideConfig, slideState) {
        const root = getAnimationRoot(component, slideConfig);
        return has$2(root, slideConfig.shrinkingClass) === true;
    };
    const isTransitioning = function(component, slideConfig, slideState) {
        return (
            isGrowing(component, slideConfig) === true ||
            isShrinking(component, slideConfig) === true
        );
    };
    const toggleGrow = function(component, slideConfig, slideState) {
        const f = slideState.isExpanded() ? doStartSmartShrink : doStartGrow;
        f(component, slideConfig, slideState);
    };

    const SlidingApis = /* #__PURE__ */ Object.freeze({
        refresh: refresh$2,
        grow,
        shrink,
        immediateShrink,
        hasGrown,
        hasShrunk,
        isGrowing,
        isShrinking,
        isTransitioning,
        toggleGrow,
        disableTransitions,
    });

    const exhibit$6 = function(base, slideConfig) {
        const { expanded } = slideConfig;
        return expanded
            ? nu$6({
                  classes: [slideConfig.openClass],
                  styles: {},
              })
            : nu$6({
                  classes: [slideConfig.closedClass],
                  styles: wrap$1(slideConfig.dimension.property, '0px'),
              });
    };
    const events$d = function(slideConfig, slideState) {
        return derive([
            runOnSource(transitionend(), function(component, simulatedEvent) {
                const raw = simulatedEvent.event().raw();
                if (raw.propertyName === slideConfig.dimension.property) {
                    disableTransitions(component, slideConfig);
                    if (slideState.isExpanded()) {
                        remove$6(
                            component.element(),
                            slideConfig.dimension.property,
                        );
                    }
                    const notify = slideState.isExpanded()
                        ? slideConfig.onGrown
                        : slideConfig.onShrunk;
                    notify(component);
                }
            }),
        ]);
    };

    const ActiveSliding = /* #__PURE__ */ Object.freeze({
        exhibit: exhibit$6,
        events: events$d,
    });

    const SlidingSchema = [
        strict$1('closedClass'),
        strict$1('openClass'),
        strict$1('shrinkingClass'),
        strict$1('growingClass'),
        option('getAnimationRoot'),
        onHandler('onShrunk'),
        onHandler('onStartShrink'),
        onHandler('onGrown'),
        onHandler('onStartGrow'),
        defaulted$1('expanded', false),
        strictOf(
            'dimension',
            choose$1('property', {
                width: [
                    output('property', 'width'),
                    output('getDimension', function(elem) {
                        return `${get$7(elem)}px`;
                    }),
                ],
                height: [
                    output('property', 'height'),
                    output('getDimension', function(elem) {
                        return `${get$6(elem)}px`;
                    }),
                ],
            }),
        ),
    ];

    const init$9 = function(spec) {
        const state = Cell(spec.expanded);
        const readState = function() {
            return `expanded: ${state.get()}`;
        };
        return nu$5({
            isExpanded() {
                return state.get() === true;
            },
            isCollapsed() {
                return state.get() === false;
            },
            setCollapsed: curry(state.set, false),
            setExpanded: curry(state.set, true),
            readState,
        });
    };

    const SlidingState = /* #__PURE__ */ Object.freeze({
        init: init$9,
    });

    const Sliding = create$1({
        fields: SlidingSchema,
        name: 'sliding',
        active: ActiveSliding,
        apis: SlidingApis,
        state: SlidingState,
    });

    const schema$o = constant(
        [
            markers([
                'closedClass',
                'openClass',
                'shrinkingClass',
                'growingClass',
                'overflowToggledClass',
            ]),
            onHandler('onOpened'),
            onHandler('onClosed'),
        ].concat(schema$m()),
    );
    const parts$a = constant([
        required({
            factory: Toolbar,
            schema: schema$k(),
            name: 'primary',
        }),
        required({
            factory: Toolbar,
            schema: schema$k(),
            name: 'overflow',
            overrides(detail) {
                return {
                    toolbarBehaviours: derive$1([
                        Sliding.config({
                            dimension: { property: 'height' },
                            closedClass: detail.markers.closedClass,
                            openClass: detail.markers.openClass,
                            shrinkingClass: detail.markers.shrinkingClass,
                            growingClass: detail.markers.growingClass,
                            onShrunk(comp) {
                                getPart(comp, detail, 'overflow-button').each(
                                    function(button) {
                                        Toggling.off(button);
                                        Focusing.focus(button);
                                    },
                                );
                                detail.onClosed(comp);
                            },
                            onGrown(comp) {
                                Keying.focusIn(comp);
                                detail.onOpened(comp);
                            },
                            onStartGrow(comp) {
                                getPart(comp, detail, 'overflow-button').each(
                                    Toggling.on,
                                );
                            },
                        }),
                        Keying.config({
                            mode: 'acyclic',
                            onEscape(comp) {
                                getPart(comp, detail, 'overflow-button').each(
                                    Focusing.focus,
                                );
                                return Option.some(true);
                            },
                        }),
                    ]),
                };
            },
        }),
        external$1({
            name: 'overflow-button',
            overrides(detail) {
                return {
                    buttonBehaviours: derive$1([
                        Toggling.config({
                            toggleClass: detail.markers.overflowToggledClass,
                            aria: { mode: 'pressed' },
                            toggleOnExecute: false,
                        }),
                    ]),
                };
            },
        }),
        external$1({ name: 'overflow-group' }),
    ]);

    const toggleToolbar$1 = function(toolbar, detail) {
        getPart(toolbar, detail, 'overflow').each(function(overf) {
            refresh$3(toolbar, detail);
            Sliding.toggleGrow(overf);
        });
    };
    const isOpen$2 = function(overf) {
        return Sliding.hasGrown(overf);
    };
    var refresh$3 = function(toolbar, detail) {
        const overflow = getPart(toolbar, detail, 'overflow');
        refresh(toolbar, detail, overflow, isOpen$2);
        overflow.each(Sliding.refresh);
    };
    const factory$c = function(detail, components, spec$1, externals) {
        return spec(detail, components, spec$1, externals, {
            coupling: {},
            apis: {
                refresh(toolbar) {
                    return refresh$3(toolbar, detail);
                },
                toggle(toolbar) {
                    return toggleToolbar$1(toolbar, detail);
                },
                getOverflow(toolbar) {
                    return getPart(toolbar, detail, 'overflow');
                },
            },
        });
    };
    const SplitSlidingToolbar = composite$1({
        name: 'SplitSlidingToolbar',
        configFields: schema$o(),
        partFields: parts$a(),
        factory: factory$c,
        apis: {
            setGroups(apis, toolbar, groups) {
                apis.setGroups(toolbar, groups);
            },
            refresh(apis, toolbar) {
                apis.refresh(toolbar);
            },
            getMoreButton(apis, toolbar) {
                return apis.getMoreButton(toolbar);
            },
            getOverflow(apis, toolbar) {
                return apis.getOverflow(toolbar);
            },
            toggle(apis, toolbar) {
                apis.toggle(toolbar);
            },
        },
    });

    const toolbarHeightChange = constant(generate$1('toolbar-height-change'));

    const ReadOnlyChannel = 'silver.readonly';
    const ReadOnlyDataSchema = objOf([strictBoolean('readonly')]);
    const setDisabledAll = function(element, state) {
        all('*', element.element()).forEach(function(elm) {
            element
                .getSystem()
                .getByDom(elm)
                .each(function(comp) {
                    if (comp.hasConfigured(Disabling)) {
                        Disabling.set(comp, state);
                    }
                });
        });
    };
    const broadcastReadonly = function(uiComponents, readonly) {
        const { outerContainer } = uiComponents;
        const target = outerContainer.element();
        if (readonly) {
            uiComponents.mothership.broadcastOn([dismissPopups()], {
                target,
            });
            uiComponents.uiMothership.broadcastOn([dismissPopups()], {
                target,
            });
        }
        uiComponents.mothership.broadcastOn([ReadOnlyChannel], {
            readonly,
        });
        uiComponents.uiMothership.broadcastOn([ReadOnlyChannel], {
            readonly,
        });
    };
    const toggleToReadOnly = function(uiComponents, readonly) {
        const { outerContainer } = uiComponents;
        broadcastReadonly(uiComponents, readonly);
        all('*', outerContainer.element()).forEach(function(elm) {
            outerContainer
                .getSystem()
                .getByDom(elm)
                .each(function(comp) {
                    if (comp.hasConfigured(Disabling)) {
                        Disabling.set(comp, readonly);
                    }
                });
        });
    };
    const setupReadonlyModeSwitch = function(editor, uiComponents) {
        editor.on('init', function() {
            if (editor.readonly) {
                toggleToReadOnly(uiComponents, true);
            }
        });
        editor.on('SwitchMode', function() {
            return toggleToReadOnly(uiComponents, editor.readonly);
        });
        if (isReadOnly(editor)) {
            editor.setMode('readonly');
        }
    };
    const createReadonlyReceivingForOverflow = function(getOverflow) {
        let _a;
        return Receiving.config({
            channels:
                ((_a = {}),
                (_a[ReadOnlyChannel] = {
                    schema: ReadOnlyDataSchema,
                    onReceive(comp, data) {
                        getOverflow(comp).each(function(toolbar) {
                            setDisabledAll(toolbar, data.readonly);
                        });
                    },
                }),
                _a),
        });
    };

    const renderToolbarGroupCommon = function(toolbarGroup) {
        const attributes = toolbarGroup.title.fold(
            function() {
                return {};
            },
            function(title) {
                return { attributes: { title } };
            },
        );
        return {
            dom: {
                tag: 'div',
                classes: ['tox-toolbar__group'],
                ...attributes,
            },
            components: [ToolbarGroup.parts().items({})],
            items: toolbarGroup.items,
            markers: {
                itemSelector:
                    '*:not(.tox-split-button) > .tox-tbtn:not([disabled]), .tox-split-button:not([disabled]), .tox-toolbar-nav-js:not([disabled])',
            },
            tgroupBehaviours: derive$1([
                Tabstopping.config({}),
                Focusing.config({}),
            ]),
        };
    };
    const renderToolbarGroup = function(toolbarGroup) {
        return ToolbarGroup.sketch(renderToolbarGroupCommon(toolbarGroup));
    };
    const getToolbarbehaviours = function(toolbarSpec, modeName, getOverflow) {
        const onAttached = runOnAttached(function(component) {
            const groups = map(toolbarSpec.initGroups, renderToolbarGroup);
            Toolbar.setGroups(component, groups);
        });
        return derive$1([
            Keying.config({
                mode: modeName,
                onEscape: toolbarSpec.onEscape,
                selector: '.tox-toolbar__group',
            }),
            config('toolbar-events', [onAttached]),
            createReadonlyReceivingForOverflow(getOverflow),
        ]);
    };
    const renderMoreToolbarCommon = function(toolbarSpec, getOverflow) {
        const modeName = toolbarSpec.cyclicKeying ? 'cyclic' : 'acyclic';
        return {
            uid: toolbarSpec.uid,
            dom: {
                tag: 'div',
                classes: ['tox-toolbar-overlord'],
            },
            parts: {
                'overflow-group': renderToolbarGroupCommon({
                    title: Option.none(),
                    items: [],
                }),
                'overflow-button': renderIconButtonSpec(
                    {
                        name: 'more',
                        icon: Option.some('more-drawer'),
                        disabled: false,
                        tooltip: Option.some('More...'),
                        primary: false,
                        borderless: false,
                    },
                    Option.none(),
                    toolbarSpec.backstage.shared.providers,
                ),
            },
            splitToolbarBehaviours: getToolbarbehaviours(
                toolbarSpec,
                modeName,
                getOverflow,
            ),
        };
    };
    const renderFloatingMoreToolbar = function(toolbarSpec) {
        const baseSpec = renderMoreToolbarCommon(
            toolbarSpec,
            SplitFloatingToolbar.getOverflow,
        );
        const overflowXOffset = 4;
        const primary = SplitFloatingToolbar.parts().primary({
            dom: {
                tag: 'div',
                classes: ['tox-toolbar__primary'],
            },
        });
        return SplitFloatingToolbar.sketch({
            ...baseSpec,
            lazySink: toolbarSpec.getSink,
            getAnchor() {
                return toolbarSpec.backstage.shared.anchors.toolbarOverflow();
            },
            getOverflowBounds() {
                const headerElem = toolbarSpec.moreDrawerData
                    .lazyHeader()
                    .element();
                const headerBounds = absolute$1(headerElem);
                const docElem = documentElement(headerElem);
                const docBounds = absolute$1(docElem);
                return bounds$1(
                    headerBounds.x() + overflowXOffset,
                    docBounds.y(),
                    headerBounds.width() - overflowXOffset * 2,
                    docBounds.height(),
                );
            },
            parts: {
                ...baseSpec.parts,
                overflow: {
                    dom: {
                        tag: 'div',
                        classes: ['tox-toolbar__overflow'],
                    },
                },
            },
            components: [primary],
            markers: { overflowToggledClass: 'tox-tbtn--enabled' },
        });
    };
    const renderSlidingMoreToolbar = function(toolbarSpec) {
        const primary = SplitSlidingToolbar.parts().primary({
            dom: {
                tag: 'div',
                classes: ['tox-toolbar__primary'],
            },
        });
        const overflow = SplitSlidingToolbar.parts().overflow({
            dom: {
                tag: 'div',
                classes: ['tox-toolbar__overflow'],
            },
        });
        const baseSpec = renderMoreToolbarCommon(
            toolbarSpec,
            SplitSlidingToolbar.getOverflow,
        );
        return SplitSlidingToolbar.sketch({
            ...baseSpec,
            components: [primary, overflow],
            markers: {
                openClass: 'tox-toolbar__overflow--open',
                closedClass: 'tox-toolbar__overflow--closed',
                growingClass: 'tox-toolbar__overflow--growing',
                shrinkingClass: 'tox-toolbar__overflow--shrinking',
                overflowToggledClass: 'tox-tbtn--enabled',
            },
            onOpened(comp) {
                comp.getSystem().broadcastOn([toolbarHeightChange()], {
                    type: 'opened',
                });
            },
            onClosed(comp) {
                comp.getSystem().broadcastOn([toolbarHeightChange()], {
                    type: 'closed',
                });
            },
        });
    };
    const renderToolbar = function(toolbarSpec) {
        const modeName = toolbarSpec.cyclicKeying ? 'cyclic' : 'acyclic';
        return Toolbar.sketch({
            uid: toolbarSpec.uid,
            dom: {
                tag: 'div',
                classes: ['tox-toolbar'].concat(
                    toolbarSpec.type === ToolbarDrawer.scrolling
                        ? ['tox-toolbar--scrolling']
                        : [],
                ),
            },
            components: [Toolbar.parts().groups({})],
            toolbarBehaviours: getToolbarbehaviours(
                toolbarSpec,
                modeName,
                constant(Option.none()),
            ),
        });
    };

    const baseToolbarButtonFields = [
        defaultedBoolean('disabled', false),
        optionString('tooltip'),
        optionString('icon'),
        optionString('text'),
        defaultedFunction('onSetup', function() {
            return noop;
        }),
    ];
    const toolbarButtonSchema = objOf(
        [strictString('type'), strictFunction('onAction')].concat(
            baseToolbarButtonFields,
        ),
    );
    const createToolbarButton = function(spec) {
        return asRaw('toolbarbutton', toolbarButtonSchema, spec);
    };

    const baseMenuButtonFields = [
        optionString('text'),
        optionString('tooltip'),
        optionString('icon'),
        strictFunction('fetch'),
        defaultedFunction('onSetup', function() {
            return noop;
        }),
    ];

    const MenuButtonSchema = objOf(
        __spreadArrays([strictString('type')], baseMenuButtonFields),
    );
    const createMenuButton = function(spec) {
        return asRaw('menubutton', MenuButtonSchema, spec);
    };

    const splitButtonSchema = objOf([
        strictString('type'),
        optionString('tooltip'),
        optionString('icon'),
        optionString('text'),
        optionFunction('select'),
        strictFunction('fetch'),
        defaultedFunction('onSetup', function() {
            return noop;
        }),
        defaultedStringEnum('presets', 'normal', [
            'normal',
            'color',
            'listpreview',
        ]),
        defaulted$1('columns', 1),
        strictFunction('onAction'),
        strictFunction('onItemAction'),
    ]);
    const createSplitButton = function(spec) {
        return asRaw('SplitButton', splitButtonSchema, spec);
    };

    const baseToolbarToggleButtonFields = [
        defaultedBoolean('active', false),
    ].concat(baseToolbarButtonFields);
    const toggleButtonSchema = objOf(
        baseToolbarToggleButtonFields.concat([
            strictString('type'),
            strictFunction('onAction'),
        ]),
    );
    const createToggleButton = function(spec) {
        return asRaw('ToggleButton', toggleButtonSchema, spec);
    };

    const contextBarFields = [
        defaultedFunction('predicate', function() {
            return false;
        }),
        defaultedStringEnum('scope', 'node', ['node', 'editor']),
        defaultedStringEnum('position', 'selection', [
            'node',
            'selection',
            'line',
        ]),
    ];
    const contextButtonFields = baseToolbarButtonFields.concat([
        defaulted$1('type', 'contextformbutton'),
        defaulted$1('primary', false),
        strictFunction('onAction'),
        state$1('original', identity),
    ]);
    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
        defaulted$1('type', 'contextformbutton'),
        defaulted$1('primary', false),
        strictFunction('onAction'),
        state$1('original', identity),
    ]);
    const launchButtonFields = baseToolbarButtonFields.concat([
        defaulted$1('type', 'contextformbutton'),
    ]);
    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([
        defaulted$1('type', 'contextformtogglebutton'),
    ]);
    const toggleOrNormal = choose$1('type', {
        contextformbutton: contextButtonFields,
        contextformtogglebutton: contextToggleButtonFields,
    });
    const contextFormSchema = objOf(
        [
            defaulted$1('type', 'contextform'),
            defaultedFunction('initValue', function() {
                return '';
            }),
            optionString('label'),
            strictArrayOf('commands', toggleOrNormal),
            optionOf(
                'launch',
                choose$1('type', {
                    contextformbutton: launchButtonFields,
                    contextformtogglebutton: launchToggleButtonFields,
                }),
            ),
        ].concat(contextBarFields),
    );
    const contextToolbarSchema = objOf(
        [defaulted$1('type', 'contexttoolbar'), strictString('items')].concat(
            contextBarFields,
        ),
    );
    const createContextToolbar = function(spec) {
        return asRaw('ContextToolbar', contextToolbarSchema, spec);
    };
    const createContextForm = function(spec) {
        return asRaw('ContextForm', contextFormSchema, spec);
    };

    const getState$2 = function(component, replaceConfig, reflectState) {
        return reflectState;
    };

    const ReflectingApis = /* #__PURE__ */ Object.freeze({
        getState: getState$2,
    });

    const events$e = function(reflectingConfig, reflectingState) {
        const update = function(component, data) {
            reflectingConfig.updateState.each(function(updateState) {
                const newState = updateState(component, data);
                reflectingState.set(newState);
            });
            reflectingConfig.renderComponents.each(function(renderComponents) {
                const newComponents = renderComponents(
                    data,
                    reflectingState.get(),
                );
                const newChildren = map(
                    newComponents,
                    component.getSystem().build,
                );
                replaceChildren(component, newChildren);
            });
        };
        return derive([
            run(receive(), function(component, message) {
                const { channel } = reflectingConfig;
                if (contains(message.channels(), channel)) {
                    update(component, message.data());
                }
            }),
            runOnAttached(function(comp, se) {
                reflectingConfig.initialData.each(function(rawData) {
                    update(comp, rawData);
                });
            }),
        ]);
    };

    const ActiveReflecting = /* #__PURE__ */ Object.freeze({
        events: events$e,
    });

    const init$a = function(spec) {
        const cell = Cell(Option.none());
        const set = function(optS) {
            return cell.set(optS);
        };
        const clear = function() {
            return cell.set(Option.none());
        };
        const get = function() {
            return cell.get();
        };
        const readState = function() {
            return cell.get().fold(
                function() {
                    return 'none';
                },
                function(x) {
                    return x;
                },
            );
        };
        return {
            readState,
            get,
            set,
            clear,
        };
    };

    const ReflectingState = /* #__PURE__ */ Object.freeze({
        init: init$a,
    });

    const ReflectingSchema = [
        strict$1('channel'),
        option('renderComponents'),
        option('updateState'),
        option('initialData'),
    ];

    const Reflecting = create$1({
        fields: ReflectingSchema,
        name: 'reflecting',
        active: ActiveReflecting,
        apis: ReflectingApis,
        state: ReflectingState,
    });

    const schema$p = constant(
        [
            strict$1('toggleClass'),
            strict$1('fetch'),
            onStrictHandler('onExecute'),
            defaulted$1('getHotspot', Option.some),
            defaulted$1('getAnchorOverrides', constant({})),
            defaulted$1('layouts', Option.none()),
            onStrictHandler('onItemExecute'),
            option('lazySink'),
            strict$1('dom'),
            onHandler('onOpen'),
            field$1('splitDropdownBehaviours', [Coupling, Keying, Focusing]),
            defaulted$1('matchWidth', false),
            defaulted$1('useMinWidth', false),
            defaulted$1('eventOrder', {}),
            option('role'),
        ].concat(sandboxFields()),
    );
    const arrowPart = required({
        factory: Button,
        schema: [strict$1('dom')],
        name: 'arrow',
        defaults(detail) {
            return { buttonBehaviours: derive$1([Focusing.revoke()]) };
        },
        overrides(detail) {
            return {
                dom: {
                    tag: 'span',
                    attributes: { role: 'presentation' },
                },
                action(arrow) {
                    arrow
                        .getSystem()
                        .getByUid(detail.uid)
                        .each(emitExecute);
                },
                buttonBehaviours: derive$1([
                    Toggling.config({
                        toggleOnExecute: false,
                        toggleClass: detail.toggleClass,
                    }),
                ]),
            };
        },
    });
    const buttonPart = required({
        factory: Button,
        schema: [strict$1('dom')],
        name: 'button',
        defaults(detail) {
            return { buttonBehaviours: derive$1([Focusing.revoke()]) };
        },
        overrides(detail) {
            return {
                dom: {
                    tag: 'span',
                    attributes: { role: 'presentation' },
                },
                action(btn) {
                    btn.getSystem()
                        .getByUid(detail.uid)
                        .each(function(splitDropdown) {
                            detail.onExecute(splitDropdown, btn);
                        });
                },
            };
        },
    });
    const parts$b = constant([
        arrowPart,
        buttonPart,
        optional({
            factory: {
                sketch(spec) {
                    return {
                        uid: spec.uid,
                        dom: {
                            tag: 'span',
                            styles: { display: 'none' },
                            attributes: { 'aria-hidden': 'true' },
                            innerHtml: spec.text,
                        },
                    };
                },
            },
            schema: [strict$1('text')],
            name: 'aria-descriptor',
        }),
        external$1({
            schema: [tieredMenuMarkers()],
            name: 'menu',
            defaults(detail) {
                return {
                    onExecute(tmenu, item) {
                        tmenu
                            .getSystem()
                            .getByUid(detail.uid)
                            .each(function(splitDropdown) {
                                detail.onItemExecute(
                                    splitDropdown,
                                    tmenu,
                                    item,
                                );
                            });
                    },
                };
            },
        }),
        partType(),
    ]);

    const factory$d = function(detail, components, spec, externals) {
        const switchToMenu = function(sandbox) {
            Composing.getCurrent(sandbox).each(function(current) {
                Highlighting.highlightFirst(current);
                Keying.focusIn(current);
            });
        };
        const action = function(component) {
            const onOpenSync = switchToMenu;
            togglePopup(
                detail,
                function(x) {
                    return x;
                },
                component,
                externals,
                onOpenSync,
                HighlightOnOpen.HighlightFirst,
            ).get(noop);
        };
        const openMenu = function(comp) {
            action(comp);
            return Option.some(true);
        };
        const executeOnButton = function(comp) {
            const button = getPartOrDie(comp, detail, 'button');
            emitExecute(button);
            return Option.some(true);
        };
        const buttonEvents = merge(
            derive([
                runOnAttached(function(component, simulatedEvent) {
                    const ariaDescriptor = getPart(
                        component,
                        detail,
                        'aria-descriptor',
                    );
                    ariaDescriptor.each(function(descriptor) {
                        const descriptorId = generate$1('aria');
                        set$1(descriptor.element(), 'id', descriptorId);
                        set$1(
                            component.element(),
                            'aria-describedby',
                            descriptorId,
                        );
                    });
                }),
            ]),
            events$7(Option.some(action)),
        );
        const apis = {
            repositionMenus(comp) {
                if (Toggling.isOn(comp)) {
                    repositionMenus(comp);
                }
            },
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            apis,
            eventOrder: {
                ...detail.eventOrder,
                'alloy.execute': [
                    'disabling',
                    'toggling',
                    'alloy.base.behaviour',
                ],
            },
            events: buttonEvents,
            behaviours: augment(detail.splitDropdownBehaviours, [
                Coupling.config({
                    others: {
                        sandbox(hotspot) {
                            const arrow = getPartOrDie(
                                hotspot,
                                detail,
                                'arrow',
                            );
                            const extras = {
                                onOpen() {
                                    Toggling.on(arrow);
                                    Toggling.on(hotspot);
                                },
                                onClose() {
                                    Toggling.off(arrow);
                                    Toggling.off(hotspot);
                                },
                            };
                            return makeSandbox(detail, hotspot, extras);
                        },
                    },
                }),
                Keying.config({
                    mode: 'special',
                    onSpace: executeOnButton,
                    onEnter: executeOnButton,
                    onDown: openMenu,
                }),
                Focusing.config({}),
                Toggling.config({
                    toggleOnExecute: false,
                    aria: { mode: 'expanded' },
                }),
            ]),
            domModification: {
                attributes: {
                    role: detail.role.getOr('button'),
                    'aria-haspopup': true,
                },
            },
        };
    };
    const SplitDropdown = composite$1({
        name: 'SplitDropdown',
        configFields: schema$p(),
        partFields: parts$b(),
        factory: factory$d,
        apis: {
            repositionMenus(apis, comp) {
                return apis.repositionMenus(comp);
            },
        },
    });

    const getButtonApi = function(component) {
        return {
            isDisabled() {
                return Disabling.isDisabled(component);
            },
            setDisabled(state) {
                return Disabling.set(component, state);
            },
        };
    };
    const getToggleApi = function(component) {
        return {
            setActive(state) {
                Toggling.set(component, state);
            },
            isActive() {
                return Toggling.isOn(component);
            },
            isDisabled() {
                return Disabling.isDisabled(component);
            },
            setDisabled(state) {
                return Disabling.set(component, state);
            },
        };
    };
    const getTooltipAttributes = function(tooltip, providersBackstage) {
        return tooltip
            .map(function(tooltip) {
                return {
                    'aria-label': providersBackstage.translate(tooltip),
                    title: providersBackstage.translate(tooltip),
                };
            })
            .getOr({});
    };
    const focusButtonEvent = generate$1('focus-button');
    const rtlIcon$1 = ['checklist', 'ordered-list'];
    const rtlTransform$1 = [
        'indent',
        'outdent',
        'table-insert-column-after',
        'table-insert-column-before',
        'unordered-list',
    ];
    const renderCommonStructure = function(
        icon,
        text,
        tooltip,
        receiver,
        behaviours,
        providersBackstage,
    ) {
        let _a;
        const getIconName = function(iconName) {
            return global$5.isRtl() && contains(rtlIcon$1, iconName)
                ? `${iconName}-rtl`
                : iconName;
        };
        const needsRtlClass =
            global$5.isRtl() &&
            icon.exists(function(name) {
                return contains(rtlTransform$1, name);
            });
        return {
            dom: {
                tag: 'button',
                classes: ['tox-tbtn']
                    .concat(text.isSome() ? ['tox-tbtn--select'] : [])
                    .concat(needsRtlClass ? ['tox-tbtn__icon-rtl'] : []),
                attributes: getTooltipAttributes(tooltip, providersBackstage),
            },
            components: componentRenderPipeline([
                icon.map(function(iconName) {
                    return renderIconFromPack(
                        getIconName(iconName),
                        providersBackstage.icons,
                    );
                }),
                text.map(function(text) {
                    return renderLabel$1(text, 'tox-tbtn', providersBackstage);
                }),
            ]),
            eventOrder:
                ((_a = {}),
                (_a[mousedown()] = [
                    'focusing',
                    'alloy.base.behaviour',
                    'common-button-display-events',
                ]),
                _a),
            buttonBehaviours: derive$1(
                [
                    config('common-button-display-events', [
                        run(mousedown(), function(button, se) {
                            se.event().prevent();
                            emit(button, focusButtonEvent);
                        }),
                    ]),
                ]
                    .concat(
                        receiver
                            .map(function(r) {
                                return Reflecting.config({
                                    channel: r,
                                    initialData: {
                                        icon,
                                        text,
                                    },
                                    renderComponents(data, _state) {
                                        return componentRenderPipeline([
                                            data.icon.map(function(iconName) {
                                                return renderIconFromPack(
                                                    getIconName(iconName),
                                                    providersBackstage.icons,
                                                );
                                            }),
                                            data.text.map(function(text) {
                                                return renderLabel$1(
                                                    text,
                                                    'tox-tbtn',
                                                    providersBackstage,
                                                );
                                            }),
                                        ]);
                                    },
                                });
                            })
                            .toArray(),
                    )
                    .concat(behaviours.getOr([])),
            ),
        };
    };
    const renderCommonToolbarButton = function(
        spec,
        specialisation,
        providersBackstage,
    ) {
        const editorOffCell = Cell(noop);
        const structure = renderCommonStructure(
            spec.icon,
            spec.text,
            spec.tooltip,
            Option.none(),
            Option.none(),
            providersBackstage,
        );
        return Button.sketch({
            dom: structure.dom,
            components: structure.components,
            eventOrder: toolbarButtonEventOrder,
            buttonBehaviours: derive$1(
                [
                    config('toolbar-button-events', [
                        onToolbarButtonExecute({
                            onAction: spec.onAction,
                            getApi: specialisation.getApi,
                        }),
                        onControlAttached(specialisation, editorOffCell),
                        onControlDetached(specialisation, editorOffCell),
                    ]),
                    DisablingConfigs.toolbarButton(spec.disabled),
                ].concat(specialisation.toolbarButtonBehaviours),
            ),
        });
    };
    const renderToolbarButton = function(spec, providersBackstage) {
        return renderToolbarButtonWith(spec, providersBackstage, []);
    };
    var renderToolbarButtonWith = function(
        spec,
        providersBackstage,
        bonusEvents,
    ) {
        return renderCommonToolbarButton(
            spec,
            {
                toolbarButtonBehaviours: [].concat(
                    bonusEvents.length > 0
                        ? [config('toolbarButtonWith', bonusEvents)]
                        : [],
                ),
                getApi: getButtonApi,
                onSetup: spec.onSetup,
            },
            providersBackstage,
        );
    };
    const renderToolbarToggleButton = function(spec, providersBackstage) {
        return renderToolbarToggleButtonWith(spec, providersBackstage, []);
    };
    var renderToolbarToggleButtonWith = function(
        spec,
        providersBackstage,
        bonusEvents,
    ) {
        return deepMerge(
            renderCommonToolbarButton(
                spec,
                {
                    toolbarButtonBehaviours: [
                        Replacing.config({}),
                        Toggling.config({
                            toggleClass: 'tox-tbtn--enabled',
                            aria: { mode: 'pressed' },
                            toggleOnExecute: false,
                        }),
                    ].concat(
                        bonusEvents.length > 0
                            ? [config('toolbarToggleButtonWith', bonusEvents)]
                            : [],
                    ),
                    getApi: getToggleApi,
                    onSetup: spec.onSetup,
                },
                providersBackstage,
            ),
        );
    };
    const fetchChoices = function(getApi, spec, providersBackstage) {
        return function(comp) {
            return Future.nu(function(callback) {
                return spec.fetch(callback);
            }).map(function(items) {
                return Option.from(
                    createTieredDataFrom(
                        deepMerge(
                            createPartialChoiceMenu(
                                generate$1('menu-value'),
                                items,
                                function(value) {
                                    spec.onItemAction(getApi(comp), value);
                                },
                                spec.columns,
                                spec.presets,
                                ItemResponse$1.CLOSE_ON_EXECUTE,
                                spec.select.getOr(function() {
                                    return false;
                                }),
                                providersBackstage,
                            ),
                            {
                                movement: deriveMenuMovement(
                                    spec.columns,
                                    spec.presets,
                                ),
                                menuBehaviours: SimpleBehaviours.unnamedEvents(
                                    spec.columns !== 'auto'
                                        ? []
                                        : [
                                              runOnAttached(function(comp, se) {
                                                  detectSize(
                                                      comp,
                                                      4,
                                                      classForPreset(
                                                          spec.presets,
                                                      ),
                                                  ).each(function(_a) {
                                                      const { numRows } = _a;
                                                      const { numColumns } = _a;
                                                      Keying.setGridSize(
                                                          comp,
                                                          numRows,
                                                          numColumns,
                                                      );
                                                  });
                                              }),
                                          ],
                                ),
                            },
                        ),
                    ),
                );
            });
        };
    };
    const renderSplitButton = function(spec, sharedBackstage) {
        let _a;
        const displayChannel = generate$1(
            'channel-update-split-dropdown-display',
        );
        const getApi = function(comp) {
            return {
                isDisabled() {
                    return Disabling.isDisabled(comp);
                },
                setDisabled(state) {
                    return Disabling.set(comp, state);
                },
                setIconFill(id, value) {
                    descendant$1(
                        comp.element(),
                        `svg path[id="${id}"], rect[id="${id}"]`,
                    ).each(function(underlinePath) {
                        set$1(underlinePath, 'fill', value);
                    });
                },
                setIconStroke(id, value) {
                    descendant$1(
                        comp.element(),
                        `svg path[id="${id}"], rect[id="${id}"]`,
                    ).each(function(underlinePath) {
                        set$1(underlinePath, 'stroke', value);
                    });
                },
                setActive(state) {
                    set$1(comp.element(), 'aria-pressed', state);
                    descendant$1(comp.element(), 'span').each(function(button) {
                        comp.getSystem()
                            .getByDom(button)
                            .each(function(buttonComp) {
                                return Toggling.set(buttonComp, state);
                            });
                    });
                },
                isActive() {
                    return descendant$1(comp.element(), 'span').exists(function(
                        button,
                    ) {
                        return comp
                            .getSystem()
                            .getByDom(button)
                            .exists(Toggling.isOn);
                    });
                },
            };
        };
        const editorOffCell = Cell(noop);
        const specialisation = {
            getApi,
            onSetup: spec.onSetup,
        };
        return SplitDropdown.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-split-button'],
                attributes: merge(
                    { 'aria-pressed': false },
                    getTooltipAttributes(
                        spec.tooltip,
                        sharedBackstage.providers,
                    ),
                ),
            },
            onExecute(button) {
                spec.onAction(getApi(button));
            },
            onItemExecute(a, b, c) {},
            splitDropdownBehaviours: derive$1([
                DisablingConfigs.splitButton(false),
                config('split-dropdown-events', [
                    run(focusButtonEvent, Focusing.focus),
                    onControlAttached(specialisation, editorOffCell),
                    onControlDetached(specialisation, editorOffCell),
                ]),
                Unselecting.config({}),
            ]),
            eventOrder:
                ((_a = {}),
                (_a[attachedToDom()] = [
                    'alloy.base.behaviour',
                    'split-dropdown-events',
                ]),
                _a),
            toggleClass: 'tox-tbtn--enabled',
            lazySink: sharedBackstage.getSink,
            fetch: fetchChoices(getApi, spec, sharedBackstage.providers),
            parts: { menu: part(false, spec.columns, spec.presets) },
            components: [
                SplitDropdown.parts().button(
                    renderCommonStructure(
                        spec.icon,
                        spec.text,
                        Option.none(),
                        Option.some(displayChannel),
                        Option.some([
                            Toggling.config({
                                toggleClass: 'tox-tbtn--enabled',
                                toggleOnExecute: false,
                            }),
                        ]),
                        sharedBackstage.providers,
                    ),
                ),
                SplitDropdown.parts().arrow({
                    dom: {
                        tag: 'button',
                        classes: ['tox-tbtn', 'tox-split-button__chevron'],
                        innerHtml: get$c(
                            'chevron-down',
                            sharedBackstage.providers.icons,
                        ),
                    },
                }),
                SplitDropdown.parts()['aria-descriptor']({
                    text: sharedBackstage.providers.translate(
                        'To open the popup, press Shift+Enter',
                    ),
                }),
            ],
        });
    };

    const getFormApi = function(input) {
        return {
            hide() {
                return emit(input, sandboxClose());
            },
            getValue() {
                return Representing.getValue(input);
            },
        };
    };
    const runOnExecute$1 = function(memInput, original) {
        return run(internalToolbarButtonExecute, function(comp, se) {
            const input = memInput.get(comp);
            const formApi = getFormApi(input);
            original.onAction(formApi, se.event().buttonApi());
        });
    };
    const renderContextButton = function(memInput, button, extras) {
        const _a = button.original;
        const { primary } = _a;
        const rest = __rest(_a, ['primary']);
        const bridged = getOrDie(
            createToolbarButton({ ...rest, type: 'button', onAction() {} }),
        );
        return renderToolbarButtonWith(
            bridged,
            extras.backstage.shared.providers,
            [runOnExecute$1(memInput, button)],
        );
    };
    const renderContextToggleButton = function(memInput, button, extras) {
        const _a = button.original;
        const { primary } = _a;
        const rest = __rest(_a, ['primary']);
        const bridged = getOrDie(
            createToggleButton({
                ...rest,
                type: 'togglebutton',
                onAction() {},
            }),
        );
        return renderToolbarToggleButtonWith(
            bridged,
            extras.backstage.shared.providers,
            [runOnExecute$1(memInput, button)],
        );
    };
    const generateOne$1 = function(memInput, button, providersBackstage) {
        const extras = {
            backstage: { shared: { providers: providersBackstage } },
        };
        if (button.type === 'contextformtogglebutton') {
            return renderContextToggleButton(memInput, button, extras);
        }
        return renderContextButton(memInput, button, extras);
    };
    const generate$7 = function(memInput, buttons, providersBackstage) {
        const mementos = map(buttons, function(button) {
            return record(generateOne$1(memInput, button, providersBackstage));
        });
        const asSpecs = function() {
            return map(mementos, function(mem) {
                return mem.asSpec();
            });
        };
        const findPrimary = function(compInSystem) {
            return findMap(buttons, function(button, i) {
                if (button.primary) {
                    return Option.from(mementos[i])
                        .bind(function(mem) {
                            return mem.getOpt(compInSystem);
                        })
                        .filter(not(Disabling.isDisabled));
                }
                return Option.none();
            });
        };
        return {
            asSpecs,
            findPrimary,
        };
    };

    const renderContextForm = function(toolbarType, ctx, backstage) {
        const inputAttributes = ctx.label.fold(
            function() {
                return {};
            },
            function(label) {
                return { 'aria-label': label };
            },
        );
        const memInput = record(
            Input.sketch({
                inputClasses: ['tox-toolbar-textfield', 'tox-toolbar-nav-js'],
                data: ctx.initValue(),
                inputAttributes,
                selectOnFocus: true,
                inputBehaviours: derive$1([
                    Keying.config({
                        mode: 'special',
                        onEnter(input) {
                            return commands
                                .findPrimary(input)
                                .map(function(primary) {
                                    emitExecute(primary);
                                    return true;
                                });
                        },
                        onLeft(comp, se) {
                            se.cut();
                            return Option.none();
                        },
                        onRight(comp, se) {
                            se.cut();
                            return Option.none();
                        },
                    }),
                ]),
            }),
        );
        var commands = generate$7(
            memInput,
            ctx.commands,
            backstage.shared.providers,
        );
        return renderToolbar({
            type: toolbarType,
            uid: generate$1('context-toolbar'),
            initGroups: [
                {
                    title: Option.none(),
                    items: [memInput.asSpec()],
                },
                {
                    title: Option.none(),
                    items: commands.asSpecs(),
                },
            ],
            onEscape: Option.none,
            cyclicKeying: true,
            backstage,
            getSink() {
                return Result.error('');
            },
        });
    };
    const ContextForm = { renderContextForm };

    const getHorizontalBounds = function(contentAreaBox, viewportBounds) {
        const x = Math.max(viewportBounds.x(), contentAreaBox.x());
        const contentBoxWidth = contentAreaBox.right() - x;
        const maxViewportWidth =
            viewportBounds.width() - (x - viewportBounds.x());
        const width = Math.min(contentBoxWidth, maxViewportWidth);
        return {
            x,
            width,
        };
    };
    const getIframeBounds = function(editor, contentAreaBox, viewportBounds) {
        const _a = getHorizontalBounds(contentAreaBox, viewportBounds);
        const { x } = _a;
        const { width } = _a;
        const container = Element.fromDom(editor.getContainer());
        const header = descendant$1(container, '.tox-editor-header').getOr(
            container,
        );
        const containerBox = box(container);
        const headerBox = box(header);
        const y = Math.max(
            viewportBounds.y(),
            contentAreaBox.y(),
            headerBox.bottom(),
        );
        const contentBoxHeight = containerBox.bottom() - y;
        const maxViewportHeight =
            viewportBounds.height() - (y - viewportBounds.y());
        const height = Math.min(contentBoxHeight, maxViewportHeight);
        return bounds$1(x, y, width, height);
    };
    const getInlineBounds = function(editor, contentAreaBox, viewportBounds) {
        const _a = getHorizontalBounds(contentAreaBox, viewportBounds);
        const { x } = _a;
        const { width } = _a;
        const container = Element.fromDom(editor.getContainer());
        const header = descendant$1(container, '.tox-editor-header').getOr(
            container,
        );
        const headerBox = box(header);
        const vpHeight = viewportBounds.height();
        const vpTop = viewportBounds.y();
        if (headerBox.y() >= contentAreaBox.bottom()) {
            const bottom = Math.min(vpHeight + vpTop, headerBox.y());
            var height = bottom - vpTop;
            return bounds$1(x, vpTop, width, height);
        }
        const y = Math.max(vpTop, headerBox.bottom());
        var height = vpHeight - (y - vpTop);
        return bounds$1(x, y, width, height);
    };
    const getDistractionFreeBounds = function(
        _editor,
        contentAreaBox,
        viewportBounds,
    ) {
        const _a = getHorizontalBounds(contentAreaBox, viewportBounds);
        const { x } = _a;
        const { width } = _a;
        return bounds$1(x, viewportBounds.y(), width, viewportBounds.height());
    };
    const getContextToolbarBounds = function(editor) {
        const toolbarOrMenubarEnabled =
            isMenubarEnabled(editor) ||
            isToolbarEnabled(editor) ||
            isMultipleToolbars(editor);
        const viewportBounds = getBounds(domGlobals.window);
        const contentAreaBox = box(
            Element.fromDom(editor.getContentAreaContainer()),
        );
        if (editor.inline && !toolbarOrMenubarEnabled) {
            return getDistractionFreeBounds(
                editor,
                contentAreaBox,
                viewportBounds,
            );
        }
        if (editor.inline) {
            return getInlineBounds(editor, contentAreaBox, viewportBounds);
        }
        return getIframeBounds(editor, contentAreaBox, viewportBounds);
    };

    const ancestor$2 = function(scope, transform, isRoot) {
        let element = scope.dom();
        const stop = isFunction(isRoot) ? isRoot : constant(false);
        while (element.parentNode) {
            element = element.parentNode;
            const el = Element.fromDom(element);
            const transformed = transform(el);
            if (transformed.isSome()) {
                return transformed;
            }
            if (stop(el)) {
                break;
            }
        }
        return Option.none();
    };

    const matchTargetWith = function(elem, toolbars) {
        return findMap(toolbars, function(toolbarApi) {
            return toolbarApi.predicate(elem.dom())
                ? Option.some({
                      toolbarApi,
                      elem,
                  })
                : Option.none();
        });
    };
    const lookup$1 = function(scopes, editor) {
        const isRoot = function(elem) {
            return elem.dom() === editor.getBody();
        };
        const startNode = Element.fromDom(editor.selection.getNode());
        return matchTargetWith(startNode, scopes.inNodeScope).orThunk(
            function() {
                return matchTargetWith(startNode, scopes.inEditorScope).orThunk(
                    function() {
                        return ancestor$2(
                            startNode,
                            function(elem) {
                                return matchTargetWith(
                                    elem,
                                    scopes.inNodeScope,
                                );
                            },
                            isRoot,
                        );
                    },
                );
            },
        );
    };
    const ToolbarLookup = { lookup: lookup$1 };

    const categorise = function(contextToolbars, navigate) {
        const forms = {};
        const inNodeScope = [];
        const inEditorScope = [];
        const formNavigators = {};
        const lookupTable = {};
        const registerForm = function(key, toolbarApi) {
            const contextForm = getOrDie(createContextForm(toolbarApi));
            forms[key] = contextForm;
            contextForm.launch.map(function(launch) {
                formNavigators[`form:${key}`] = {
                    ...toolbarApi.launch,
                    type:
                        launch.type === 'contextformtogglebutton'
                            ? 'togglebutton'
                            : 'button',
                    onAction() {
                        navigate(contextForm);
                    },
                };
            });
            if (contextForm.scope === 'editor') {
                inEditorScope.push(contextForm);
            } else {
                inNodeScope.push(contextForm);
            }
            lookupTable[key] = contextForm;
        };
        const registerToolbar = function(key, toolbarApi) {
            createContextToolbar(toolbarApi).each(function(contextToolbar) {
                if (toolbarApi.scope === 'editor') {
                    inEditorScope.push(contextToolbar);
                } else {
                    inNodeScope.push(contextToolbar);
                }
                lookupTable[key] = contextToolbar;
            });
        };
        const keys$1 = keys(contextToolbars);
        each(keys$1, function(key) {
            const toolbarApi = contextToolbars[key];
            if (toolbarApi.type === 'contextform') {
                registerForm(key, toolbarApi);
            } else if (toolbarApi.type === 'contexttoolbar') {
                registerToolbar(key, toolbarApi);
            }
        });
        return {
            forms,
            inNodeScope,
            inEditorScope,
            lookupTable,
            formNavigators,
        };
    };
    const ToolbarScopes = { categorise };

    const forwardSlideEvent = generate$1('forward-slide');
    const backSlideEvent = generate$1('backward-slide');
    const changeSlideEvent = generate$1('change-slide-event');
    const resizingClass = 'tox-pop--resizing';
    const renderContextToolbar = function(spec) {
        const stack = Cell([]);
        return InlineView.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-pop'],
            },
            fireDismissalEventInstead: { event: 'doNotDismissYet' },
            onShow(comp) {
                stack.set([]);
                InlineView.getContent(comp).each(function(c) {
                    remove$6(c.element(), 'visibility');
                });
                remove$4(comp.element(), resizingClass);
                remove$6(comp.element(), 'width');
            },
            inlineBehaviours: derive$1([
                config('context-toolbar-events', [
                    runOnSource(transitionend(), function(comp, se) {
                        InlineView.getContent(comp).each(function(c) {});
                        remove$4(comp.element(), resizingClass);
                        remove$6(comp.element(), 'width');
                    }),
                    run(changeSlideEvent, function(comp, se) {
                        remove$6(comp.element(), 'width');
                        const currentWidth = get$7(comp.element());
                        InlineView.setContent(comp, se.event().contents());
                        add$2(comp.element(), resizingClass);
                        const newWidth = get$7(comp.element());
                        set$2(comp.element(), 'width', `${currentWidth}px`);
                        InlineView.getContent(comp).each(function(newContents) {
                            se.event()
                                .focus()
                                .bind(function(f) {
                                    focus$1(f);
                                    return search(comp.element());
                                })
                                .orThunk(function() {
                                    Keying.focusIn(newContents);
                                    return active();
                                });
                        });
                        global$2.setTimeout(function() {
                            set$2(comp.element(), 'width', `${newWidth}px`);
                        }, 0);
                    }),
                    run(forwardSlideEvent, function(comp, se) {
                        InlineView.getContent(comp).each(function(oldContents) {
                            stack.set(
                                stack.get().concat([
                                    {
                                        bar: oldContents,
                                        focus: active(),
                                    },
                                ]),
                            );
                        });
                        emitWith(comp, changeSlideEvent, {
                            contents: se.event().forwardContents(),
                            focus: Option.none(),
                        });
                    }),
                    run(backSlideEvent, function(comp, se) {
                        last(stack.get()).each(function(last) {
                            stack.set(
                                stack.get().slice(0, stack.get().length - 1),
                            );
                            emitWith(comp, changeSlideEvent, {
                                contents: premade$1(last.bar),
                                focus: last.focus,
                            });
                        });
                    }),
                ]),
                Keying.config({
                    mode: 'special',
                    onEscape(comp) {
                        return last(stack.get()).fold(
                            function() {
                                return spec.onEscape();
                            },
                            function(_) {
                                emit(comp, backSlideEvent);
                                return Option.some(true);
                            },
                        );
                    },
                }),
            ]),
            lazySink() {
                return Result.value(spec.sink);
            },
        });
    };

    const onSetupFormatToggle = function(editor, name) {
        return function(api) {
            const unbindCell = Cell(Option.none());
            const init = function() {
                api.setActive(editor.formatter.match(name));
                const { unbind } = editor.formatter.formatChanged(
                    name,
                    api.setActive,
                );
                unbindCell.set(Option.some(unbind));
            };
            editor.initialized ? init() : editor.on('init', init);
            return function() {
                return unbindCell.get().each(function(unbind) {
                    return unbind();
                });
            };
        };
    };
    const onActionToggleFormat = function(editor) {
        return function(rawItem) {
            return function() {
                editor.undoManager.transact(function() {
                    editor.focus();
                    editor.execCommand(
                        'mceToggleFormat',
                        false,
                        rawItem.format,
                    );
                });
            };
        };
    };

    const generateSelectItems = function(_editor, backstage, spec) {
        const generateItem = function(rawItem, response, disabled, value) {
            const translatedText = backstage.shared.providers.translate(
                rawItem.title,
            );
            if (rawItem.type === 'separator') {
                return Option.some({
                    type: 'separator',
                    text: translatedText,
                });
            }
            if (rawItem.type === 'submenu') {
                const items = bind(rawItem.getStyleItems(), function(si) {
                    return validate(si, response, value);
                });
                if (response === 0 && items.length <= 0) {
                    return Option.none();
                }
                return Option.some({
                    type: 'nestedmenuitem',
                    text: translatedText,
                    disabled: items.length <= 0,
                    getSubmenuItems() {
                        return bind(rawItem.getStyleItems(), function(si) {
                            return validate(si, response, value);
                        });
                    },
                });
            }
            return Option.some({
                type: 'togglemenuitem',
                text: translatedText,
                active: rawItem.isSelected(value),
                disabled,
                onAction: spec.onAction(rawItem),
                ...rawItem.getStylePreview().fold(
                    function() {
                        return {};
                    },
                    function(preview) {
                        return { meta: { style: preview } };
                    },
                ),
            });
        };
        var validate = function(item, response, value) {
            const invalid = item.type === 'formatter' && spec.isInvalid(item);
            if (response === 0) {
                return invalid
                    ? []
                    : generateItem(item, response, false, value).toArray();
            }
            return generateItem(item, response, invalid, value).toArray();
        };
        const validateItems = function(preItems) {
            const value = spec.getCurrentValue();
            const response = spec.shouldHide ? 0 : 1;
            return bind(preItems, function(item) {
                return validate(item, response, value);
            });
        };
        const getFetch = function(backstage, getStyleItems) {
            return function(callback) {
                const preItems = getStyleItems();
                const items = validateItems(preItems);
                const menu = build$2(
                    items,
                    ItemResponse$1.CLOSE_ON_EXECUTE,
                    backstage,
                    false,
                );
                callback(menu);
            };
        };
        return {
            validateItems,
            getFetch,
        };
    };
    const createMenuItems = function(editor, backstage, spec) {
        const { dataset } = spec;
        const getStyleItems =
            dataset.type === 'basic'
                ? function() {
                      return map(dataset.data, function(d) {
                          return processBasic(
                              d,
                              spec.isSelectedFor,
                              spec.getPreviewFor,
                          );
                      });
                  }
                : dataset.getData;
        return {
            items: generateSelectItems(editor, backstage, spec),
            getStyleItems,
        };
    };
    const createSelectButton = function(editor, backstage, spec) {
        const _a = createMenuItems(editor, backstage, spec);
        const { items } = _a;
        const { getStyleItems } = _a;
        const getApi = function(comp) {
            return {
                getComponent() {
                    return comp;
                },
            };
        };
        const onSetup = function(api) {
            spec.setInitialValue.each(function(f) {
                return f(api.getComponent());
            });
            return spec.nodeChangeHandler
                .map(function(f) {
                    const handler = f(api.getComponent());
                    editor.on('NodeChange', handler);
                    return function() {
                        editor.off('NodeChange', handler);
                    };
                })
                .getOr(noop);
        };
        return renderCommonDropdown(
            {
                text: spec.icon.isSome() ? Option.none() : Option.some(''),
                icon: spec.icon,
                tooltip: Option.from(spec.tooltip),
                role: Option.none(),
                fetch: items.getFetch(backstage, getStyleItems),
                onSetup,
                getApi,
                columns: 1,
                presets: 'normal',
                classes: spec.icon.isSome() ? [] : ['bespoke'],
                dropdownBehaviours: [],
            },
            'tox-tbtn',
            backstage.shared,
        );
    };

    const process = function(rawFormats) {
        return map(rawFormats, function(item) {
            let title = item;
            let format = item;
            const values = item.split('=');
            if (values.length > 1) {
                title = values[0];
                format = values[1];
            }
            return {
                title,
                format,
            };
        });
    };
    const buildBasicStaticDataset = function(data) {
        return {
            type: 'basic',
            data,
        };
    };
    let Delimiter;
    (function(Delimiter) {
        Delimiter[(Delimiter.SemiColon = 0)] = 'SemiColon';
        Delimiter[(Delimiter.Space = 1)] = 'Space';
    })(Delimiter || (Delimiter = {}));
    const split = function(rawFormats, delimiter) {
        if (delimiter === Delimiter.SemiColon) {
            return rawFormats.replace(/;$/, '').split(';');
        }
        return rawFormats.split(' ');
    };
    const buildBasicSettingsDataset = function(
        editor,
        settingName,
        defaults,
        delimiter,
    ) {
        const rawFormats = readOptFrom$1(editor.settings, settingName).getOr(
            defaults,
        );
        const data = process(split(rawFormats, delimiter));
        return {
            type: 'basic',
            data,
        };
    };

    const alignMenuItems = [
        {
            title: 'Left',
            icon: 'align-left',
            format: 'alignleft',
        },
        {
            title: 'Center',
            icon: 'align-center',
            format: 'aligncenter',
        },
        {
            title: 'Right',
            icon: 'align-right',
            format: 'alignright',
        },
        {
            title: 'Justify',
            icon: 'align-justify',
            format: 'alignjustify',
        },
    ];
    const getSpec = function(editor) {
        const getMatchingValue = function() {
            return find(alignMenuItems, function(item) {
                return editor.formatter.match(item.format);
            });
        };
        const isSelectedFor = function(format) {
            return function() {
                return editor.formatter.match(format);
            };
        };
        const getPreviewFor = function(_format) {
            return function() {
                return Option.none();
            };
        };
        const updateSelectMenuIcon = function(comp) {
            const match = getMatchingValue();
            const alignment = match.fold(
                function() {
                    return 'left';
                },
                function(item) {
                    return item.title.toLowerCase();
                },
            );
            emitWith(comp, updateMenuIcon, { icon: `align-${alignment}` });
        };
        const nodeChangeHandler = Option.some(function(comp) {
            return function() {
                return updateSelectMenuIcon(comp);
            };
        });
        const setInitialValue = Option.some(function(comp) {
            return updateSelectMenuIcon(comp);
        });
        const dataset = buildBasicStaticDataset(alignMenuItems);
        return {
            tooltip: 'Align',
            icon: Option.some('align-left'),
            isSelectedFor,
            getCurrentValue: constant(Option.none()),
            getPreviewFor,
            onAction: onActionToggleFormat(editor),
            setInitialValue,
            nodeChangeHandler,
            dataset,
            shouldHide: false,
            isInvalid(item) {
                return !editor.formatter.canApply(item.format);
            },
        };
    };
    const createAlignSelect = function(editor, backstage) {
        return createSelectButton(editor, backstage, getSpec(editor));
    };
    const alignSelectMenu = function(editor, backstage) {
        const menuItems = createMenuItems(editor, backstage, getSpec(editor));
        editor.ui.registry.addNestedMenuItem('align', {
            text: backstage.shared.providers.translate('Align'),
            getSubmenuItems() {
                return menuItems.items.validateItems(menuItems.getStyleItems());
            },
        });
    };

    const defaultFontsFormats =
        'Andale Mono=andale mono,monospace;' +
        'Arial=arial,helvetica,sans-serif;' +
        'Arial Black=arial black,sans-serif;' +
        'Book Antiqua=book antiqua,palatino,serif;' +
        'Comic Sans MS=comic sans ms,sans-serif;' +
        'Courier New=courier new,courier,monospace;' +
        'Georgia=georgia,palatino,serif;' +
        'Helvetica=helvetica,arial,sans-serif;' +
        'Impact=impact,sans-serif;' +
        'Symbol=symbol;' +
        'Tahoma=tahoma,arial,helvetica,sans-serif;' +
        'Terminal=terminal,monaco,monospace;' +
        'Times New Roman=times new roman,times,serif;' +
        'Trebuchet MS=trebuchet ms,geneva,sans-serif;' +
        'Verdana=verdana,geneva,sans-serif;' +
        'Webdings=webdings;' +
        'Wingdings=wingdings,zapf dingbats';
    const systemStackFonts = [
        '-apple-system',
        'Segoe UI',
        'Roboto',
        'Helvetica Neue',
        'sans-serif',
    ];
    const splitFonts = function(fontFamily) {
        const fonts = fontFamily.split(/\s*,\s*/);
        return map(fonts, function(font) {
            return font.replace(/^['"]+|['"]+$/g, '');
        });
    };
    const isSystemFontStack = function(fontFamily) {
        const matchesSystemStack = function() {
            const fonts = splitFonts(fontFamily.toLowerCase());
            return forall(systemStackFonts, function(font) {
                return fonts.indexOf(font.toLowerCase()) > -1;
            });
        };
        return (
            fontFamily.indexOf('-apple-system') === 0 && matchesSystemStack()
        );
    };
    const getSpec$1 = function(editor) {
        const getMatchingValue = function() {
            const getFirstFont = function(fontFamily) {
                return fontFamily ? splitFonts(fontFamily)[0] : '';
            };
            const fontFamily = editor.queryCommandValue('FontName');
            const items = dataset.data;
            const font = fontFamily ? fontFamily.toLowerCase() : '';
            const matchOpt = find(items, function(item) {
                const { format } = item;
                return (
                    format.toLowerCase() === font ||
                    getFirstFont(format).toLowerCase() ===
                        getFirstFont(font).toLowerCase()
                );
            }).orThunk(function() {
                if (isSystemFontStack(font)) {
                    return Option.from({
                        title: 'System Font',
                        format: font,
                    });
                }
                return Option.none();
            });
            return {
                matchOpt,
                font: fontFamily,
            };
        };
        const isSelectedFor = function(item) {
            return function(valueOpt) {
                return valueOpt.exists(function(value) {
                    return value.format === item;
                });
            };
        };
        const getCurrentValue = function() {
            const { matchOpt } = getMatchingValue();
            return matchOpt;
        };
        const getPreviewFor = function(item) {
            return function() {
                return Option.some({
                    tag: 'div',
                    styleAttr:
                        item.indexOf('dings') === -1
                            ? `font-family:${item}`
                            : '',
                });
            };
        };
        const onAction = function(rawItem) {
            return function() {
                editor.undoManager.transact(function() {
                    editor.focus();
                    editor.execCommand('FontName', false, rawItem.format);
                });
            };
        };
        const updateSelectMenuText = function(comp) {
            const _a = getMatchingValue();
            const { matchOpt } = _a;
            const { font } = _a;
            const text = matchOpt.fold(
                function() {
                    return font;
                },
                function(item) {
                    return item.title;
                },
            );
            emitWith(comp, updateMenuText, { text });
        };
        const nodeChangeHandler = Option.some(function(comp) {
            return function() {
                return updateSelectMenuText(comp);
            };
        });
        const setInitialValue = Option.some(function(comp) {
            return updateSelectMenuText(comp);
        });
        var dataset = buildBasicSettingsDataset(
            editor,
            'font_formats',
            defaultFontsFormats,
            Delimiter.SemiColon,
        );
        return {
            tooltip: 'Fonts',
            icon: Option.none(),
            isSelectedFor,
            getCurrentValue,
            getPreviewFor,
            onAction,
            setInitialValue,
            nodeChangeHandler,
            dataset,
            shouldHide: false,
            isInvalid() {
                return false;
            },
        };
    };
    const createFontSelect = function(editor, backstage) {
        return createSelectButton(editor, backstage, getSpec$1(editor));
    };
    const fontSelectMenu = function(editor, backstage) {
        const menuItems = createMenuItems(editor, backstage, getSpec$1(editor));
        editor.ui.registry.addNestedMenuItem('fontformats', {
            text: backstage.shared.providers.translate('Fonts'),
            getSubmenuItems() {
                return menuItems.items.validateItems(menuItems.getStyleItems());
            },
        });
    };

    const defaultFontsizeFormats = '8pt 10pt 12pt 14pt 18pt 24pt 36pt';
    const legacyFontSizes = {
        '8pt': '1',
        '10pt': '2',
        '12pt': '3',
        '14pt': '4',
        '18pt': '5',
        '24pt': '6',
        '36pt': '7',
    };
    const round$1 = function(number, precision) {
        const factor = Math.pow(10, precision);
        return Math.round(number * factor) / factor;
    };
    const toPt = function(fontSize, precision) {
        if (/[0-9.]+px$/.test(fontSize)) {
            return `${round$1(
                (parseInt(fontSize, 10) * 72) / 96,
                precision || 0,
            )}pt`;
        }
        return fontSize;
    };
    const toLegacy = function(fontSize) {
        return get(legacyFontSizes, fontSize).getOr('');
    };
    const getSpec$2 = function(editor) {
        const getMatchingValue = function() {
            let matchOpt = Option.none();
            const items = dataset.data;
            const fontSize = editor.queryCommandValue('FontSize');
            if (fontSize) {
                const _loop_1 = function(precision) {
                    const pt = toPt(fontSize, precision);
                    const legacy = toLegacy(pt);
                    matchOpt = find(items, function(item) {
                        return (
                            item.format === fontSize ||
                            item.format === pt ||
                            item.format === legacy
                        );
                    });
                };
                for (
                    let precision = 3;
                    matchOpt.isNone() && precision >= 0;
                    precision--
                ) {
                    _loop_1(precision);
                }
            }
            return {
                matchOpt,
                size: fontSize,
            };
        };
        const isSelectedFor = function(item) {
            return function(valueOpt) {
                return valueOpt.exists(function(value) {
                    return value.format === item;
                });
            };
        };
        const getCurrentValue = function() {
            const { matchOpt } = getMatchingValue();
            return matchOpt;
        };
        const getPreviewFor = constant(constant(Option.none()));
        const onAction = function(rawItem) {
            return function() {
                editor.undoManager.transact(function() {
                    editor.focus();
                    editor.execCommand('FontSize', false, rawItem.format);
                });
            };
        };
        const updateSelectMenuText = function(comp) {
            const _a = getMatchingValue();
            const { matchOpt } = _a;
            const { size } = _a;
            const text = matchOpt.fold(
                function() {
                    return size;
                },
                function(match) {
                    return match.title;
                },
            );
            emitWith(comp, updateMenuText, { text });
        };
        const nodeChangeHandler = Option.some(function(comp) {
            return function() {
                return updateSelectMenuText(comp);
            };
        });
        const setInitialValue = Option.some(function(comp) {
            return updateSelectMenuText(comp);
        });
        var dataset = buildBasicSettingsDataset(
            editor,
            'fontsize_formats',
            defaultFontsizeFormats,
            Delimiter.Space,
        );
        return {
            tooltip: 'Font sizes',
            icon: Option.none(),
            isSelectedFor,
            getPreviewFor,
            getCurrentValue,
            onAction,
            setInitialValue,
            nodeChangeHandler,
            dataset,
            shouldHide: false,
            isInvalid() {
                return false;
            },
        };
    };
    const createFontsizeSelect = function(editor, backstage) {
        return createSelectButton(editor, backstage, getSpec$2(editor));
    };
    const fontsizeSelectMenu = function(editor, backstage) {
        const menuItems = createMenuItems(editor, backstage, getSpec$2(editor));
        editor.ui.registry.addNestedMenuItem('fontsizes', {
            text: 'Font sizes',
            getSubmenuItems() {
                return menuItems.items.validateItems(menuItems.getStyleItems());
            },
        });
    };

    const findNearest = function(editor, getStyles, parents) {
        const styles = getStyles();
        return findMap(parents, function(parent) {
            return find(styles, function(fmt) {
                return editor.formatter.matchNode(parent, fmt.format);
            });
        }).orThunk(function() {
            if (editor.formatter.match('p')) {
                return Option.some({
                    title: 'Paragraph',
                    format: 'p',
                });
            }
            return Option.none();
        });
    };
    const getCurrentSelectionParents = function(editor) {
        const currentNode = editor.selection.getStart(true) || editor.getBody();
        return editor.dom.getParents(
            currentNode,
            function() {
                return true;
            },
            editor.getBody(),
        );
    };

    const defaultBlocks =
        'Paragraph=p;' +
        'Heading 1=h1;' +
        'Heading 2=h2;' +
        'Heading 3=h3;' +
        'Heading 4=h4;' +
        'Heading 5=h5;' +
        'Heading 6=h6;' +
        'Preformatted=pre';
    const getSpec$3 = function(editor) {
        const getMatchingValue = function(nodeChangeEvent) {
            return findNearest(
                editor,
                function() {
                    return dataset.data;
                },
                nodeChangeEvent,
            );
        };
        const isSelectedFor = function(format) {
            return function() {
                return editor.formatter.match(format);
            };
        };
        const getPreviewFor = function(format) {
            return function() {
                const fmt = editor.formatter.get(format);
                return Option.some({
                    tag:
                        fmt.length > 0
                            ? fmt[0].inline || fmt[0].block || 'div'
                            : 'div',
                    styleAttr: editor.formatter.getCssText(format),
                });
            };
        };
        const updateSelectMenuText = function(parents, comp) {
            const detectedFormat = getMatchingValue(parents);
            const text = detectedFormat.fold(
                function() {
                    return 'Paragraph';
                },
                function(fmt) {
                    return fmt.title;
                },
            );
            emitWith(comp, updateMenuText, { text });
        };
        const nodeChangeHandler = Option.some(function(comp) {
            return function(e) {
                return updateSelectMenuText(e.parents, comp);
            };
        });
        const setInitialValue = Option.some(function(comp) {
            const parents = getCurrentSelectionParents(editor);
            updateSelectMenuText(parents, comp);
        });
        var dataset = buildBasicSettingsDataset(
            editor,
            'block_formats',
            defaultBlocks,
            Delimiter.SemiColon,
        );
        return {
            tooltip: 'Blocks',
            icon: Option.none(),
            isSelectedFor,
            getCurrentValue: constant(Option.none()),
            getPreviewFor,
            onAction: onActionToggleFormat(editor),
            setInitialValue,
            nodeChangeHandler,
            dataset,
            shouldHide: false,
            isInvalid(item) {
                return !editor.formatter.canApply(item.format);
            },
        };
    };
    const createFormatSelect = function(editor, backstage) {
        return createSelectButton(editor, backstage, getSpec$3(editor));
    };
    const formatSelectMenu = function(editor, backstage) {
        const menuItems = createMenuItems(editor, backstage, getSpec$3(editor));
        editor.ui.registry.addNestedMenuItem('blockformats', {
            text: 'Blocks',
            getSubmenuItems() {
                return menuItems.items.validateItems(menuItems.getStyleItems());
            },
        });
    };

    const getSpec$4 = function(editor, dataset) {
        const isSelectedFor = function(format) {
            return function() {
                return editor.formatter.match(format);
            };
        };
        const getPreviewFor = function(format) {
            return function() {
                const fmt = editor.formatter.get(format);
                return fmt !== undefined
                    ? Option.some({
                          tag:
                              fmt.length > 0
                                  ? fmt[0].inline || fmt[0].block || 'div'
                                  : 'div',
                          styleAttr: editor.formatter.getCssText(format),
                      })
                    : Option.none();
            };
        };
        const updateSelectMenuText = function(parents, comp) {
            var getFormatItems = function(fmt) {
                const subs = fmt.items;
                return subs !== undefined && subs.length > 0
                    ? bind(subs, getFormatItems)
                    : [
                          {
                              title: fmt.title,
                              format: fmt.format,
                          },
                      ];
            };
            const flattenedItems = bind(
                getStyleFormats(editor),
                getFormatItems,
            );
            const detectedFormat = findNearest(
                editor,
                function() {
                    return flattenedItems;
                },
                parents,
            );
            const text = detectedFormat.fold(
                function() {
                    return 'Paragraph';
                },
                function(fmt) {
                    return fmt.title;
                },
            );
            emitWith(comp, updateMenuText, { text });
        };
        const nodeChangeHandler = Option.some(function(comp) {
            return function(e) {
                return updateSelectMenuText(e.parents, comp);
            };
        });
        const setInitialValue = Option.some(function(comp) {
            const parents = getCurrentSelectionParents(editor);
            updateSelectMenuText(parents, comp);
        });
        return {
            tooltip: 'Formats',
            icon: Option.none(),
            isSelectedFor,
            getCurrentValue: constant(Option.none()),
            getPreviewFor,
            onAction: onActionToggleFormat(editor),
            setInitialValue,
            nodeChangeHandler,
            shouldHide: editor.getParam(
                'style_formats_autohide',
                false,
                'boolean',
            ),
            isInvalid(item) {
                return !editor.formatter.canApply(item.format);
            },
            dataset,
        };
    };
    const createStyleSelect = function(editor, backstage) {
        const dataset = { type: 'advanced', ...backstage.styleselect };
        return createSelectButton(
            editor,
            backstage,
            getSpec$4(editor, dataset),
        );
    };
    const styleSelectMenu = function(editor, backstage) {
        const dataset = { type: 'advanced', ...backstage.styleselect };
        const menuItems = createMenuItems(
            editor,
            backstage,
            getSpec$4(editor, dataset),
        );
        editor.ui.registry.addNestedMenuItem('formats', {
            text: 'Formats',
            getSubmenuItems() {
                return menuItems.items.validateItems(menuItems.getStyleItems());
            },
        });
    };

    const defaultToolbar = [
        {
            name: 'history',
            items: ['undo', 'redo'],
        },
        {
            name: 'styles',
            items: ['styleselect'],
        },
        {
            name: 'formatting',
            items: ['bold', 'italic'],
        },
        {
            name: 'alignment',
            items: ['alignleft', 'aligncenter', 'alignright', 'alignjustify'],
        },
        {
            name: 'indentation',
            items: ['outdent', 'indent'],
        },
        {
            name: 'permanent pen',
            items: ['permanentpen'],
        },
        {
            name: 'comments',
            items: ['addcomment'],
        },
    ];
    const renderFromBridge = function(bridgeBuilder, render) {
        return function(spec, extras) {
            const internal = bridgeBuilder(spec)
                .mapError(function(errInfo) {
                    return formatError(errInfo);
                })
                .getOrDie();
            return render(internal, extras);
        };
    };
    const types = {
        button: renderFromBridge(createToolbarButton, function(s, extras) {
            return renderToolbarButton(s, extras.backstage.shared.providers);
        }),
        togglebutton: renderFromBridge(createToggleButton, function(s, extras) {
            return renderToolbarToggleButton(
                s,
                extras.backstage.shared.providers,
            );
        }),
        menubutton: renderFromBridge(createMenuButton, function(s, extras) {
            return renderMenuButton(
                s,
                'tox-tbtn',
                extras.backstage,
                Option.none(),
            );
        }),
        splitbutton: renderFromBridge(createSplitButton, function(s, extras) {
            return renderSplitButton(s, extras.backstage.shared);
        }),
        styleSelectButton(editor, extras) {
            return createStyleSelect(editor, extras.backstage);
        },
        fontsizeSelectButton(editor, extras) {
            return createFontsizeSelect(editor, extras.backstage);
        },
        fontSelectButton(editor, extras) {
            return createFontSelect(editor, extras.backstage);
        },
        formatButton(editor, extras) {
            return createFormatSelect(editor, extras.backstage);
        },
        alignMenuButton(editor, extras) {
            return createAlignSelect(editor, extras.backstage);
        },
    };
    const extractFrom = function(spec, extras) {
        return get(types, spec.type).fold(
            function() {
                domGlobals.console.error('skipping button defined by', spec);
                return Option.none();
            },
            function(render) {
                return Option.some(render(spec, extras));
            },
        );
    };
    const bespokeButtons = {
        styleselect: types.styleSelectButton,
        fontsizeselect: types.fontsizeSelectButton,
        fontselect: types.fontSelectButton,
        formatselect: types.formatButton,
        align: types.alignMenuButton,
    };
    const removeUnusedDefaults = function(buttons) {
        const filteredItemGroups = map(defaultToolbar, function(group) {
            const items = filter(group.items, function(subItem) {
                return has(buttons, subItem) || has(bespokeButtons, subItem);
            });
            return {
                name: group.name,
                items,
            };
        });
        return filter(filteredItemGroups, function(group) {
            return group.items.length > 0;
        });
    };
    const convertStringToolbar = function(strToolbar) {
        const groupsStrings = strToolbar.split('|');
        return map(groupsStrings, function(g) {
            return { items: g.trim().split(' ') };
        });
    };
    const isToolbarGroupSettingArray = function(toolbar) {
        return isArrayOf(toolbar, function(t) {
            return has(t, 'name') && has(t, 'items');
        });
    };
    const createToolbar = function(toolbarConfig) {
        const { toolbar } = toolbarConfig;
        const { buttons } = toolbarConfig;
        if (toolbar === false) {
            return [];
        }
        if (toolbar === undefined || toolbar === true) {
            return removeUnusedDefaults(buttons);
        }
        if (isString(toolbar)) {
            return convertStringToolbar(toolbar);
        }
        if (isToolbarGroupSettingArray(toolbar)) {
            return toolbar;
        }
        domGlobals.console.error(
            'Toolbar type should be string, string[], boolean or ToolbarGroup[]',
        );
        return [];
    };
    const lookupButton = function(
        editor,
        buttons,
        toolbarItem,
        extras,
        prefixes,
    ) {
        return get(buttons, toolbarItem.toLowerCase())
            .orThunk(function() {
                return prefixes.bind(function(ps) {
                    return findMap(ps, function(prefix) {
                        return get(buttons, prefix + toolbarItem.toLowerCase());
                    });
                });
            })
            .fold(
                function() {
                    return get(bespokeButtons, toolbarItem.toLowerCase())
                        .map(function(r) {
                            return r(editor, extras);
                        })
                        .orThunk(function() {
                            return Option.none();
                        });
                },
                function(spec) {
                    return extractFrom(spec, extras);
                },
            );
    };
    const identifyButtons = function(editor, toolbarConfig, extras, prefixes) {
        const toolbarGroups = createToolbar(toolbarConfig);
        const groups = map(toolbarGroups, function(group) {
            const items = bind(group.items, function(toolbarItem) {
                return toolbarItem.trim().length === 0
                    ? []
                    : lookupButton(
                          editor,
                          toolbarConfig.buttons,
                          toolbarItem,
                          extras,
                          prefixes,
                      ).toArray();
            });
            return {
                title: Option.from(editor.translate(group.name)),
                items,
            };
        });
        return filter(groups, function(group) {
            return group.items.length > 0;
        });
    };

    const bubbleSize = 12;
    const bubbleAlignments$1 = {
        valignCentre: [],
        alignCentre: [],
        alignLeft: ['tox-pop--align-left'],
        alignRight: ['tox-pop--align-right'],
        right: ['tox-pop--right'],
        left: ['tox-pop--left'],
        bottom: ['tox-pop--bottom'],
        top: ['tox-pop--top'],
    };
    const anchorOverrides = {
        maxHeightFunction: expandable(),
        maxWidthFunction: expandable$1(),
    };
    const desktopAnchorSpecLayouts = {
        onLtr() {
            return [
                north$1,
                south$1,
                northeast$1,
                southeast$1,
                northwest$1,
                southwest$1,
                north$3,
                south$3,
                northeast$3,
                southeast$3,
                northwest$3,
                southwest$3,
            ];
        },
        onRtl() {
            return [
                north$1,
                south$1,
                northwest$1,
                southwest$1,
                northeast$1,
                southeast$1,
                north$3,
                south$3,
                northwest$3,
                southwest$3,
                northeast$3,
                southeast$3,
            ];
        },
    };
    const mobileAnchorSpecLayouts = {
        onLtr() {
            return [
                south$1,
                southeast$1,
                southwest$1,
                northeast$1,
                northwest$1,
                north$1,
                north$3,
                south$3,
                northeast$3,
                southeast$3,
                northwest$3,
                southwest$3,
            ];
        },
        onRtl() {
            return [
                south$1,
                southwest$1,
                southeast$1,
                northwest$1,
                northeast$1,
                north$1,
                north$3,
                south$3,
                northwest$3,
                southwest$3,
                northeast$3,
                southeast$3,
            ];
        },
    };
    const getAnchorLayout = function(position, isTouch) {
        if (position === 'line') {
            return {
                bubble: nu$8(bubbleSize, 0, bubbleAlignments$1),
                layouts: {
                    onLtr() {
                        return [east$1];
                    },
                    onRtl() {
                        return [west$1];
                    },
                },
                overrides: anchorOverrides,
            };
        }
        return {
            bubble: nu$8(0, bubbleSize, bubbleAlignments$1),
            layouts: isTouch
                ? mobileAnchorSpecLayouts
                : desktopAnchorSpecLayouts,
            overrides: anchorOverrides,
        };
    };
    const register$4 = function(editor, registryContextToolbars, sink, extras) {
        const { isTouch } = detect$3().deviceType;
        const contextbar = build$1(
            renderContextToolbar({
                sink,
                onEscape() {
                    editor.focus();
                    return Option.some(true);
                },
            }),
        );
        const getBounds = function() {
            return getContextToolbarBounds(editor);
        };
        const isRangeOverlapping = function(aTop, aBottom, bTop, bBottom) {
            return Math.max(aTop, bTop) <= Math.min(aBottom, bBottom);
        };
        const getLastElementVerticalBound = function() {
            const nodeBounds = lastElement
                .get()
                .map(function(ele) {
                    return ele.getBoundingClientRect();
                })
                .getOrThunk(function() {
                    return editor.selection.getRng().getBoundingClientRect();
                });
            const diffTop = editor.inline
                ? get$8().top()
                : absolute$1(Element.fromDom(editor.getBody())).y();
            return {
                y: nodeBounds.top + diffTop,
                bottom: nodeBounds.bottom + diffTop,
            };
        };
        const shouldContextToolbarHide = function() {
            if (isTouch() && extras.backstage.isContextMenuOpen()) {
                return true;
            }
            const lastElementBounds = getLastElementVerticalBound();
            const contextToolbarBounds = getBounds();
            return !isRangeOverlapping(
                lastElementBounds.y,
                lastElementBounds.bottom,
                contextToolbarBounds.y(),
                contextToolbarBounds.bottom(),
            );
        };
        const forceHide = function() {
            InlineView.hide(contextbar);
        };
        const hideOrRepositionIfNecessary = function() {
            lastAnchor.get().each(function(anchor) {
                const contextBarEle = contextbar.element();
                remove$6(contextBarEle, 'display');
                if (shouldContextToolbarHide()) {
                    set$2(contextBarEle, 'display', 'none');
                } else {
                    Positioning.positionWithinBounds(
                        sink,
                        anchor,
                        contextbar,
                        Option.some(getBounds()),
                    );
                }
            });
        };
        var lastAnchor = Cell(Option.none());
        var lastElement = Cell(Option.none());
        const timer = Cell(null);
        const wrapInPopDialog = function(toolbarSpec) {
            return {
                dom: {
                    tag: 'div',
                    classes: ['tox-pop__dialog'],
                },
                components: [toolbarSpec],
                behaviours: derive$1([
                    Keying.config({ mode: 'acyclic' }),
                    config('pop-dialog-wrap-events', [
                        runOnAttached(function(comp) {
                            editor.shortcuts.add(
                                'ctrl+F9',
                                'focus statusbar',
                                function() {
                                    return Keying.focusIn(comp);
                                },
                            );
                        }),
                        runOnDetached(function(comp) {
                            editor.shortcuts.remove('ctrl+F9');
                        }),
                    ]),
                ]),
            };
        };
        const getScopes = cached(function() {
            return ToolbarScopes.categorise(registryContextToolbars, function(
                toolbarApi,
            ) {
                const alloySpec = buildToolbar(toolbarApi);
                emitWith(contextbar, forwardSlideEvent, {
                    forwardContents: wrapInPopDialog(alloySpec),
                });
            });
        });
        var buildToolbar = function(ctx) {
            const { buttons } = editor.ui.registry.getAll();
            const toolbarType =
                getToolbarDrawer(editor) === ToolbarDrawer.scrolling
                    ? ToolbarDrawer.scrolling
                    : ToolbarDrawer.default;
            const scopes = getScopes();
            return ctx.type === 'contexttoolbar'
                ? (function() {
                      const allButtons = merge(buttons, scopes.formNavigators);
                      const initGroups = identifyButtons(
                          editor,
                          {
                              buttons: allButtons,
                              toolbar: ctx.items,
                          },
                          extras,
                          Option.some(['form:']),
                      );
                      return renderToolbar({
                          type: toolbarType,
                          uid: generate$1('context-toolbar'),
                          initGroups,
                          onEscape: Option.none,
                          cyclicKeying: true,
                          backstage: extras.backstage,
                          getSink() {
                              return Result.error('');
                          },
                      });
                  })()
                : (function() {
                      return ContextForm.renderContextForm(
                          toolbarType,
                          ctx,
                          extras.backstage,
                      );
                  })();
        };
        editor.on(showContextToolbarEvent, function(e) {
            const scopes = getScopes();
            readOptFrom$1(scopes.lookupTable, e.toolbarKey).each(function(ctx) {
                launchContext(
                    ctx,
                    e.target === editor ? Option.none() : Option.some(e),
                );
                InlineView.getContent(contextbar).each(Keying.focusIn);
            });
        });
        const getAnchor = function(position, element) {
            const anchorage =
                position === 'node'
                    ? extras.backstage.shared.anchors.node(element)
                    : extras.backstage.shared.anchors.cursor();
            return deepMerge(anchorage, getAnchorLayout(position, isTouch()));
        };
        var launchContext = function(toolbarApi, elem) {
            clearTimer();
            if (isTouch() && extras.backstage.isContextMenuOpen()) {
                return;
            }
            const toolbarSpec = buildToolbar(toolbarApi);
            const sElem = elem.map(Element.fromDom);
            const anchor = getAnchor(toolbarApi.position, sElem);
            lastAnchor.set(Option.some(anchor));
            lastElement.set(elem);
            const contextBarEle = contextbar.element();
            remove$6(contextBarEle, 'display');
            InlineView.showWithinBounds(
                contextbar,
                anchor,
                wrapInPopDialog(toolbarSpec),
                function() {
                    return Option.some(getBounds());
                },
            );
            if (shouldContextToolbarHide()) {
                set$2(contextBarEle, 'display', 'none');
            }
        };
        const launchContextToolbar = function() {
            const scopes = getScopes();
            ToolbarLookup.lookup(scopes, editor).fold(
                function() {
                    lastAnchor.set(Option.none());
                    InlineView.hide(contextbar);
                },
                function(info) {
                    launchContext(
                        info.toolbarApi,
                        Option.some(info.elem.dom()),
                    );
                },
            );
        };
        var clearTimer = function() {
            const current = timer.get();
            if (current !== null) {
                global$2.clearTimeout(current);
                timer.set(null);
            }
        };
        const resetTimer = function(t) {
            clearTimer();
            timer.set(t);
        };
        editor.on('init', function() {
            editor.on(hideContextToolbarEvent, forceHide);
            editor.on(
                'ScrollContent ScrollWindow longpress',
                hideOrRepositionIfNecessary,
            );
            editor.on(
                'click keyup SetContent ObjectResized ResizeEditor',
                function(e) {
                    resetTimer(
                        global$2.setEditorTimeout(
                            editor,
                            launchContextToolbar,
                            0,
                        ),
                    );
                },
            );
            editor.on('focusout', function(e) {
                global$2.setEditorTimeout(
                    editor,
                    function() {
                        if (
                            search(sink.element()).isNone() &&
                            search(contextbar.element()).isNone()
                        ) {
                            lastAnchor.set(Option.none());
                            InlineView.hide(contextbar);
                        }
                    },
                    0,
                );
            });
            editor.on('SwitchMode', function() {
                if (editor.readonly) {
                    lastAnchor.set(Option.none());
                    InlineView.hide(contextbar);
                }
            });
            editor.on('NodeChange', function(e) {
                search(contextbar.element()).fold(
                    function() {
                        resetTimer(
                            global$2.setEditorTimeout(
                                editor,
                                launchContextToolbar,
                                0,
                            ),
                        );
                    },
                    function(_) {},
                );
            });
        });
    };
    const ContextToolbar = { register: register$4 };

    const setup$4 = function(editor, mothership, uiMothership) {
        const broadcastEvent = function(name, evt) {
            each([mothership, uiMothership], function(ship) {
                ship.broadcastEvent(name, evt);
            });
        };
        const broadcastOn = function(channel, message) {
            each([mothership, uiMothership], function(ship) {
                ship.broadcastOn([channel], message);
            });
        };
        const fireDismissPopups = function(evt) {
            return broadcastOn(dismissPopups(), { target: evt.target() });
        };
        const onTouchstart = bind$3(
            Element.fromDom(domGlobals.document),
            'touchstart',
            fireDismissPopups,
        );
        const onTouchmove = bind$3(
            Element.fromDom(domGlobals.document),
            'touchmove',
            function(evt) {
                return broadcastEvent(documentTouchmove(), evt);
            },
        );
        const onTouchend = bind$3(
            Element.fromDom(domGlobals.document),
            'touchend',
            function(evt) {
                return broadcastEvent(documentTouchend(), evt);
            },
        );
        const onMousedown = bind$3(
            Element.fromDom(domGlobals.document),
            'mousedown',
            fireDismissPopups,
        );
        const onMouseup = bind$3(
            Element.fromDom(domGlobals.document),
            'mouseup',
            function(evt) {
                if (evt.raw().button === 0) {
                    broadcastOn(mouseReleased(), { target: evt.target() });
                }
            },
        );
        const onContentClick = function(raw) {
            return broadcastOn(dismissPopups(), {
                target: Element.fromDom(raw.target),
            });
        };
        const onContentMouseup = function(raw) {
            if (raw.button === 0) {
                broadcastOn(mouseReleased(), {
                    target: Element.fromDom(raw.target),
                });
            }
        };
        const onWindowScroll = function(evt) {
            return broadcastEvent(windowScroll(), fromRawEvent$1(evt));
        };
        const onWindowResize = function(evt) {
            broadcastOn(repositionPopups(), {});
            broadcastEvent(windowResize(), fromRawEvent$1(evt));
        };
        const onEditorResize = function() {
            return broadcastOn(repositionPopups(), {});
        };
        editor.on('PostRender', function() {
            editor.on('click', onContentClick);
            editor.on('tap', onContentClick);
            editor.on('mouseup', onContentMouseup);
            editor.on('ScrollWindow', onWindowScroll);
            editor.on('ResizeWindow', onWindowResize);
            editor.on('ResizeEditor', onEditorResize);
        });
        editor.on('remove', function() {
            editor.off('click', onContentClick);
            editor.off('tap', onContentClick);
            editor.off('mouseup', onContentMouseup);
            editor.off('ScrollWindow', onWindowScroll);
            editor.off('ResizeWindow', onWindowResize);
            editor.off('ResizeEditor', onEditorResize);
            onMousedown.unbind();
            onTouchstart.unbind();
            onTouchmove.unbind();
            onTouchend.unbind();
            onMouseup.unbind();
        });
        editor.on('detach', function() {
            detachSystem(mothership);
            detachSystem(uiMothership);
            mothership.destroy();
            uiMothership.destroy();
        });
    };
    const Events$1 = { setup: setup$4 };

    const parts$c = AlloyParts;
    const partType$1 = PartType;

    const schema$q = constant([
        defaulted$1('shell', false),
        strict$1('makeItem'),
        defaulted$1('setupItem', noop),
        SketchBehaviours.field('listBehaviours', [Replacing]),
    ]);
    const customListDetail = function(detail) {
        return { behaviours: derive$1([Replacing.config({})]) };
    };
    const itemsPart = optional({
        name: 'items',
        overrides: customListDetail,
    });
    const parts$d = constant([itemsPart]);
    const name$2 = constant('CustomList');

    const factory$e = function(detail, components, spec, external) {
        const setItems = function(list, items) {
            getListContainer(list).fold(
                function() {
                    domGlobals.console.error(
                        'Custom List was defined to not be a shell, but no item container was specified in components',
                    );
                    throw new Error(
                        'Custom List was defined to not be a shell, but no item container was specified in components',
                    );
                },
                function(container) {
                    const itemComps = Replacing.contents(container);
                    const numListsRequired = items.length;
                    const numListsToAdd = numListsRequired - itemComps.length;
                    const itemsToAdd =
                        numListsToAdd > 0
                            ? range(numListsToAdd, function() {
                                  return detail.makeItem();
                              })
                            : [];
                    const itemsToRemove = itemComps.slice(numListsRequired);
                    each(itemsToRemove, function(item) {
                        return Replacing.remove(container, item);
                    });
                    each(itemsToAdd, function(item) {
                        return Replacing.append(container, item);
                    });
                    const builtLists = Replacing.contents(container);
                    each(builtLists, function(item, i) {
                        detail.setupItem(list, item, items[i], i);
                    });
                },
            );
        };
        const extra = detail.shell
            ? {
                  behaviours: [Replacing.config({})],
                  components: [],
              }
            : {
                  behaviours: [],
                  components,
              };
        var getListContainer = function(component) {
            return detail.shell
                ? Option.some(component)
                : getPart(component, detail, 'items');
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components: extra.components,
            behaviours: augment(detail.listBehaviours, extra.behaviours),
            apis: { setItems },
        };
    };
    const CustomList = composite$1({
        name: name$2(),
        configFields: schema$q(),
        partFields: parts$d(),
        factory: factory$e,
        apis: {
            setItems(apis, list, items) {
                apis.setItems(list, items);
            },
        },
    });

    const getOrigin = function(element) {
        const isFixed = getRaw(element, 'position').is('fixed');
        const offsetParent$1 = isFixed ? Option.none() : offsetParent(element);
        return offsetParent$1
            .orThunk(function() {
                const marker = Element.fromTag('span');
                before(element, marker);
                const offsetParent$1 = offsetParent(marker);
                remove(marker);
                return offsetParent$1;
            })
            .map(absolute)
            .getOrThunk(function() {
                return Position(0, 0);
            });
    };

    const adt$c = Adt.generate([
        {
            offset: ['x', 'y'],
        },
        {
            absolute: ['x', 'y'],
        },
        {
            fixed: ['x', 'y'],
        },
    ]);
    const subtract = function(change) {
        return function(point) {
            return point.translate(-change.left(), -change.top());
        };
    };
    const add$4 = function(change) {
        return function(point) {
            return point.translate(change.left(), change.top());
        };
    };
    const transform$1 = function(changes) {
        return function(x, y) {
            return foldl(
                changes,
                function(rest, f) {
                    return f(rest);
                },
                Position(x, y),
            );
        };
    };
    const asFixed = function(coord, scroll, origin) {
        return coord.fold(
            transform$1([add$4(origin), subtract(scroll)]),
            transform$1([subtract(scroll)]),
            transform$1([]),
        );
    };
    const asAbsolute = function(coord, scroll, origin) {
        return coord.fold(
            transform$1([add$4(origin)]),
            transform$1([]),
            transform$1([add$4(scroll)]),
        );
    };
    const asOffset = function(coord, scroll, origin) {
        return coord.fold(
            transform$1([]),
            transform$1([subtract(origin)]),
            transform$1([add$4(scroll), subtract(origin)]),
        );
    };
    const withinRange = function(
        coord1,
        coord2,
        xRange,
        yRange,
        scroll,
        origin,
    ) {
        const a1 = asAbsolute(coord1, scroll, origin);
        const a2 = asAbsolute(coord2, scroll, origin);
        return (
            Math.abs(a1.left() - a2.left()) <= xRange &&
            Math.abs(a1.top() - a2.top()) <= yRange
        );
    };
    const getDeltas = function(coord1, coord2, xRange, yRange, scroll, origin) {
        const a1 = asAbsolute(coord1, scroll, origin);
        const a2 = asAbsolute(coord2, scroll, origin);
        const left = Math.abs(a1.left() - a2.left());
        const top = Math.abs(a1.top() - a2.top());
        return Position(left, top);
    };
    const toStyles = function(coord, scroll, origin) {
        return coord.fold(
            function(x, y) {
                return {
                    position: 'absolute',
                    left: `${x}px`,
                    top: `${y}px`,
                };
            },
            function(x, y) {
                return {
                    position: 'absolute',
                    left: `${x - origin.left()}px`,
                    top: `${y - origin.top()}px`,
                };
            },
            function(x, y) {
                return {
                    position: 'fixed',
                    left: `${x}px`,
                    top: `${y}px`,
                };
            },
        );
    };
    const translate$2 = function(coord, deltaX, deltaY) {
        return coord.fold(
            function(x, y) {
                return adt$c.offset(x + deltaX, y + deltaY);
            },
            function(x, y) {
                return adt$c.absolute(x + deltaX, y + deltaY);
            },
            function(x, y) {
                return adt$c.fixed(x + deltaX, y + deltaY);
            },
        );
    };
    const absorb = function(partialCoord, originalCoord, scroll, origin) {
        const absorbOne = function(stencil, nu) {
            return function(optX, optY) {
                const original = stencil(originalCoord, scroll, origin);
                return nu(
                    optX.getOr(original.left()),
                    optY.getOr(original.top()),
                );
            };
        };
        return partialCoord.fold(
            absorbOne(asOffset, adt$c.offset),
            absorbOne(asAbsolute, adt$c.absolute),
            absorbOne(asFixed, adt$c.fixed),
        );
    };
    const { offset } = adt$c;
    const absolute$3 = adt$c.absolute;
    const fixed$1 = adt$c.fixed;

    const morphAdt = Adt.generate([
        { static: [] },
        {
            absolute: ['x', 'y'],
        },
        {
            fixed: ['x', 'y'],
        },
    ]);
    const appear = function(component, contextualInfo) {
        const elem = component.element();
        add$2(elem, contextualInfo.transitionClass);
        remove$4(elem, contextualInfo.fadeOutClass);
        add$2(elem, contextualInfo.fadeInClass);
        contextualInfo.onShow(component);
    };
    const disappear = function(component, contextualInfo) {
        const elem = component.element();
        add$2(elem, contextualInfo.transitionClass);
        remove$4(elem, contextualInfo.fadeInClass);
        add$2(elem, contextualInfo.fadeOutClass);
        contextualInfo.onHide(component);
    };
    const isPartiallyVisible = function(box, viewport) {
        return box.y() < viewport.bottom() && box.bottom() > viewport.y();
    };
    const isTopCompletelyVisible = function(box, viewport) {
        return box.y() >= viewport.y();
    };
    const isBottomCompletelyVisible = function(box, viewport) {
        return box.bottom() <= viewport.bottom();
    };
    const isVisibleForModes = function(modes, box, viewport) {
        return forall(modes, function(mode) {
            switch (mode) {
                case 'bottom':
                    return isBottomCompletelyVisible(box, viewport);
                case 'top':
                    return isTopCompletelyVisible(box, viewport);
            }
        });
    };
    const getAttr = function(elem, attr) {
        return has$1(elem, attr)
            ? Option.some(parseInt(get$2(elem, attr), 10))
            : Option.none();
    };
    const getPrior = function(elem, dockInfo) {
        return getAttr(elem, dockInfo.leftAttr).bind(function(left) {
            return getAttr(elem, dockInfo.topAttr).map(function(top) {
                const w = get$7(elem);
                const h = get$6(elem);
                return bounds$1(left, top, w, h);
            });
        });
    };
    const setPrior = function(elem, dockInfo, absLeft, absTop, position) {
        set$1(elem, dockInfo.leftAttr, absLeft);
        set$1(elem, dockInfo.topAttr, absTop);
        set$1(elem, dockInfo.positionAttr, position);
    };
    const clearPrior = function(elem, dockInfo) {
        remove$1(elem, dockInfo.leftAttr);
        remove$1(elem, dockInfo.topAttr);
        remove$1(elem, dockInfo.positionAttr);
    };
    const revertToOriginal = function(elem, dockInfo, box) {
        const position = get$2(elem, dockInfo.positionAttr);
        clearPrior(elem, dockInfo);
        switch (position) {
            case 'static':
                return Option.some(morphAdt.static());
            case 'absolute':
                return Option.some(morphAdt.absolute(box.x(), box.y()));
            default:
                return Option.none();
        }
    };
    const morphToOriginal = function(elem, dockInfo, viewport) {
        return getPrior(elem, dockInfo)
            .filter(function(box) {
                return isVisibleForModes(dockInfo.modes, box, viewport);
            })
            .bind(function(box) {
                return revertToOriginal(elem, dockInfo, box);
            });
    };
    const morphToFixed = function(
        elem,
        dockInfo,
        viewport,
        scroll,
        lazyOrigin,
    ) {
        const box$1 = box(elem);
        if (!isVisibleForModes(dockInfo.modes, box$1, viewport)) {
            const origin = lazyOrigin();
            const position = get$4(elem, 'position');
            setPrior(elem, dockInfo, box$1.x(), box$1.y(), position);
            const coord = absolute$3(box$1.x(), box$1.y());
            const asFixed$1 = asFixed(coord, scroll, origin);
            const viewportPt = absolute$3(viewport.x(), viewport.y());
            const fixedViewport = asFixed(viewportPt, scroll, origin);
            const fixedY =
                box$1.y() <= viewport.y()
                    ? fixedViewport.top()
                    : fixedViewport.top() + viewport.height() - box$1.height();
            return Option.some(morphAdt.fixed(asFixed$1.left(), fixedY));
        }
        return Option.none();
    };
    const getMorph = function(
        component,
        dockInfo,
        viewport,
        scroll,
        lazyOrigin,
    ) {
        const elem = component.element();
        const isDocked = getRaw(elem, 'position').is('fixed');
        return isDocked
            ? morphToOriginal(elem, dockInfo, viewport)
            : morphToFixed(elem, dockInfo, viewport, scroll, lazyOrigin);
    };
    const getMorphToOriginal = function(component, dockInfo) {
        const elem = component.element();
        return getPrior(elem, dockInfo).bind(function(box) {
            return revertToOriginal(elem, dockInfo, box);
        });
    };

    const morphToStatic = function(component, config) {
        each(['left', 'top', 'position'], function(prop) {
            return remove$6(component.element(), prop);
        });
        config.onUndocked(component);
    };
    const morphToCoord = function(component, config, scroll, origin, morph) {
        const styles = toStyles(morph, scroll, origin);
        setAll$1(component.element(), styles);
        const method =
            styles.position === 'fixed' ? config.onDocked : config.onUndocked;
        method(component);
    };
    const updateVisibility = function(
        component,
        config,
        state,
        viewport,
        morphToDocked,
    ) {
        if (morphToDocked === void 0) {
            morphToDocked = false;
        }
        config.contextual.each(function(contextInfo) {
            contextInfo.lazyContext(component).each(function(box) {
                const isVisible = isPartiallyVisible(box, viewport);
                if (isVisible !== state.isVisible()) {
                    state.setVisible(isVisible);
                    if (morphToDocked && !isVisible) {
                        add$3(component.element(), [contextInfo.fadeOutClass]);
                        contextInfo.onHide(component);
                    } else {
                        const method = isVisible ? appear : disappear;
                        method(component, contextInfo);
                    }
                }
            });
        });
    };
    const refreshInternal = function(component, config, state) {
        const viewport = config.lazyViewport(component);
        const elem = component.element();
        const doc = owner(elem);
        const scroll = get$8(doc);
        const lazyOrigin = cached(function() {
            return getOrigin(elem);
        });
        const isDocked = state.isDocked();
        if (isDocked) {
            updateVisibility(component, config, state, viewport);
        }
        getMorph(component, config, viewport, scroll, lazyOrigin).each(function(
            morph,
        ) {
            state.setDocked(!isDocked);
            morph.fold(
                function() {
                    return morphToStatic(component, config);
                },
                function(x, y) {
                    return morphToCoord(
                        component,
                        config,
                        scroll,
                        lazyOrigin(),
                        absolute$3(x, y),
                    );
                },
                function(x, y) {
                    updateVisibility(component, config, state, viewport, true);
                    morphToCoord(
                        component,
                        config,
                        scroll,
                        lazyOrigin(),
                        fixed$1(x, y),
                    );
                },
            );
        });
    };
    const resetInternal = function(component, config, state) {
        const elem = component.element();
        state.setDocked(false);
        getMorphToOriginal(component, config).each(function(morph) {
            morph.fold(
                function() {
                    return morphToStatic(component, config);
                },
                function(x, y) {
                    const doc = owner(elem);
                    const scroll = get$8(doc);
                    const origin = getOrigin(elem);
                    morphToCoord(
                        component,
                        config,
                        scroll,
                        origin,
                        absolute$3(x, y),
                    );
                },
                noop,
            );
        });
        state.setVisible(true);
        config.contextual.each(function(contextInfo) {
            remove$5(elem, [
                contextInfo.fadeInClass,
                contextInfo.fadeOutClass,
                contextInfo.transitionClass,
            ]);
            contextInfo.onShow(component);
        });
        refresh$4(component, config, state);
    };
    var refresh$4 = function(component, config, state) {
        if (component.getSystem().isConnected()) {
            refreshInternal(component, config, state);
        }
    };
    const reset = function(component, config, state) {
        if (state.isDocked()) {
            resetInternal(component, config, state);
        }
    };
    const isDocked = function(component, config, state) {
        return state.isDocked();
    };

    const DockingApis = /* #__PURE__ */ Object.freeze({
        refresh: refresh$4,
        reset,
        isDocked,
    });

    const events$f = function(dockInfo, dockState) {
        return derive([
            runOnSource(transitionend(), function(component, simulatedEvent) {
                dockInfo.contextual.each(function(contextInfo) {
                    if (
                        has$2(component.element(), contextInfo.transitionClass)
                    ) {
                        remove$5(component.element(), [
                            contextInfo.transitionClass,
                            contextInfo.fadeInClass,
                        ]);
                        const notify = dockState.isVisible()
                            ? contextInfo.onShown
                            : contextInfo.onHidden;
                        notify(component);
                    }
                    simulatedEvent.stop();
                });
            }),
            run(windowScroll(), function(component, _) {
                refresh$4(component, dockInfo, dockState);
            }),
            run(windowResize(), function(component, _) {
                reset(component, dockInfo, dockState);
            }),
        ]);
    };

    const ActiveDocking = /* #__PURE__ */ Object.freeze({
        events: events$f,
    });

    const DockingSchema = [
        optionObjOf('contextual', [
            strictString('fadeInClass'),
            strictString('fadeOutClass'),
            strictString('transitionClass'),
            strictFunction('lazyContext'),
            onHandler('onShow'),
            onHandler('onShown'),
            onHandler('onHide'),
            onHandler('onHidden'),
        ]),
        defaultedFunction('lazyViewport', win),
        strictString('leftAttr'),
        strictString('topAttr'),
        strictString('positionAttr'),
        defaultedArrayOf('modes', ['top', 'bottom'], string),
        onHandler('onDocked'),
        onHandler('onUndocked'),
    ];

    const init$b = function() {
        const docked = Cell(false);
        const visible = Cell(true);
        const readState = function() {
            return `docked:  ${docked.get()}, visible: ${visible.get()}`;
        };
        return nu$5({
            isDocked() {
                return docked.get();
            },
            setDocked(state) {
                return docked.set(state);
            },
            isVisible() {
                return visible.get();
            },
            setVisible(state) {
                return visible.set(state);
            },
            readState,
        });
    };

    const DockingState = /* #__PURE__ */ Object.freeze({
        init: init$b,
    });

    const Docking = create$1({
        fields: DockingSchema,
        name: 'docking',
        active: ActiveDocking,
        apis: DockingApis,
        state: DockingState,
    });

    const visibility = {
        fadeInClass: 'tox-editor-dock-fadein',
        fadeOutClass: 'tox-editor-dock-fadeout',
        transitionClass: 'tox-editor-dock-transition',
    };
    const editorStickyOnClass = 'tox-tinymce--toolbar-sticky-on';
    const editorStickyOffClass = 'tox-tinymce--toolbar-sticky-off';
    const updateIframeContentFlow = function(header) {
        const elm = header.element();
        parent(elm).each(function(parentElem) {
            if (Docking.isDocked(header)) {
                const parentWidth = get$7(parentElem);
                set$2(elm, 'width', `${parentWidth}px`);
                const headerHeight = getOuter$1(elm);
                set$2(parentElem, 'padding-top', `${headerHeight}px`);
            } else {
                remove$6(elm, 'width');
                remove$6(parentElem, 'padding-top');
            }
        });
    };
    const updateSinkVisibility = function(sinkElem, visible) {
        if (visible) {
            remove$4(sinkElem, visibility.fadeOutClass);
            add$3(sinkElem, [
                visibility.transitionClass,
                visibility.fadeInClass,
            ]);
        } else {
            remove$4(sinkElem, visibility.fadeInClass);
            add$3(sinkElem, [
                visibility.fadeOutClass,
                visibility.transitionClass,
            ]);
        }
    };
    const updateEditorClasses = function(editor, docked) {
        const editorContainer = Element.fromDom(editor.getContainer());
        if (docked) {
            add$2(editorContainer, editorStickyOnClass);
            remove$4(editorContainer, editorStickyOffClass);
        } else {
            add$2(editorContainer, editorStickyOffClass);
            remove$4(editorContainer, editorStickyOnClass);
        }
    };
    const restoreFocus = function(headerElem, focusedElem) {
        const ownerDoc = owner(focusedElem);
        active(ownerDoc)
            .filter(function(activeElm) {
                return !eq(focusedElem, activeElm);
            })
            .filter(function(activeElm) {
                return (
                    eq(activeElm, Element.fromDom(ownerDoc.dom().body)) ||
                    contains$2(headerElem, activeElm)
                );
            })
            .each(function() {
                return focus$1(focusedElem);
            });
    };
    const findFocusedElem = function(rootElm, lazySink) {
        return search(rootElm).orThunk(function() {
            return lazySink()
                .toOption()
                .bind(function(sink) {
                    return search(sink.element());
                });
        });
    };
    const setup$5 = function(editor, lazyHeader) {
        if (!editor.inline) {
            editor.on('ResizeWindow ResizeEditor ResizeContent', function() {
                lazyHeader().each(updateIframeContentFlow);
            });
            editor.on('SkinLoaded', function() {
                lazyHeader().each(Docking.reset);
            });
            editor.on('FullscreenStateChanged', function() {
                lazyHeader().each(Docking.refresh);
            });
        }
        editor.on('PostRender', function() {
            updateEditorClasses(editor, false);
        });
    };
    const isDocked$1 = function(lazyHeader) {
        return lazyHeader()
            .map(Docking.isDocked)
            .getOr(false);
    };
    const getIframeBehaviours = function() {
        let _a;
        return [
            Receiving.config({
                channels:
                    ((_a = {}),
                    (_a[toolbarHeightChange()] = {
                        onReceive: updateIframeContentFlow,
                    }),
                    _a),
            }),
        ];
    };
    const getBehaviours$2 = function(editor, lazySink) {
        const focusedElm = Cell(Option.none());
        const runOnSinkElement = function(f) {
            lazySink().each(function(sink) {
                return f(sink.element());
            });
        };
        const onDockingSwitch = function(comp) {
            if (!editor.inline) {
                updateIframeContentFlow(comp);
            }
            updateEditorClasses(editor, Docking.isDocked(comp));
            comp.getSystem().broadcastOn([repositionPopups()], {});
            lazySink().each(function(sink) {
                return sink.getSystem().broadcastOn([repositionPopups()], {});
            });
        };
        const additionalBehaviours = editor.inline ? [] : getIframeBehaviours();
        return __spreadArrays(
            [
                Focusing.config({}),
                Docking.config({
                    leftAttr: 'data-dock-left',
                    topAttr: 'data-dock-top',
                    positionAttr: 'data-dock-pos',
                    contextual: {
                        lazyContext(comp) {
                            const headerHeight = getOuter$1(comp.element());
                            const container = editor.inline
                                ? editor.getContentAreaContainer()
                                : editor.getContainer();
                            const box$1 = box(Element.fromDom(container));
                            const boxHeight = box$1.height() - headerHeight;
                            return Option.some(
                                bounds$1(
                                    box$1.x(),
                                    box$1.y(),
                                    box$1.width(),
                                    boxHeight,
                                ),
                            );
                        },
                        onShow() {
                            runOnSinkElement(function(elem) {
                                return updateSinkVisibility(elem, true);
                            });
                        },
                        onShown(comp) {
                            runOnSinkElement(function(elem) {
                                return remove$5(elem, [
                                    visibility.transitionClass,
                                    visibility.fadeInClass,
                                ]);
                            });
                            focusedElm.get().each(function(elem) {
                                restoreFocus(comp.element(), elem);
                                focusedElm.set(Option.none());
                            });
                        },
                        onHide(comp) {
                            focusedElm.set(
                                findFocusedElem(comp.element(), lazySink),
                            );
                            runOnSinkElement(function(elem) {
                                return updateSinkVisibility(elem, false);
                            });
                        },
                        onHidden() {
                            runOnSinkElement(function(elem) {
                                return remove$5(elem, [
                                    visibility.transitionClass,
                                ]);
                            });
                        },
                        ...visibility,
                    },
                    modes: ['top'],
                    onDocked: onDockingSwitch,
                    onUndocked: onDockingSwitch,
                }),
            ],
            additionalBehaviours,
        );
    };

    const StickyHeader = /* #__PURE__ */ Object.freeze({
        setup: setup$5,
        isDocked: isDocked$1,
        getBehaviours: getBehaviours$2,
    });

    const setup$6 = noop;
    const isDocked$2 = never;
    const getBehaviours$3 = constant([]);

    const StaticHeader = /* #__PURE__ */ Object.freeze({
        setup: setup$6,
        isDocked: isDocked$2,
        getBehaviours: getBehaviours$3,
    });

    const renderHeader = function(spec) {
        const { editor } = spec;
        const getBehaviours = spec.sticky ? getBehaviours$2 : getBehaviours$3;
        return {
            uid: spec.uid,
            dom: spec.dom,
            components: spec.components,
            behaviours: derive$1(getBehaviours(editor, spec.getSink)),
        };
    };

    const factory$f = function(detail, spec) {
        const setMenus = function(comp, menus) {
            const newMenus = map(menus, function(m) {
                const buttonSpec = {
                    type: 'menubutton',
                    text: m.text,
                    fetch(callback) {
                        callback(m.getItems());
                    },
                };
                const internal = createMenuButton(buttonSpec)
                    .mapError(function(errInfo) {
                        return formatError(errInfo);
                    })
                    .getOrDie();
                return renderMenuButton(
                    internal,
                    'tox-mbtn',
                    spec.backstage,
                    Option.some('menuitem'),
                );
            });
            Replacing.set(comp, newMenus);
        };
        const apis = {
            focus: Keying.focusIn,
            setMenus,
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components: [],
            behaviours: derive$1([
                Replacing.config({}),
                config('menubar-events', [
                    runOnAttached(function(component) {
                        detail.onSetup(component);
                    }),
                    run(mouseover(), function(comp, se) {
                        descendant$1(
                            comp.element(),
                            '.' + 'tox-mbtn--active',
                        ).each(function(activeButton) {
                            closest$3(
                                se.event().target(),
                                '.' + 'tox-mbtn',
                            ).each(function(hoveredButton) {
                                if (!eq(activeButton, hoveredButton)) {
                                    comp.getSystem()
                                        .getByDom(activeButton)
                                        .each(function(activeComp) {
                                            comp.getSystem()
                                                .getByDom(hoveredButton)
                                                .each(function(hoveredComp) {
                                                    Dropdown.expand(
                                                        hoveredComp,
                                                    );
                                                    Dropdown.close(activeComp);
                                                    Focusing.focus(hoveredComp);
                                                });
                                        });
                                }
                            });
                        });
                    }),
                    run(focusShifted(), function(comp, se) {
                        se.event()
                            .prevFocus()
                            .bind(function(prev) {
                                return comp
                                    .getSystem()
                                    .getByDom(prev)
                                    .toOption();
                            })
                            .each(function(prev) {
                                se.event()
                                    .newFocus()
                                    .bind(function(nu) {
                                        return comp
                                            .getSystem()
                                            .getByDom(nu)
                                            .toOption();
                                    })
                                    .each(function(nu) {
                                        if (Dropdown.isOpen(prev)) {
                                            Dropdown.expand(nu);
                                            Dropdown.close(prev);
                                        }
                                    });
                            });
                    }),
                ]),
                Keying.config({
                    mode: 'flow',
                    selector: '.' + 'tox-mbtn',
                    onEscape(comp) {
                        detail.onEscape(comp);
                        return Option.some(true);
                    },
                }),
                Tabstopping.config({}),
            ]),
            apis,
            domModification: { attributes: { role: 'menubar' } },
        };
    };
    const SilverMenubar = single$2({
        factory: factory$f,
        name: 'silver.Menubar',
        configFields: [
            strict$1('dom'),
            strict$1('uid'),
            strict$1('onEscape'),
            strict$1('backstage'),
            defaulted$1('onSetup', noop),
        ],
        apis: {
            focus(apis, comp) {
                apis.focus(comp);
            },
            setMenus(apis, comp, menus) {
                apis.setMenus(comp, menus);
            },
        },
    });

    const owner$4 = 'container';
    const schema$r = [field$1('slotBehaviours', [])];
    const getPartName$1 = function(name) {
        return `<alloy.field.${name}>`;
    };
    const sketch$2 = function(sSpec) {
        const parts = (function() {
            const record = [];
            const slot = function(name, config) {
                record.push(name);
                return generateOne(owner$4, getPartName$1(name), config);
            };
            return {
                slot,
                record() {
                    return record;
                },
            };
        })();
        const spec = sSpec(parts);
        const partNames = parts.record();
        const fieldParts = map(partNames, function(n) {
            return required({
                name: n,
                pname: getPartName$1(n),
            });
        });
        return composite(owner$4, schema$r, fieldParts, make$7, spec);
    };
    var make$7 = function(detail, components, spec) {
        const getSlotNames = function(_) {
            return getAllPartNames(detail);
        };
        const getSlot = function(container, key) {
            return getPart(container, detail, key);
        };
        const onSlot = function(f, def) {
            if (def === void 0) {
                def = undefined;
            }
            return function(container, key) {
                return getPart(container, detail, key)
                    .map(function(slot) {
                        return f(slot, key);
                    })
                    .getOr(def);
            };
        };
        const onSlots = function(f) {
            return function(container, keys) {
                each(keys, function(key) {
                    return f(container, key);
                });
            };
        };
        const doShowing = function(comp, key) {
            return get$2(comp.element(), 'aria-hidden') !== 'true';
        };
        const doShow = function(comp, key) {
            if (!doShowing(comp)) {
                const element = comp.element();
                remove$6(element, 'display');
                remove$1(element, 'aria-hidden');
                emitWith(comp, slotVisibility(), {
                    name: key,
                    visible: true,
                });
            }
        };
        const doHide = function(comp, key) {
            if (doShowing(comp)) {
                const element = comp.element();
                set$2(element, 'display', 'none');
                set$1(element, 'aria-hidden', 'true');
                emitWith(comp, slotVisibility(), {
                    name: key,
                    visible: false,
                });
            }
        };
        const isShowing = onSlot(doShowing, false);
        const hideSlot = onSlot(doHide);
        const hideSlots = onSlots(hideSlot);
        const hideAllSlots = function(container) {
            return hideSlots(container, getSlotNames());
        };
        const showSlot = onSlot(doShow);
        const apis = {
            getSlotNames,
            getSlot,
            isShowing,
            hideSlot,
            hideAllSlots,
            showSlot,
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: get$b(detail.slotBehaviours),
            apis,
        };
    };
    const slotApis = map$1(
        {
            getSlotNames(apis, c) {
                return apis.getSlotNames(c);
            },
            getSlot(apis, c, key) {
                return apis.getSlot(c, key);
            },
            isShowing(apis, c, key) {
                return apis.isShowing(c, key);
            },
            hideSlot(apis, c, key) {
                return apis.hideSlot(c, key);
            },
            hideAllSlots(apis, c) {
                return apis.hideAllSlots(c);
            },
            showSlot(apis, c, key) {
                return apis.showSlot(c, key);
            },
        },
        makeApi,
    );
    const SlotContainer = { ...slotApis, sketch: sketch$2 };

    const sidebarSchema = objOf([
        optionString('icon'),
        optionString('tooltip'),
        defaultedFunction('onShow', noop),
        defaultedFunction('onHide', noop),
        defaultedFunction('onSetup', function() {
            return noop;
        }),
    ]);
    const createSidebar = function(spec) {
        return asRaw('sidebar', sidebarSchema, spec);
    };

    const setup$7 = function(editor) {
        const { sidebars } = editor.ui.registry.getAll();
        each(keys(sidebars), function(name) {
            const spec = sidebars[name];
            const isActive = function() {
                return Option.from(
                    editor.queryCommandValue('ToggleSidebar'),
                ).is(name);
            };
            editor.ui.registry.addToggleButton(name, {
                icon: spec.icon,
                tooltip: spec.tooltip,
                onAction(buttonApi) {
                    editor.execCommand('ToggleSidebar', false, name);
                    buttonApi.setActive(isActive());
                },
                onSetup(buttonApi) {
                    const handleToggle = function() {
                        return buttonApi.setActive(isActive());
                    };
                    editor.on('ToggleSidebar', handleToggle);
                    return function() {
                        editor.off('ToggleSidebar', handleToggle);
                    };
                },
            });
        });
    };
    const getApi = function(comp) {
        return {
            element() {
                return comp.element().dom();
            },
        };
    };
    const makePanels = function(parts, panelConfigs) {
        const specs = map(keys(panelConfigs), function(name) {
            const spec = panelConfigs[name];
            const bridged = getOrDie(createSidebar(spec));
            return {
                name,
                getApi,
                onSetup: bridged.onSetup,
                onShow: bridged.onShow,
                onHide: bridged.onHide,
            };
        });
        return map(specs, function(spec) {
            const editorOffCell = Cell(noop);
            return parts.slot(spec.name, {
                dom: {
                    tag: 'div',
                    classes: ['tox-sidebar__pane'],
                },
                behaviours: SimpleBehaviours.unnamedEvents([
                    onControlAttached(spec, editorOffCell),
                    onControlDetached(spec, editorOffCell),
                    run(slotVisibility(), function(sidepanel, se) {
                        const data = se.event();
                        const optSidePanelSpec = find(specs, function(config) {
                            return config.name === data.name();
                        });
                        optSidePanelSpec.each(function(sidePanelSpec) {
                            const handler = data.visible()
                                ? sidePanelSpec.onShow
                                : sidePanelSpec.onHide;
                            handler(sidePanelSpec.getApi(sidepanel));
                        });
                    }),
                ]),
            });
        });
    };
    const makeSidebar = function(panelConfigs) {
        return SlotContainer.sketch(function(parts) {
            return {
                dom: {
                    tag: 'div',
                    classes: ['tox-sidebar__pane-container'],
                },
                components: makePanels(parts, panelConfigs),
                slotBehaviours: SimpleBehaviours.unnamedEvents([
                    runOnAttached(function(slotContainer) {
                        return SlotContainer.hideAllSlots(slotContainer);
                    }),
                ]),
            };
        });
    };
    const setSidebar = function(sidebar, panelConfigs) {
        const optSlider = Composing.getCurrent(sidebar);
        optSlider.each(function(slider) {
            return Replacing.set(slider, [makeSidebar(panelConfigs)]);
        });
    };
    const toggleSidebar = function(sidebar, name) {
        const optSlider = Composing.getCurrent(sidebar);
        optSlider.each(function(slider) {
            const optSlotContainer = Composing.getCurrent(slider);
            optSlotContainer.each(function(slotContainer) {
                if (Sliding.hasGrown(slider)) {
                    if (SlotContainer.isShowing(slotContainer, name)) {
                        Sliding.shrink(slider);
                    } else {
                        SlotContainer.hideAllSlots(slotContainer);
                        SlotContainer.showSlot(slotContainer, name);
                    }
                } else {
                    SlotContainer.hideAllSlots(slotContainer);
                    SlotContainer.showSlot(slotContainer, name);
                    Sliding.grow(slider);
                }
            });
        });
    };
    const whichSidebar = function(sidebar) {
        const optSlider = Composing.getCurrent(sidebar);
        return optSlider.bind(function(slider) {
            const sidebarOpen =
                Sliding.isGrowing(slider) || Sliding.hasGrown(slider);
            if (sidebarOpen) {
                const optSlotContainer = Composing.getCurrent(slider);
                return optSlotContainer.bind(function(slotContainer) {
                    return find(
                        SlotContainer.getSlotNames(slotContainer),
                        function(name) {
                            return SlotContainer.isShowing(slotContainer, name);
                        },
                    );
                });
            }
            return Option.none();
        });
    };
    const fixSize = generate$1('FixSizeEvent');
    const autoSize = generate$1('AutoSizeEvent');
    const renderSidebar = function(spec) {
        return {
            uid: spec.uid,
            dom: {
                tag: 'div',
                classes: ['tox-sidebar'],
                attributes: { role: 'complementary' },
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-sidebar__slider'],
                    },
                    components: [],
                    behaviours: derive$1([
                        Tabstopping.config({}),
                        Focusing.config({}),
                        Sliding.config({
                            dimension: { property: 'width' },
                            closedClass: 'tox-sidebar--sliding-closed',
                            openClass: 'tox-sidebar--sliding-open',
                            shrinkingClass: 'tox-sidebar--sliding-shrinking',
                            growingClass: 'tox-sidebar--sliding-growing',
                            onShrunk(slider) {
                                const optSlotContainer = Composing.getCurrent(
                                    slider,
                                );
                                optSlotContainer.each(
                                    SlotContainer.hideAllSlots,
                                );
                                emit(slider, autoSize);
                            },
                            onGrown(slider) {
                                emit(slider, autoSize);
                            },
                            onStartGrow(slider) {
                                emitWith(slider, fixSize, {
                                    width: getRaw(
                                        slider.element(),
                                        'width',
                                    ).getOr(''),
                                });
                            },
                            onStartShrink(slider) {
                                emitWith(slider, fixSize, {
                                    width: `${get$7(slider.element())}px`,
                                });
                            },
                        }),
                        Replacing.config({}),
                        Composing.config({
                            find(comp) {
                                const children = Replacing.contents(comp);
                                return head(children);
                            },
                        }),
                    ]),
                },
            ],
            behaviours: derive$1([
                ComposingConfigs.childAt(0),
                config('sidebar-sliding-events', [
                    run(fixSize, function(comp, se) {
                        set$2(comp.element(), 'width', se.event().width());
                    }),
                    run(autoSize, function(comp, se) {
                        remove$6(comp.element(), 'width');
                    }),
                ]),
            ]),
        };
    };

    const renderSpinner = function(providerBackstage) {
        return {
            dom: {
                tag: 'div',
                attributes: {
                    'aria-label': providerBackstage.translate('Loading...'),
                },
                classes: ['tox-throbber__busy-spinner'],
            },
            components: [
                {
                    dom: fromHtml$2(
                        '<div class="tox-spinner"><div></div><div></div><div></div></div>',
                    ),
                },
            ],
            behaviours: derive$1([
                Keying.config({
                    mode: 'special',
                    onTab() {
                        return Option.some(true);
                    },
                    onShiftTab() {
                        return Option.some(true);
                    },
                }),
                Focusing.config({}),
            ]),
        };
    };
    const toggleThrobber = function(comp, state, providerBackstage) {
        const element = comp.element();
        if (state === true) {
            Replacing.set(comp, [renderSpinner(providerBackstage)]);
            remove$6(element, 'display');
            remove$1(element, 'aria-hidden');
        } else {
            Replacing.set(comp, []);
            set$2(element, 'display', 'none');
            set$1(element, 'aria-hidden', 'true');
        }
    };
    const renderThrobber = function(spec) {
        return {
            uid: spec.uid,
            dom: {
                tag: 'div',
                attributes: { 'aria-hidden': 'true' },
                classes: ['tox-throbber'],
                styles: { display: 'none' },
            },
            behaviours: derive$1([Replacing.config({})]),
            components: [],
        };
    };
    const setup$8 = function(editor, lazyThrobber, sharedBackstage) {
        const throbberState = Cell(false);
        const timer = Cell(Option.none());
        const toggle = function(state) {
            if (state !== throbberState.get()) {
                toggleThrobber(
                    lazyThrobber(),
                    state,
                    sharedBackstage.providers,
                );
                throbberState.set(state);
            }
        };
        editor.on('ProgressState', function(e) {
            timer.get().each(global$2.clearTimeout);
            if (isNumber(e.time)) {
                const timerId = global$2.setEditorTimeout(
                    editor,
                    function() {
                        return toggle(e.state);
                    },
                    e.time,
                );
                timer.set(Option.some(timerId));
            } else {
                toggle(e.state);
                timer.set(Option.none());
            }
        });
    };

    const factory$g = function(detail, components, spec) {
        const apis = {
            getSocket(comp) {
                return parts$c.getPart(comp, detail, 'socket');
            },
            setSidebar(comp, panelConfigs) {
                parts$c
                    .getPart(comp, detail, 'sidebar')
                    .each(function(sidebar) {
                        return setSidebar(sidebar, panelConfigs);
                    });
            },
            toggleSidebar(comp, name) {
                parts$c
                    .getPart(comp, detail, 'sidebar')
                    .each(function(sidebar) {
                        return toggleSidebar(sidebar, name);
                    });
            },
            whichSidebar(comp) {
                return parts$c
                    .getPart(comp, detail, 'sidebar')
                    .bind(whichSidebar)
                    .getOrNull();
            },
            getHeader(comp) {
                return parts$c.getPart(comp, detail, 'header');
            },
            getToolbar(comp) {
                return parts$c.getPart(comp, detail, 'toolbar');
            },
            setToolbar(comp, groups) {
                parts$c
                    .getPart(comp, detail, 'toolbar')
                    .each(function(toolbar) {
                        toolbar.getApis().setGroups(toolbar, groups);
                    });
            },
            setToolbars(comp, toolbars) {
                parts$c
                    .getPart(comp, detail, 'multiple-toolbar')
                    .each(function(mToolbar) {
                        CustomList.setItems(mToolbar, toolbars);
                    });
            },
            refreshToolbar(comp) {
                const toolbar = parts$c.getPart(comp, detail, 'toolbar');
                toolbar.each(function(toolbar) {
                    return toolbar.getApis().refresh(toolbar);
                });
            },
            getMoreButton(comp) {
                const toolbar = parts$c.getPart(comp, detail, 'toolbar');
                return toolbar.bind(function(toolbar) {
                    return toolbar.getApis().getMoreButton(toolbar);
                });
            },
            getThrobber(comp) {
                return parts$c.getPart(comp, detail, 'throbber');
            },
            focusToolbar(comp) {
                const optToolbar = parts$c
                    .getPart(comp, detail, 'toolbar')
                    .orThunk(function() {
                        return parts$c.getPart(
                            comp,
                            detail,
                            'multiple-toolbar',
                        );
                    });
                optToolbar.each(function(toolbar) {
                    Keying.focusIn(toolbar);
                });
            },
            setMenubar(comp, menus) {
                parts$c
                    .getPart(comp, detail, 'menubar')
                    .each(function(menubar) {
                        SilverMenubar.setMenus(menubar, menus);
                    });
            },
            focusMenubar(comp) {
                parts$c
                    .getPart(comp, detail, 'menubar')
                    .each(function(menubar) {
                        SilverMenubar.focus(menubar);
                    });
            },
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            apis,
            behaviours: detail.behaviours,
        };
    };
    const partMenubar = partType$1.optional({
        factory: SilverMenubar,
        name: 'menubar',
        schema: [strict$1('backstage')],
    });
    const toolbarFactory = function(spec) {
        if (spec.split === ToolbarDrawer.sliding) {
            return renderSlidingMoreToolbar;
        }
        if (spec.split === ToolbarDrawer.floating) {
            return renderFloatingMoreToolbar;
        }
        return renderToolbar;
    };
    const partMultipleToolbar = partType$1.optional({
        factory: {
            sketch(spec) {
                return CustomList.sketch({
                    uid: spec.uid,
                    dom: spec.dom,
                    listBehaviours: derive$1([
                        Keying.config({
                            mode: 'acyclic',
                            selector: '.tox-toolbar',
                        }),
                    ]),
                    makeItem() {
                        return renderToolbar({
                            type: spec.split,
                            uid: generate$1('multiple-toolbar-item'),
                            backstage: spec.backstage,
                            cyclicKeying: false,
                            getSink: spec.getSink,
                            initGroups: [],
                            onEscape() {
                                return Option.none();
                            },
                        });
                    },
                    setupItem(mToolbar, tc, data, index) {
                        Toolbar.setGroups(tc, data);
                    },
                    shell: true,
                });
            },
        },
        name: 'multiple-toolbar',
        schema: [strict$1('dom'), strict$1('onEscape')],
    });
    const partToolbar = partType$1.optional({
        factory: {
            sketch(spec) {
                const renderer = toolbarFactory(spec);
                const toolbarSpec = {
                    type: spec.split,
                    uid: spec.uid,
                    onEscape() {
                        spec.onEscape();
                        return Option.some(true);
                    },
                    cyclicKeying: false,
                    initGroups: [],
                    getSink: spec.getSink,
                    backstage: spec.backstage,
                    moreDrawerData: {
                        lazyToolbar: spec.lazyToolbar,
                        lazyMoreButton: spec.lazyMoreButton,
                        lazyHeader: spec.lazyHeader,
                    },
                };
                return renderer(toolbarSpec);
            },
        },
        name: 'toolbar',
        schema: [strict$1('dom'), strict$1('onEscape'), strict$1('getSink')],
    });
    const partHeader = partType$1.optional({
        factory: { sketch: renderHeader },
        name: 'header',
        schema: [strict$1('dom')],
    });
    const partSocket = partType$1.optional({
        name: 'socket',
        schema: [strict$1('dom')],
    });
    const partSidebar = partType$1.optional({
        factory: { sketch: renderSidebar },
        name: 'sidebar',
        schema: [strict$1('dom')],
    });
    const partThrobber = partType$1.optional({
        factory: { sketch: renderThrobber },
        name: 'throbber',
        schema: [strict$1('dom')],
    });
    const OuterContainer = composite$1({
        name: 'OuterContainer',
        factory: factory$g,
        configFields: [strict$1('dom'), strict$1('behaviours')],
        partFields: [
            partHeader,
            partMenubar,
            partToolbar,
            partMultipleToolbar,
            partSocket,
            partSidebar,
            partThrobber,
        ],
        apis: {
            getSocket(apis, comp) {
                return apis.getSocket(comp);
            },
            setSidebar(apis, comp, panelConfigs) {
                apis.setSidebar(comp, panelConfigs);
            },
            toggleSidebar(apis, comp, name) {
                apis.toggleSidebar(comp, name);
            },
            whichSidebar(apis, comp) {
                return apis.whichSidebar(comp);
            },
            getHeader(apis, comp) {
                return apis.getHeader(comp);
            },
            getToolbar(apis, comp) {
                return apis.getToolbar(comp);
            },
            setToolbar(apis, comp, grps) {
                const groups = map(grps, function(grp) {
                    return renderToolbarGroup(grp);
                });
                apis.setToolbar(comp, groups);
            },
            setToolbars(apis, comp, ts) {
                const renderedToolbars = map(ts, function(g) {
                    return map(g, renderToolbarGroup);
                });
                apis.setToolbars(comp, renderedToolbars);
            },
            getMoreButton(apis, comp) {
                return apis.getMoreButton(comp);
            },
            refreshToolbar(apis, comp) {
                return apis.refreshToolbar(comp);
            },
            getThrobber(apis, comp) {
                return apis.getThrobber(comp);
            },
            setMenubar(apis, comp, menus) {
                apis.setMenubar(comp, menus);
            },
            focusMenubar(apis, comp) {
                apis.focusMenubar(comp);
            },
            focusToolbar(apis, comp) {
                apis.focusToolbar(comp);
            },
        },
    });

    const defaultMenubar = 'file edit view insert format tools table help';
    const defaultMenus = {
        file: {
            title: 'File',
            items:
                'newdocument restoredraft | preview | print | deleteallconversations',
        },
        edit: {
            title: 'Edit',
            items:
                'undo redo | cut copy paste pastetext | selectall | searchreplace',
        },
        view: {
            title: 'View',
            items:
                'code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments',
        },
        insert: {
            title: 'Insert',
            items:
                'image link media addcomment pageembed template codesample inserttable | charmap emoticons hr | pagebreak nonbreaking anchor toc | insertdatetime',
        },
        format: {
            title: 'Format',
            items:
                'bold italic underline strikethrough superscript subscript codeformat | formats blockformats fontformats fontsizes align | forecolor backcolor | removeformat',
        },
        tools: {
            title: 'Tools',
            items:
                'spellchecker spellcheckerlanguage | a11ycheck code wordcount',
        },
        table: {
            title: 'Table',
            items:
                'inserttable | cell row column | advtablesort | tableprops deletetable',
        },
        help: {
            title: 'Help',
            items: 'help',
        },
    };
    const make$8 = function(menu, registry, editor) {
        const removedMenuItems = getRemovedMenuItems(editor).split(/[ ,]/);
        return {
            text: menu.title,
            getItems() {
                return bind(menu.items, function(i) {
                    const itemName = i.toLowerCase();
                    if (itemName.trim().length === 0) {
                        return [];
                    }
                    if (
                        exists(removedMenuItems, function(removedMenuItem) {
                            return removedMenuItem === itemName;
                        })
                    ) {
                        return [];
                    }
                    if (itemName === 'separator' || itemName === '|') {
                        return [{ type: 'separator' }];
                    }
                    if (registry.menuItems[itemName]) {
                        return [registry.menuItems[itemName]];
                    }
                    return [];
                });
            },
        };
    };
    const parseItemsString = function(items) {
        if (typeof items === 'string') {
            return items.split(' ');
        }
        return items;
    };
    const identifyMenus = function(editor, registry) {
        const rawMenuData = merge(defaultMenus, registry.menus);
        const userDefinedMenus = keys(registry.menus).length > 0;
        const menubar =
            registry.menubar === undefined || registry.menubar === true
                ? parseItemsString(defaultMenubar)
                : parseItemsString(
                      registry.menubar === false ? '' : registry.menubar,
                  );
        const validMenus = filter(menubar, function(menuName) {
            return userDefinedMenus
                ? (registry.menus.hasOwnProperty(menuName) &&
                      registry.menus[menuName].hasOwnProperty('items')) ||
                      defaultMenus.hasOwnProperty(menuName)
                : defaultMenus.hasOwnProperty(menuName);
        });
        const menus = map(validMenus, function(menuName) {
            const menuData = rawMenuData[menuName];
            return make$8(
                {
                    title: menuData.title,
                    items: parseItemsString(menuData.items),
                },
                registry,
                editor,
            );
        });
        return filter(menus, function(menu) {
            const isNotSeparator = function(item) {
                return item.type !== 'separator';
            };
            return (
                menu.getItems().length > 0 &&
                exists(menu.getItems(), isNotSeparator)
            );
        });
    };

    const fireSkinLoaded$1 = function(editor) {
        const done = function() {
            editor._skinLoaded = true;
            Events.fireSkinLoaded(editor);
        };
        return function() {
            if (editor.initialized) {
                done();
            } else {
                editor.on('init', done);
            }
        };
    };
    const SkinLoaded = { fireSkinLoaded: fireSkinLoaded$1 };

    const loadSkin = function(isInline, editor) {
        const skinUrl = getSkinUrl(editor);
        let skinUiCss;
        if (skinUrl) {
            skinUiCss = `${skinUrl}/skin.min.css`;
            editor.contentCSS.push(
                `${skinUrl +
                    (isInline ? '/content.inline' : '/content')}.min.css`,
            );
        }
        if (isSkinDisabled(editor) === false && skinUiCss) {
            global$7.DOM.styleSheetLoader.load(
                skinUiCss,
                SkinLoaded.fireSkinLoaded(editor),
            );
        } else {
            SkinLoaded.fireSkinLoaded(editor)();
        }
    };
    const iframe = curry(loadSkin, false);
    const inline = curry(loadSkin, true);

    const setToolbar = function(editor, uiComponents, rawUiConfig, backstage) {
        const comp = uiComponents.outerContainer;
        const toolbarConfig = rawUiConfig.toolbar;
        const toolbarButtonsConfig = rawUiConfig.buttons;
        if (isArrayOf(toolbarConfig, isString)) {
            const toolbars = toolbarConfig.map(function(t) {
                const config = {
                    toolbar: t,
                    buttons: toolbarButtonsConfig,
                };
                return identifyButtons(
                    editor,
                    config,
                    { backstage },
                    Option.none(),
                );
            });
            OuterContainer.setToolbars(comp, toolbars);
        } else {
            OuterContainer.setToolbar(
                comp,
                identifyButtons(
                    editor,
                    rawUiConfig,
                    { backstage },
                    Option.none(),
                ),
            );
        }
    };

    const { DOM } = global$7;
    const detection = detect$3();
    const isiOS12 = detection.os.isiOS() && detection.os.version.major <= 12;
    const setupEvents = function(editor) {
        const contentWindow = editor.getWin();
        const initialDocEle = editor.getDoc().documentElement;
        const lastWindowDimensions = Cell(
            Position(contentWindow.innerWidth, contentWindow.innerHeight),
        );
        const lastDocumentDimensions = Cell(
            Position(initialDocEle.offsetWidth, initialDocEle.offsetHeight),
        );
        const resize = function(e) {
            const docEle = editor.getDoc().documentElement;
            const outer = lastWindowDimensions.get();
            const inner = lastDocumentDimensions.get();
            if (
                outer.left() !== contentWindow.innerWidth ||
                outer.top() !== contentWindow.innerHeight
            ) {
                lastWindowDimensions.set(
                    Position(
                        contentWindow.innerWidth,
                        contentWindow.innerHeight,
                    ),
                );
                Events.fireResizeContent(editor, e);
            } else if (
                inner.left() !== docEle.offsetWidth ||
                inner.top() !== docEle.offsetHeight
            ) {
                lastDocumentDimensions.set(
                    Position(docEle.offsetWidth, docEle.offsetHeight),
                );
                Events.fireResizeContent(editor, e);
            }
        };
        const scroll = function(e) {
            return Events.fireScrollContent(editor, e);
        };
        DOM.bind(contentWindow, 'resize', resize);
        DOM.bind(contentWindow, 'scroll', scroll);
        const elementLoad = capture$1(
            Element.fromDom(editor.getBody()),
            'load',
            resize,
        );
        editor.on('remove', function() {
            elementLoad.unbind();
            DOM.unbind(contentWindow, 'resize', resize);
            DOM.unbind(contentWindow, 'scroll', scroll);
        });
    };
    const render = function(
        editor,
        uiComponents,
        rawUiConfig,
        backstage,
        args,
    ) {
        const lastToolbarWidth = Cell(0);
        iframe(editor);
        attachSystemAfter(
            Element.fromDom(args.targetNode),
            uiComponents.mothership,
        );
        attachSystem(body(), uiComponents.uiMothership);
        editor.on('PostRender', function() {
            setToolbar(editor, uiComponents, rawUiConfig, backstage);
            lastToolbarWidth.set(editor.getWin().innerWidth);
            OuterContainer.setMenubar(
                uiComponents.outerContainer,
                identifyMenus(editor, rawUiConfig),
            );
            OuterContainer.setSidebar(
                uiComponents.outerContainer,
                rawUiConfig.sidebar,
            );
            setupEvents(editor);
        });
        const socket = OuterContainer.getSocket(
            uiComponents.outerContainer,
        ).getOrDie('Could not find expected socket element');
        if (isiOS12 === true) {
            setAll$1(socket.element(), {
                overflow: 'scroll',
                '-webkit-overflow-scrolling': 'touch',
            });
            const limit = first$1(function() {
                editor.fire('ScrollContent');
            }, 20);
            bind$3(socket.element(), 'scroll', limit.throttle);
        }
        setupReadonlyModeSwitch(editor, uiComponents);
        editor.addCommand('ToggleSidebar', function(ui, value) {
            OuterContainer.toggleSidebar(uiComponents.outerContainer, value);
            editor.fire('ToggleSidebar');
        });
        editor.addQueryValueHandler('ToggleSidebar', function() {
            return OuterContainer.whichSidebar(uiComponents.outerContainer);
        });
        const drawer = getToolbarDrawer(editor);
        const refreshDrawer = function() {
            OuterContainer.refreshToolbar(uiComponents.outerContainer);
        };
        if (
            drawer === ToolbarDrawer.sliding ||
            drawer === ToolbarDrawer.floating
        ) {
            editor.on('ResizeWindow ResizeEditor ResizeContent', function() {
                const width = editor.getWin().innerWidth;
                if (width !== lastToolbarWidth.get()) {
                    refreshDrawer();
                    lastToolbarWidth.set(width);
                }
            });
        }
        return {
            iframeContainer: socket.element().dom(),
            editorContainer: uiComponents.outerContainer.element().dom(),
        };
    };
    const Iframe = { render };

    const parseToInt = function(val) {
        const re = /^[0-9\.]+(|px)$/i;
        if (re.test(`${val}`)) {
            return Option.some(parseInt(`${val}`, 10));
        }
        return Option.none();
    };
    const numToPx = function(val) {
        return isNumber(val) ? `${val}px` : val;
    };
    const calcCappedSize = function(size, minSize, maxSize) {
        const minOverride = minSize.filter(function(min) {
            return size < min;
        });
        const maxOverride = maxSize.filter(function(max) {
            return size > max;
        });
        return minOverride.or(maxOverride).getOr(size);
    };
    const Utils = {
        calcCappedSize,
        parseToInt,
        numToPx,
    };

    const getHeight$1 = function(editor) {
        const baseHeight = getHeightSetting(editor);
        const minHeight = getMinHeightSetting(editor);
        const maxHeight = getMaxHeightSetting(editor);
        return Utils.parseToInt(baseHeight).map(function(height) {
            return Utils.calcCappedSize(height, minHeight, maxHeight);
        });
    };
    const getHeightWithFallback = function(editor) {
        const height = getHeight$1(editor);
        return height.getOr(getHeightSetting(editor));
    };
    const getWidth$1 = function(editor) {
        const baseWidth = getWidthSetting(editor);
        const minWidth = getMinWidthSetting(editor);
        const maxWidth = getMaxWidthSetting(editor);
        return Utils.parseToInt(baseWidth).map(function(width) {
            return Utils.calcCappedSize(width, minWidth, maxWidth);
        });
    };
    const getWidthWithFallback = function(editor) {
        const width = getWidth$1(editor);
        return width.getOr(getWidthSetting(editor));
    };

    const render$1 = function(
        editor,
        uiComponents,
        rawUiConfig,
        backstage,
        args,
    ) {
        let floatContainer;
        const { DOM } = global$7;
        const useFixedToolbarContainer = useFixedContainer(editor);
        const isSticky = isStickyToolbar(editor);
        const targetElm = Element.fromDom(args.targetNode);
        const editorMaxWidthOpt = getMaxWidthSetting(editor).or(
            getWidth$1(editor),
        );
        const splitSetting = getToolbarDrawer(editor);
        const split =
            splitSetting === ToolbarDrawer.sliding ||
            splitSetting === ToolbarDrawer.floating;
        inline(editor);
        const updateChromePosition = function(toolbar) {
            const offset = split
                ? toolbar.fold(
                      function() {
                          return 0;
                      },
                      function(tbar) {
                          return tbar.components().length > 1
                              ? get$6(tbar.components()[1].element())
                              : 0;
                      },
                  )
                : 0;
            const location = absolute(targetElm);
            const top =
                location.top() - get$6(floatContainer.element()) + offset;
            setAll$1(uiComponents.outerContainer.element(), {
                position: 'absolute',
                top: `${Math.round(top)}px`,
                left: `${Math.round(location.left())}px`,
            });
            const maxWidth = editorMaxWidthOpt.getOrThunk(function() {
                const bodyMargin = Utils.parseToInt(
                    get$4(body(), 'margin-left'),
                ).getOr(0);
                return get$7(body()) - location.left() + bodyMargin;
            });
            set$2(floatContainer.element(), 'max-width', `${maxWidth}px`);
        };
        const updateChromeUi = function(resetDocking) {
            if (resetDocking === void 0) {
                resetDocking = false;
            }
            if (split) {
                OuterContainer.refreshToolbar(uiComponents.outerContainer);
            }
            if (!useFixedToolbarContainer) {
                const toolbar = OuterContainer.getToolbar(
                    uiComponents.outerContainer,
                );
                updateChromePosition(toolbar);
            }
            if (isSticky) {
                resetDocking
                    ? Docking.reset(floatContainer)
                    : Docking.refresh(floatContainer);
            }
        };
        const show = function() {
            set$2(uiComponents.outerContainer.element(), 'display', 'flex');
            DOM.addClass(editor.getBody(), 'mce-edit-focus');
            remove$6(uiComponents.uiMothership.element(), 'display');
            updateChromeUi();
        };
        const hide = function() {
            if (uiComponents.outerContainer) {
                set$2(uiComponents.outerContainer.element(), 'display', 'none');
                DOM.removeClass(editor.getBody(), 'mce-edit-focus');
            }
            set$2(uiComponents.uiMothership.element(), 'display', 'none');
        };
        const render = function() {
            if (floatContainer) {
                show();
                return;
            }
            floatContainer = OuterContainer.getHeader(
                uiComponents.outerContainer,
            ).getOrDie();
            const uiContainer = getUiContainer(editor);
            attachSystem(uiContainer, uiComponents.mothership);
            attachSystem(uiContainer, uiComponents.uiMothership);
            setToolbar(editor, uiComponents, rawUiConfig, backstage);
            OuterContainer.setMenubar(
                uiComponents.outerContainer,
                identifyMenus(editor, rawUiConfig),
            );
            show();
            editor.on('activate', show);
            editor.on('deactivate', hide);
            editor.on('NodeChange SkinLoaded ResizeWindow', function() {
                if (!editor.hidden) {
                    updateChromeUi(true);
                }
            });
            editor.nodeChanged();
        };
        editor.on('focus', render);
        editor.on('blur hide', hide);
        editor.on('init', function() {
            if (editor.hasFocus()) {
                render();
            }
        });
        setupReadonlyModeSwitch(editor, uiComponents);
        return { editorContainer: uiComponents.outerContainer.element().dom() };
    };
    const Inline = { render: render$1 };

    const register$5 = function(editor) {
        const alignToolbarButtons = [
            {
                name: 'alignleft',
                text: 'Align left',
                cmd: 'JustifyLeft',
                icon: 'align-left',
            },
            {
                name: 'aligncenter',
                text: 'Align center',
                cmd: 'JustifyCenter',
                icon: 'align-center',
            },
            {
                name: 'alignright',
                text: 'Align right',
                cmd: 'JustifyRight',
                icon: 'align-right',
            },
            {
                name: 'alignjustify',
                text: 'Justify',
                cmd: 'JustifyFull',
                icon: 'align-justify',
            },
        ];
        global$e.each(alignToolbarButtons, function(item) {
            editor.ui.registry.addToggleButton(item.name, {
                tooltip: item.text,
                onAction() {
                    return editor.execCommand(item.cmd);
                },
                icon: item.icon,
                onSetup: onSetupFormatToggle(editor, item.name),
            });
        });
        const alignNoneToolbarButton = {
            name: 'alignnone',
            text: 'No alignment',
            cmd: 'JustifyNone',
            icon: 'align-none',
        };
        editor.ui.registry.addButton(alignNoneToolbarButton.name, {
            tooltip: alignNoneToolbarButton.text,
            onAction() {
                return editor.execCommand(alignNoneToolbarButton.cmd);
            },
            icon: alignNoneToolbarButton.icon,
        });
    };
    const AlignmentButtons = { register: register$5 };

    const toggleFormat = function(editor, fmt) {
        return function() {
            editor.execCommand('mceToggleFormat', false, fmt);
        };
    };
    const registerFormatButtons = function(editor) {
        global$e.each(
            [
                {
                    name: 'bold',
                    text: 'Bold',
                    icon: 'bold',
                },
                {
                    name: 'italic',
                    text: 'Italic',
                    icon: 'italic',
                },
                {
                    name: 'underline',
                    text: 'Underline',
                    icon: 'underline',
                },
                {
                    name: 'strikethrough',
                    text: 'Strikethrough',
                    icon: 'strike-through',
                },
                {
                    name: 'subscript',
                    text: 'Subscript',
                    icon: 'subscript',
                },
                {
                    name: 'superscript',
                    text: 'Superscript',
                    icon: 'superscript',
                },
            ],
            function(btn, idx) {
                editor.ui.registry.addToggleButton(btn.name, {
                    tooltip: btn.text,
                    icon: btn.icon,
                    onSetup: onSetupFormatToggle(editor, btn.name),
                    onAction: toggleFormat(editor, btn.name),
                });
            },
        );
        for (let i = 1; i <= 6; i++) {
            const name = `h${i}`;
            editor.ui.registry.addToggleButton(name, {
                text: name.toUpperCase(),
                tooltip: `Heading ${i}`,
                onSetup: onSetupFormatToggle(editor, name),
                onAction: toggleFormat(editor, name),
            });
        }
    };
    const registerCommandButtons = function(editor) {
        global$e.each(
            [
                {
                    name: 'cut',
                    text: 'Cut',
                    action: 'Cut',
                    icon: 'cut',
                },
                {
                    name: 'copy',
                    text: 'Copy',
                    action: 'Copy',
                    icon: 'copy',
                },
                {
                    name: 'paste',
                    text: 'Paste',
                    action: 'Paste',
                    icon: 'paste',
                },
                {
                    name: 'help',
                    text: 'Help',
                    action: 'mceHelp',
                    icon: 'help',
                },
                {
                    name: 'selectall',
                    text: 'Select all',
                    action: 'SelectAll',
                    icon: 'select-all',
                },
                {
                    name: 'newdocument',
                    text: 'New document',
                    action: 'mceNewDocument',
                    icon: 'new-document',
                },
                {
                    name: 'removeformat',
                    text: 'Clear formatting',
                    action: 'RemoveFormat',
                    icon: 'remove-formatting',
                },
                {
                    name: 'remove',
                    text: 'Remove',
                    action: 'Delete',
                    icon: 'remove',
                },
            ],
            function(btn) {
                editor.ui.registry.addButton(btn.name, {
                    tooltip: btn.text,
                    icon: btn.icon,
                    onAction() {
                        return editor.execCommand(btn.action);
                    },
                });
            },
        );
    };
    const registerCommandToggleButtons = function(editor) {
        global$e.each(
            [
                {
                    name: 'blockquote',
                    text: 'Blockquote',
                    action: 'mceBlockQuote',
                    icon: 'quote',
                },
            ],
            function(btn) {
                editor.ui.registry.addToggleButton(btn.name, {
                    tooltip: btn.text,
                    icon: btn.icon,
                    onAction() {
                        return editor.execCommand(btn.action);
                    },
                    onSetup: onSetupFormatToggle(editor, btn.name),
                });
            },
        );
    };
    const registerButtons = function(editor) {
        registerFormatButtons(editor);
        registerCommandButtons(editor);
        registerCommandToggleButtons(editor);
    };
    const registerMenuItems = function(editor) {
        global$e.each(
            [
                {
                    name: 'bold',
                    text: 'Bold',
                    action: 'Bold',
                    icon: 'bold',
                    shortcut: 'Meta+B',
                },
                {
                    name: 'italic',
                    text: 'Italic',
                    action: 'Italic',
                    icon: 'italic',
                    shortcut: 'Meta+I',
                },
                {
                    name: 'underline',
                    text: 'Underline',
                    action: 'Underline',
                    icon: 'underline',
                    shortcut: 'Meta+U',
                },
                {
                    name: 'strikethrough',
                    text: 'Strikethrough',
                    action: 'Strikethrough',
                    icon: 'strike-through',
                    shortcut: '',
                },
                {
                    name: 'subscript',
                    text: 'Subscript',
                    action: 'Subscript',
                    icon: 'subscript',
                    shortcut: '',
                },
                {
                    name: 'superscript',
                    text: 'Superscript',
                    action: 'Superscript',
                    icon: 'superscript',
                    shortcut: '',
                },
                {
                    name: 'removeformat',
                    text: 'Clear formatting',
                    action: 'RemoveFormat',
                    icon: 'remove-formatting',
                    shortcut: '',
                },
                {
                    name: 'newdocument',
                    text: 'New document',
                    action: 'mceNewDocument',
                    icon: 'new-document',
                    shortcut: '',
                },
                {
                    name: 'cut',
                    text: 'Cut',
                    action: 'Cut',
                    icon: 'cut',
                    shortcut: 'Meta+X',
                },
                {
                    name: 'copy',
                    text: 'Copy',
                    action: 'Copy',
                    icon: 'copy',
                    shortcut: 'Meta+C',
                },
                {
                    name: 'paste',
                    text: 'Paste',
                    action: 'Paste',
                    icon: 'paste',
                    shortcut: 'Meta+V',
                },
                {
                    name: 'selectall',
                    text: 'Select all',
                    action: 'SelectAll',
                    icon: 'select-all',
                    shortcut: 'Meta+A',
                },
            ],
            function(btn) {
                editor.ui.registry.addMenuItem(btn.name, {
                    text: btn.text,
                    icon: btn.icon,
                    shortcut: btn.shortcut,
                    onAction() {
                        return editor.execCommand(btn.action);
                    },
                });
            },
        );
        editor.ui.registry.addMenuItem('codeformat', {
            text: 'Code',
            icon: 'sourcecode',
            onAction: toggleFormat(editor, 'code'),
        });
    };
    const register$6 = function(editor) {
        registerButtons(editor);
        registerMenuItems(editor);
    };
    const SimpleControls = { register: register$6 };

    const toggleUndoRedoState = function(api, editor, type) {
        const checkState = function() {
            return editor.undoManager ? editor.undoManager[type]() : false;
        };
        const onUndoStateChange = function() {
            api.setDisabled(editor.readonly || !checkState());
        };
        api.setDisabled(!checkState());
        editor.on(
            'Undo Redo AddUndo TypingUndo ClearUndos SwitchMode',
            onUndoStateChange,
        );
        return function() {
            return editor.off(
                'Undo Redo AddUndo TypingUndo ClearUndos SwitchMode',
                onUndoStateChange,
            );
        };
    };
    const registerMenuItems$1 = function(editor) {
        editor.ui.registry.addMenuItem('undo', {
            text: 'Undo',
            icon: 'undo',
            shortcut: 'Meta+Z',
            onSetup(api) {
                return toggleUndoRedoState(api, editor, 'hasUndo');
            },
            onAction() {
                return editor.execCommand('undo');
            },
        });
        editor.ui.registry.addMenuItem('redo', {
            text: 'Redo',
            icon: 'redo',
            shortcut: 'Meta+Y',
            onSetup(api) {
                return toggleUndoRedoState(api, editor, 'hasRedo');
            },
            onAction() {
                return editor.execCommand('redo');
            },
        });
    };
    const registerButtons$1 = function(editor) {
        editor.ui.registry.addButton('undo', {
            tooltip: 'Undo',
            icon: 'undo',
            onSetup(api) {
                return toggleUndoRedoState(api, editor, 'hasUndo');
            },
            onAction() {
                return editor.execCommand('undo');
            },
        });
        editor.ui.registry.addButton('redo', {
            tooltip: 'Redo',
            icon: 'redo',
            onSetup(api) {
                return toggleUndoRedoState(api, editor, 'hasRedo');
            },
            onAction() {
                return editor.execCommand('redo');
            },
        });
    };
    const register$7 = function(editor) {
        registerMenuItems$1(editor);
        registerButtons$1(editor);
    };
    const UndoRedo = { register: register$7 };

    const toggleVisualAidState = function(api, editor) {
        api.setActive(editor.hasVisual);
        const onVisualAid = function(e) {
            api.setActive(e.hasVisual);
        };
        editor.on('VisualAid', onVisualAid);
        return function() {
            return editor.off('VisualAid', onVisualAid);
        };
    };
    const registerMenuItems$2 = function(editor) {
        editor.ui.registry.addToggleMenuItem('visualaid', {
            text: 'Visual aids',
            onSetup(api) {
                return toggleVisualAidState(api, editor);
            },
            onAction() {
                editor.execCommand('mceToggleVisualAid');
            },
        });
    };
    const registerToolbarButton = function(editor) {
        editor.ui.registry.addButton('visualaid', {
            tooltip: 'Visual aids',
            text: 'Visual aids',
            onAction() {
                return editor.execCommand('mceToggleVisualAid');
            },
        });
    };
    const register$8 = function(editor) {
        registerToolbarButton(editor);
        registerMenuItems$2(editor);
    };
    const VisualAid = { register: register$8 };

    const toggleOutdentState = function(api, editor) {
        api.setDisabled(!editor.queryCommandState('outdent'));
        const onNodeChange = function() {
            api.setDisabled(!editor.queryCommandState('outdent'));
        };
        editor.on('NodeChange', onNodeChange);
        return function() {
            return editor.off('NodeChange', onNodeChange);
        };
    };
    const registerButtons$2 = function(editor) {
        editor.ui.registry.addButton('outdent', {
            tooltip: 'Decrease indent',
            icon: 'outdent',
            onSetup(api) {
                return toggleOutdentState(api, editor);
            },
            onAction() {
                return editor.execCommand('outdent');
            },
        });
        editor.ui.registry.addButton('indent', {
            tooltip: 'Increase indent',
            icon: 'indent',
            onAction() {
                return editor.execCommand('indent');
            },
        });
    };
    const register$9 = function(editor) {
        registerButtons$2(editor);
    };
    const IndentOutdent = { register: register$9 };

    const register$a = function(editor, backstage) {
        alignSelectMenu(editor, backstage);
        fontSelectMenu(editor, backstage);
        styleSelectMenu(editor, backstage);
        formatSelectMenu(editor, backstage);
        fontsizeSelectMenu(editor, backstage);
    };
    const ComplexControls = { register: register$a };

    const setup$9 = function(editor, backstage) {
        AlignmentButtons.register(editor);
        SimpleControls.register(editor);
        ComplexControls.register(editor, backstage);
        UndoRedo.register(editor);
        ColorSwatch.register(editor);
        VisualAid.register(editor);
        IndentOutdent.register(editor);
    };
    const FormatControls = { setup: setup$9 };

    const nu$d = function(x, y) {
        return {
            anchor: 'makeshift',
            x,
            y,
        };
    };
    const transpose$1 = function(pos, dx, dy) {
        return nu$d(pos.x + dx, pos.y + dy);
    };
    const isTouchEvent$1 = function(e) {
        return e.type === 'longpress' || e.type.indexOf('touch') === 0;
    };
    const fromPageXY = function(e) {
        if (isTouchEvent$1(e)) {
            const touch = e.touches[0];
            return nu$d(touch.pageX, touch.pageY);
        }
        return nu$d(e.pageX, e.pageY);
    };
    const fromClientXY = function(e) {
        if (isTouchEvent$1(e)) {
            const touch = e.touches[0];
            return nu$d(touch.clientX, touch.clientY);
        }
        return nu$d(e.clientX, e.clientY);
    };
    const transposeContentAreaContainer = function(element, pos) {
        const containerPos = global$7.DOM.getPos(element);
        return transpose$1(pos, containerPos.x, containerPos.y);
    };
    const getPointAnchor = function(editor, e) {
        if (e.type === 'contextmenu') {
            if (editor.inline) {
                return fromPageXY(e);
            }
            return transposeContentAreaContainer(
                editor.getContentAreaContainer(),
                fromClientXY(e),
            );
        }
        return getSelectionAnchor(editor);
    };
    var getSelectionAnchor = function(editor) {
        return {
            anchor: 'selection',
            root: Element.fromDom(editor.selection.getNode()),
        };
    };
    const getNodeAnchor$1 = function(editor) {
        return {
            anchor: 'node',
            node: Option.some(Element.fromDom(editor.selection.getNode())),
            root: Element.fromDom(editor.getBody()),
        };
    };

    const getAnchorSpec = function(editor, e, isTriggeredByKeyboardEvent) {
        return isTriggeredByKeyboardEvent
            ? getNodeAnchor$1(editor)
            : getPointAnchor(editor, e);
    };
    const initAndShow = function(
        editor,
        e,
        buildMenu,
        backstage,
        contextmenu,
        isTriggeredByKeyboardEvent,
    ) {
        const items = buildMenu();
        const anchorSpec = getAnchorSpec(editor, e, isTriggeredByKeyboardEvent);
        build$2(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false).map(
            function(menuData) {
                e.preventDefault();
                InlineView.showMenuAt(contextmenu, anchorSpec, {
                    menu: { markers: markers$1('normal') },
                    data: menuData,
                });
            },
        );
    };

    const layouts = {
        onLtr() {
            return [
                south$1,
                southeast$1,
                southwest$1,
                northeast$1,
                northwest$1,
                north$1,
                north$3,
                south$3,
                northeast$3,
                southeast$3,
                northwest$3,
                southwest$3,
            ];
        },
        onRtl() {
            return [
                south$1,
                southwest$1,
                southeast$1,
                northwest$1,
                northeast$1,
                north$1,
                north$3,
                south$3,
                northwest$3,
                southwest$3,
                northeast$3,
                southeast$3,
            ];
        },
    };
    const bubbleSize$1 = 12;
    const bubbleAlignments$2 = {
        valignCentre: [],
        alignCentre: [],
        alignLeft: ['tox-pop--align-left'],
        alignRight: ['tox-pop--align-right'],
        right: ['tox-pop--right'],
        left: ['tox-pop--left'],
        bottom: ['tox-pop--bottom'],
        top: ['tox-pop--top'],
    };
    const isTouchWithinSelection = function(editor, e) {
        const { selection } = editor;
        if (selection.isCollapsed() || e.touches.length < 1) {
            return false;
        }
        const touch_1 = e.touches[0];
        const rng = selection.getRng();
        const rngRectOpt = getFirstRect$1(
            editor.getWin(),
            Selection.domRange(rng),
        );
        return rngRectOpt.exists(function(rngRect) {
            return (
                rngRect.left() <= touch_1.clientX &&
                rngRect.right() >= touch_1.clientX &&
                rngRect.top() <= touch_1.clientY &&
                rngRect.bottom() >= touch_1.clientY
            );
        });
    };
    const getAnchorSpec$1 = function(editor, isTriggeredByKeyboardEvent) {
        const anchorSpec = isTriggeredByKeyboardEvent
            ? getNodeAnchor$1(editor)
            : getSelectionAnchor(editor);
        return {
            bubble: nu$8(0, bubbleSize$1, bubbleAlignments$2),
            layouts,
            overrides: {
                maxWidthFunction: expandable$1(),
                maxHeightFunction: expandable(),
            },
            ...anchorSpec,
        };
    };
    const setupiOSOverrides = function(editor) {
        const originalSelection = editor.selection.getRng();
        const selectionReset = function() {
            global$2.setEditorTimeout(
                editor,
                function() {
                    editor.selection.setRng(originalSelection);
                },
                10,
            );
            unbindEventListeners();
        };
        editor.once('touchend', selectionReset);
        const preventMousedown = function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
        };
        editor.on('mousedown', preventMousedown, true);
        const clearSelectionReset = function() {
            return unbindEventListeners();
        };
        editor.once('longpresscancel', clearSelectionReset);
        var unbindEventListeners = function() {
            editor.off('touchend', selectionReset);
            editor.off('longpresscancel', clearSelectionReset);
            editor.off('mousedown', preventMousedown);
        };
    };
    const show = function(
        editor,
        e,
        items,
        backstage,
        contextmenu,
        isTriggeredByKeyboardEvent,
    ) {
        const anchorSpec = getAnchorSpec$1(editor, isTriggeredByKeyboardEvent);
        build$2(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, true).map(
            function(menuData) {
                e.preventDefault();
                InlineView.showMenuWithinBounds(
                    contextmenu,
                    anchorSpec,
                    {
                        menu: { markers: markers$1('normal') },
                        data: menuData,
                        type: 'horizontal',
                    },
                    function() {
                        return Option.some(getContextToolbarBounds(editor));
                    },
                );
                editor.fire(hideContextToolbarEvent);
            },
        );
    };
    const initAndShow$1 = function(
        editor,
        e,
        buildMenu,
        backstage,
        contextmenu,
        isTriggeredByKeyboardEvent,
    ) {
        const detection = detect$3();
        const isiOS = detection.os.isiOS();
        const isOSX = detection.os.isOSX();
        const isAndroid = detection.os.isAndroid();
        const open = function() {
            const items = buildMenu();
            show(
                editor,
                e,
                items,
                backstage,
                contextmenu,
                isTriggeredByKeyboardEvent,
            );
        };
        if ((isOSX || isiOS) && !isTriggeredByKeyboardEvent) {
            const openiOS_1 = function() {
                setupiOSOverrides(editor);
                open();
            };
            if (isTouchWithinSelection(editor, e)) {
                openiOS_1();
            } else {
                editor.once('selectionchange', openiOS_1);
                editor.once('touchend', function() {
                    return editor.off('selectionchange', openiOS_1);
                });
            }
        } else {
            if (isAndroid && !isTriggeredByKeyboardEvent) {
                editor.selection.setCursorLocation(e.target, 0);
            }
            open();
        }
    };

    const patchPipeConfig = function(config) {
        return typeof config === 'string' ? config.split(/[ ,]/) : config;
    };
    const shouldNeverUseNative = function(editor) {
        return editor.settings.contextmenu_never_use_native || false;
    };
    const getMenuItems = function(editor, name, defaultItems) {
        const { contextMenus } = editor.ui.registry.getAll();
        return get(editor.settings, name)
            .map(patchPipeConfig)
            .getOrThunk(function() {
                return filter(patchPipeConfig(defaultItems), function(item) {
                    return has(contextMenus, item);
                });
            });
    };
    const isContextMenuDisabled = function(editor) {
        return editor.getParam('contextmenu') === false;
    };
    const getContextMenu = function(editor) {
        return getMenuItems(
            editor,
            'contextmenu',
            'link linkchecker image imagetools table spellchecker configurepermanentpen',
        );
    };
    const Settings$1 = {
        shouldNeverUseNative,
        getContextMenu,
        isContextMenuDisabled,
    };

    const isSeparator$1 = function(item) {
        return isString(item) ? item === '|' : item.type === 'separator';
    };
    const separator$3 = { type: 'separator' };
    var makeContextItem = function(item) {
        if (isString(item)) {
            return item;
        }
        switch (item.type) {
            case 'separator':
                return separator$3;
            case 'submenu':
                return {
                    type: 'nestedmenuitem',
                    text: item.text,
                    icon: item.icon,
                    getSubmenuItems() {
                        const items = item.getSubmenuItems();
                        if (isString(items)) {
                            return items;
                        }
                        return map(items, makeContextItem);
                    },
                };
            default:
                return {
                    type: 'menuitem',
                    text: item.text,
                    icon: item.icon,
                    onAction: noarg(item.onAction),
                };
        }
    };
    const addContextMenuGroup = function(xs, groupItems) {
        if (groupItems.length === 0) {
            return xs;
        }
        const lastMenuItem = last(xs).filter(function(item) {
            return !isSeparator$1(item);
        });
        const before = lastMenuItem.fold(
            function() {
                return [];
            },
            function(_) {
                return [separator$3];
            },
        );
        return xs
            .concat(before)
            .concat(groupItems)
            .concat([separator$3]);
    };
    const generateContextMenu = function(
        contextMenus,
        menuConfig,
        selectedElement,
    ) {
        const sections = foldl(
            menuConfig,
            function(acc, name) {
                if (has(contextMenus, name)) {
                    const items = contextMenus[name].update(selectedElement);
                    if (isString(items)) {
                        return addContextMenuGroup(acc, items.split(' '));
                    }
                    if (items.length > 0) {
                        const allItems = map(items, makeContextItem);
                        return addContextMenuGroup(acc, allItems);
                    }
                    return acc;
                }
                return acc.concat([name]);
            },
            [],
        );
        if (
            sections.length > 0 &&
            isSeparator$1(sections[sections.length - 1])
        ) {
            sections.pop();
        }
        return sections;
    };
    const isNativeOverrideKeyEvent = function(editor, e) {
        return e.ctrlKey && !Settings$1.shouldNeverUseNative(editor);
    };
    const isTriggeredByKeyboard = function(editor, e) {
        return (
            e.type !== 'longpress' &&
            (e.button !== 2 ||
                (e.target === editor.getBody() && e.pointerType === ''))
        );
    };
    const setup$a = function(editor, lazySink, backstage) {
        const detection = detect$3();
        const { isTouch } = detection.deviceType;
        const contextmenu = build$1(
            InlineView.sketch({
                dom: { tag: 'div' },
                lazySink,
                onEscape() {
                    return editor.focus();
                },
                onShow() {
                    return backstage.setContextMenuState(true);
                },
                onHide() {
                    return backstage.setContextMenuState(false);
                },
                fireDismissalEventInstead: {},
                inlineBehaviours: derive$1([
                    config('dismissContextMenu', [
                        run(dismissRequested(), function(comp, se) {
                            Sandboxing.close(comp);
                            editor.focus();
                        }),
                    ]),
                ]),
            }),
        );
        const hideContextMenu = function(_e) {
            return InlineView.hide(contextmenu);
        };
        const showContextMenu = function(e) {
            if (Settings$1.shouldNeverUseNative(editor)) {
                e.preventDefault();
            }
            if (
                isNativeOverrideKeyEvent(editor, e) ||
                Settings$1.isContextMenuDisabled(editor)
            ) {
                return;
            }
            const isTriggeredByKeyboardEvent = isTriggeredByKeyboard(editor, e);
            const buildMenu = function() {
                const selectedElement = isTriggeredByKeyboardEvent
                    ? editor.selection.getStart(true)
                    : e.target;
                const registry = editor.ui.registry.getAll();
                const menuConfig = Settings$1.getContextMenu(editor);
                return generateContextMenu(
                    registry.contextMenus,
                    menuConfig,
                    selectedElement,
                );
            };
            const initAndShow$2 = isTouch() ? initAndShow$1 : initAndShow;
            initAndShow$2(
                editor,
                e,
                buildMenu,
                backstage,
                contextmenu,
                isTriggeredByKeyboardEvent,
            );
        };
        editor.on('init', function() {
            const hideEvents = `ResizeEditor ScrollContent ScrollWindow longpresscancel${
                isTouch() ? '' : ' ResizeWindow'
            }`;
            editor.on(hideEvents, hideContextMenu);
            editor.on('longpress contextmenu', showContextMenu);
        });
    };

    const initialAttribute = 'data-initial-z-index';
    const resetZIndex = function(blocker) {
        parent(blocker.element())
            .filter(isElement)
            .each(function(root) {
                const initZIndex = get$2(root, initialAttribute);
                if (has$1(root, initialAttribute)) {
                    set$2(root, 'z-index', initZIndex);
                } else {
                    remove$6(root, 'z-index');
                }
                remove$1(root, initialAttribute);
            });
    };
    const changeZIndex = function(blocker) {
        parent(blocker.element())
            .filter(isElement)
            .each(function(root) {
                getRaw(root, 'z-index').each(function(zindex) {
                    set$1(root, initialAttribute, zindex);
                });
                set$2(root, 'z-index', get$4(blocker.element(), 'z-index'));
            });
    };
    const instigate = function(anyComponent, blocker) {
        anyComponent.getSystem().addToGui(blocker);
        changeZIndex(blocker);
    };
    const discard = function(blocker) {
        resetZIndex(blocker);
        blocker.getSystem().removeFromGui(blocker);
    };
    const createComponent = function(component, blockerClass, blockerEvents) {
        return component.getSystem().build(
            Container.sketch({
                dom: {
                    styles: {
                        left: '0px',
                        top: '0px',
                        width: '100%',
                        height: '100%',
                        position: 'fixed',
                        'z-index': '1000000000000000',
                    },
                    classes: [blockerClass],
                },
                events: blockerEvents,
            }),
        );
    };

    const SnapSchema = optionObjOf('snaps', [
        strict$1('getSnapPoints'),
        onHandler('onSensor'),
        strict$1('leftAttr'),
        strict$1('topAttr'),
        defaulted$1('lazyViewport', win),
        defaulted$1('mustSnap', false),
    ]);

    const schema$s = [
        defaulted$1('useFixed', never),
        strict$1('blockerClass'),
        defaulted$1('getTarget', identity),
        defaulted$1('onDrag', noop),
        defaulted$1('repositionTarget', true),
        defaulted$1('onDrop', noop),
        defaultedFunction('getBounds', win),
        SnapSchema,
    ];

    const get$d = function(component, snapsInfo) {
        const element = component.element();
        const x = parseInt(get$2(element, snapsInfo.leftAttr), 10);
        const y = parseInt(get$2(element, snapsInfo.topAttr), 10);
        return isNaN(x) || isNaN(y)
            ? Option.none()
            : Option.some(Position(x, y));
    };
    const set$8 = function(component, snapsInfo, pt) {
        const element = component.element();
        set$1(element, snapsInfo.leftAttr, `${pt.left()}px`);
        set$1(element, snapsInfo.topAttr, `${pt.top()}px`);
    };
    const clear = function(component, snapsInfo) {
        const element = component.element();
        remove$1(element, snapsInfo.leftAttr);
        remove$1(element, snapsInfo.topAttr);
    };

    const getCoords = function(component, snapInfo, coord, delta) {
        return get$d(component, snapInfo).fold(
            function() {
                return coord;
            },
            function(fixed) {
                return fixed$1(
                    fixed.left() + delta.left(),
                    fixed.top() + delta.top(),
                );
            },
        );
    };
    const moveOrSnap = function(
        component,
        snapInfo,
        coord,
        delta,
        scroll,
        origin,
    ) {
        const newCoord = getCoords(component, snapInfo, coord, delta);
        const snap = snapInfo.mustSnap
            ? findClosestSnap(component, snapInfo, newCoord, scroll, origin)
            : findSnap(component, snapInfo, newCoord, scroll, origin);
        const fixedCoord = asFixed(newCoord, scroll, origin);
        set$8(component, snapInfo, fixedCoord);
        return snap.fold(
            function() {
                return {
                    coord: fixed$1(fixedCoord.left(), fixedCoord.top()),
                    extra: Option.none(),
                };
            },
            function(spanned) {
                return {
                    coord: spanned.output(),
                    extra: spanned.extra(),
                };
            },
        );
    };
    const stopDrag = function(component, snapInfo) {
        clear(component, snapInfo);
    };
    const findMatchingSnap = function(snaps, newCoord, scroll, origin) {
        return findMap(snaps, function(snap) {
            const sensor = snap.sensor();
            const inRange = withinRange(
                newCoord,
                sensor,
                snap.range().left(),
                snap.range().top(),
                scroll,
                origin,
            );
            return inRange
                ? Option.some({
                      output: constant(
                          absorb(snap.output(), newCoord, scroll, origin),
                      ),
                      extra: snap.extra,
                  })
                : Option.none();
        });
    };
    var findClosestSnap = function(
        component,
        snapInfo,
        newCoord,
        scroll,
        origin,
    ) {
        const snaps = snapInfo.getSnapPoints(component);
        const matchSnap = findMatchingSnap(snaps, newCoord, scroll, origin);
        return matchSnap.orThunk(function() {
            const bestSnap = foldl(
                snaps,
                function(acc, snap) {
                    const sensor = snap.sensor();
                    const deltas = getDeltas(
                        newCoord,
                        sensor,
                        snap.range().left(),
                        snap.range().top(),
                        scroll,
                        origin,
                    );
                    return acc.deltas.fold(
                        function() {
                            return {
                                deltas: Option.some(deltas),
                                snap: Option.some(snap),
                            };
                        },
                        function(bestDeltas) {
                            const currAvg = (deltas.left() + deltas.top()) / 2;
                            const bestAvg =
                                (bestDeltas.left() + bestDeltas.top()) / 2;
                            if (currAvg <= bestAvg) {
                                return {
                                    deltas: Option.some(deltas),
                                    snap: Option.some(snap),
                                };
                            }
                            return acc;
                        },
                    );
                },
                {
                    deltas: Option.none(),
                    snap: Option.none(),
                },
            );
            return bestSnap.snap.map(function(snap) {
                return {
                    output: constant(
                        absorb(snap.output(), newCoord, scroll, origin),
                    ),
                    extra: snap.extra,
                };
            });
        });
    };
    var findSnap = function(component, snapInfo, newCoord, scroll, origin) {
        const snaps = snapInfo.getSnapPoints(component);
        return findMatchingSnap(snaps, newCoord, scroll, origin);
    };
    const snapTo = function(snap, scroll, origin) {
        return {
            coord: absorb(snap.output(), snap.output(), scroll, origin),
            extra: snap.extra(),
        };
    };

    const getCurrentCoord = function(target) {
        return lift3(
            getRaw(target, 'left'),
            getRaw(target, 'top'),
            getRaw(target, 'position'),
            function(left, top, position) {
                const nu = position === 'fixed' ? fixed$1 : offset;
                return nu(parseInt(left, 10), parseInt(top, 10));
            },
        ).getOrThunk(function() {
            const location = absolute(target);
            return absolute$3(location.left(), location.top());
        });
    };
    const clampCoords = function(component, coords, scroll, origin, startData) {
        const { bounds } = startData;
        const absoluteCoord = asAbsolute(coords, scroll, origin);
        const newX = cap(
            absoluteCoord.left(),
            bounds.x(),
            bounds.x() + bounds.width() - startData.width,
        );
        const newY = cap(
            absoluteCoord.top(),
            bounds.y(),
            bounds.y() + bounds.height() - startData.height,
        );
        const newCoords = absolute$3(newX, newY);
        return coords.fold(
            function() {
                const offset$1 = asOffset(newCoords, scroll, origin);
                return offset(offset$1.left(), offset$1.top());
            },
            function() {
                return newCoords;
            },
            function() {
                const fixed = asFixed(newCoords, scroll, origin);
                return fixed$1(fixed.left(), fixed.top());
            },
        );
    };
    const calcNewCoord = function(
        component,
        optSnaps,
        currentCoord,
        scroll,
        origin,
        delta,
        startData,
    ) {
        const newCoord = optSnaps.fold(
            function() {
                const translated = translate$2(
                    currentCoord,
                    delta.left(),
                    delta.top(),
                );
                const fixedCoord = asFixed(translated, scroll, origin);
                return fixed$1(fixedCoord.left(), fixedCoord.top());
            },
            function(snapInfo) {
                const snapping = moveOrSnap(
                    component,
                    snapInfo,
                    currentCoord,
                    delta,
                    scroll,
                    origin,
                );
                snapping.extra.each(function(extra) {
                    snapInfo.onSensor(component, extra);
                });
                return snapping.coord;
            },
        );
        return clampCoords(component, newCoord, scroll, origin, startData);
    };
    const dragBy = function(component, dragConfig, startData, delta) {
        const target = dragConfig.getTarget(component.element());
        if (dragConfig.repositionTarget) {
            const doc = owner(component.element());
            const scroll = get$8(doc);
            const origin = getOrigin(target);
            const currentCoord = getCurrentCoord(target);
            const newCoord = calcNewCoord(
                component,
                dragConfig.snaps,
                currentCoord,
                scroll,
                origin,
                delta,
                startData,
            );
            const styles = toStyles(newCoord, scroll, origin);
            setAll$1(target, styles);
        }
        dragConfig.onDrag(component, target, delta);
    };

    const calcStartData = function(dragConfig, comp) {
        return {
            bounds: dragConfig.getBounds(),
            height: getOuter$1(comp.element()),
            width: getOuter$2(comp.element()),
        };
    };
    const move$1 = function(component, dragConfig, dragState, dragMode, event) {
        const delta = dragState.update(dragMode, event);
        const dragStartData = dragState.getStartData().getOrThunk(function() {
            return calcStartData(dragConfig, component);
        });
        delta.each(function(dlt) {
            dragBy(component, dragConfig, dragStartData, dlt);
        });
    };
    const stop = function(component, blocker, dragConfig, dragState) {
        blocker.each(discard);
        dragConfig.snaps.each(function(snapInfo) {
            stopDrag(component, snapInfo);
        });
        const target = dragConfig.getTarget(component.element());
        dragState.reset();
        dragConfig.onDrop(component, target);
    };
    const handlers = function(events) {
        return function(dragConfig, dragState) {
            const updateStartState = function(comp) {
                dragState.setStartData(calcStartData(dragConfig, comp));
            };
            return derive(
                __spreadArrays(
                    [
                        run(windowScroll(), function(comp) {
                            dragState.getStartData().each(function() {
                                return updateStartState(comp);
                            });
                        }),
                    ],
                    events(dragConfig, dragState, updateStartState),
                ),
            );
        };
    };

    const init$c = function(dragApi) {
        return derive([
            run(mousedown(), dragApi.forceDrop),
            run(mouseup(), dragApi.drop),
            run(mousemove(), function(comp, simulatedEvent) {
                dragApi.move(simulatedEvent.event());
            }),
            run(mouseout(), dragApi.delayDrop),
        ]);
    };

    const getData$1 = function(event) {
        return Option.from(Position(event.x(), event.y()));
    };
    const getDelta$1 = function(old, nu) {
        return Position(nu.left() - old.left(), nu.top() - old.top());
    };

    const MouseData = /* #__PURE__ */ Object.freeze({
        getData: getData$1,
        getDelta: getDelta$1,
    });

    const events$g = function(dragConfig, dragState, updateStartState) {
        return [
            run(mousedown(), function(component, simulatedEvent) {
                const raw = simulatedEvent.event().raw();
                if (raw.button !== 0) {
                    return;
                }
                simulatedEvent.stop();
                const stop$1 = function() {
                    return stop(
                        component,
                        Option.some(blocker),
                        dragConfig,
                        dragState,
                    );
                };
                const delayDrop = DelayedFunction(stop$1, 200);
                const dragApi = {
                    drop: stop$1,
                    delayDrop: delayDrop.schedule,
                    forceDrop: stop$1,
                    move(event) {
                        delayDrop.cancel();
                        move$1(
                            component,
                            dragConfig,
                            dragState,
                            MouseData,
                            event,
                        );
                    },
                };
                var blocker = createComponent(
                    component,
                    dragConfig.blockerClass,
                    init$c(dragApi),
                );
                const start = function() {
                    updateStartState(component);
                    instigate(component, blocker);
                };
                start();
            }),
        ];
    };
    const schema$t = __spreadArrays(schema$s, [
        output('dragger', { handlers: handlers(events$g) }),
    ]);

    const init$d = function(dragApi) {
        return derive([
            run(touchstart(), dragApi.forceDrop),
            run(touchend(), dragApi.drop),
            run(touchcancel(), dragApi.drop),
            run(touchmove(), function(comp, simulatedEvent) {
                dragApi.move(simulatedEvent.event());
            }),
        ]);
    };

    const getDataFrom = function(touches) {
        const touch = touches[0];
        return Option.some(Position(touch.clientX, touch.clientY));
    };
    const getData$2 = function(event) {
        const raw = event.raw();
        const { touches } = raw;
        return touches.length === 1 ? getDataFrom(touches) : Option.none();
    };
    const getDelta$2 = function(old, nu) {
        return Position(nu.left() - old.left(), nu.top() - old.top());
    };

    const TouchData = /* #__PURE__ */ Object.freeze({
        getData: getData$2,
        getDelta: getDelta$2,
    });

    const events$h = function(dragConfig, dragState, updateStartState) {
        const blockerCell = Cell(Option.none());
        return [
            run(touchstart(), function(component, simulatedEvent) {
                simulatedEvent.stop();
                const stop$1 = function() {
                    stop(component, blockerCell.get(), dragConfig, dragState);
                    blockerCell.set(Option.none());
                };
                const dragApi = {
                    drop: stop$1,
                    delayDrop() {},
                    forceDrop: stop$1,
                    move(event) {
                        move$1(
                            component,
                            dragConfig,
                            dragState,
                            TouchData,
                            event,
                        );
                    },
                };
                const blocker = createComponent(
                    component,
                    dragConfig.blockerClass,
                    init$d(dragApi),
                );
                blockerCell.set(Option.some(blocker));
                const start = function() {
                    updateStartState(component);
                    instigate(component, blocker);
                };
                start();
            }),
            run(touchmove(), function(component, simulatedEvent) {
                simulatedEvent.stop();
                move$1(
                    component,
                    dragConfig,
                    dragState,
                    TouchData,
                    simulatedEvent.event(),
                );
            }),
            run(touchend(), function(component, simulatedEvent) {
                simulatedEvent.stop();
                stop(component, blockerCell.get(), dragConfig, dragState);
                blockerCell.set(Option.none());
            }),
            run(touchcancel(), function(component) {
                stop(component, blockerCell.get(), dragConfig, dragState);
                blockerCell.set(Option.none());
            }),
        ];
    };
    const schema$u = __spreadArrays(schema$s, [
        output('dragger', { handlers: handlers(events$h) }),
    ]);

    const events$i = function(dragConfig, dragState, updateStartState) {
        return __spreadArrays(
            events$g(dragConfig, dragState, updateStartState),
            events$h(dragConfig, dragState, updateStartState),
        );
    };
    const schema$v = __spreadArrays(schema$s, [
        output('dragger', { handlers: handlers(events$i) }),
    ]);

    const mouse = schema$t;
    const touch = schema$u;
    const mouseOrTouch = schema$v;

    const DraggingBranches = /* #__PURE__ */ Object.freeze({
        mouse,
        touch,
        mouseOrTouch,
    });

    const init$e = function() {
        let previous = Option.none();
        let startData = Option.none();
        const reset = function() {
            previous = Option.none();
            startData = Option.none();
        };
        const calculateDelta = function(mode, nu) {
            const result = previous.map(function(old) {
                return mode.getDelta(old, nu);
            });
            previous = Option.some(nu);
            return result;
        };
        const update = function(mode, dragEvent) {
            return mode.getData(dragEvent).bind(function(nuData) {
                return calculateDelta(mode, nuData);
            });
        };
        const setStartData = function(data) {
            startData = Option.some(data);
        };
        const getStartData = function() {
            return startData;
        };
        const readState = constant({});
        return nu$5({
            readState,
            reset,
            update,
            getStartData,
            setStartData,
        });
    };

    const DragState = /* #__PURE__ */ Object.freeze({
        init: init$e,
    });

    const snapTo$1 = function(component, dragConfig, _state, snap) {
        const target = dragConfig.getTarget(component.element());
        if (dragConfig.repositionTarget) {
            const doc = owner(component.element());
            const scroll = get$8(doc);
            const origin = getOrigin(target);
            const snapPin = snapTo(snap, scroll, origin);
            const styles = toStyles(snapPin.coord, scroll, origin);
            setAll$1(target, styles);
        }
    };

    const DraggingApis = /* #__PURE__ */ Object.freeze({
        snapTo: snapTo$1,
    });

    const Dragging = createModes$1({
        branchKey: 'mode',
        branches: DraggingBranches,
        name: 'dragging',
        active: {
            events(dragConfig, dragState) {
                const { dragger } = dragConfig;
                return dragger.handlers(dragConfig, dragState);
            },
        },
        extra: {
            snap: MixedBag(['sensor', 'range', 'output'], ['extra']),
        },
        state: DragState,
        apis: DraggingApis,
    });

    const platform$1 = detect$3();
    const snapWidth = 40;
    const snapOffset = snapWidth / 2;
    const calcSnap = function(selectorOpt, td, x, y, width, height) {
        return selectorOpt.fold(
            function() {
                return Dragging.snap({
                    sensor: absolute$3(x - snapOffset, y - snapOffset),
                    range: Position(width, height),
                    output: absolute$3(Option.some(x), Option.some(y)),
                    extra: { td },
                });
            },
            function(selectorHandle) {
                const sensorLeft = x - snapOffset;
                const sensorTop = y - snapOffset;
                const sensorWidth = snapWidth;
                const sensorHeight = snapWidth;
                const rect = selectorHandle
                    .element()
                    .dom()
                    .getBoundingClientRect();
                return Dragging.snap({
                    sensor: absolute$3(sensorLeft, sensorTop),
                    range: Position(sensorWidth, sensorHeight),
                    output: absolute$3(
                        Option.some(x - rect.width / 2),
                        Option.some(y - rect.height / 2),
                    ),
                    extra: { td },
                });
            },
        );
    };
    const getSnapsConfig = function(getSnapPoints, cell, onChange) {
        const isSameCell = function(cellOpt, td) {
            return cellOpt.exists(function(currentTd) {
                return eq(currentTd, td);
            });
        };
        return {
            getSnapPoints,
            leftAttr: 'data-drag-left',
            topAttr: 'data-drag-top',
            onSensor(component, extra) {
                const { td } = extra;
                if (!isSameCell(cell.get(), td)) {
                    cell.set(Option.some(td));
                    onChange(td);
                }
            },
            mustSnap: true,
        };
    };
    const createSelector = function(snaps) {
        return record(
            Button.sketch({
                dom: {
                    tag: 'div',
                    classes: ['tox-selector'],
                },
                buttonBehaviours: derive$1([
                    Dragging.config({
                        mode: 'mouseOrTouch',
                        blockerClass: 'blocker',
                        snaps,
                    }),
                    Unselecting.config({}),
                ]),
                eventOrder: {
                    mousedown: ['dragging', 'alloy.base.behaviour'],
                    touchstart: ['dragging', 'alloy.base.behaviour'],
                },
            }),
        );
    };
    const setup$b = function(editor, sink) {
        const tlTds = Cell([]);
        const brTds = Cell([]);
        const isVisible = Cell(false);
        const startCell = Cell(Option.none());
        const finishCell = Cell(Option.none());
        const getTopLeftSnap = function(td) {
            const box = absolute$1(td);
            return calcSnap(
                memTopLeft.getOpt(sink),
                td,
                box.x(),
                box.y(),
                box.width(),
                box.height(),
            );
        };
        const getTopLeftSnaps = function() {
            return map(tlTds.get(), function(td) {
                return getTopLeftSnap(td);
            });
        };
        const getBottomRightSnap = function(td) {
            const box = absolute$1(td);
            return calcSnap(
                memBottomRight.getOpt(sink),
                td,
                box.right(),
                box.bottom(),
                box.width(),
                box.height(),
            );
        };
        const getBottomRightSnaps = function() {
            return map(brTds.get(), function(td) {
                return getBottomRightSnap(td);
            });
        };
        const topLeftSnaps = getSnapsConfig(
            getTopLeftSnaps,
            startCell,
            function(start) {
                finishCell.get().each(function(finish) {
                    editor.fire('TableSelectorChange', {
                        start,
                        finish,
                    });
                });
            },
        );
        const bottomRightSnaps = getSnapsConfig(
            getBottomRightSnaps,
            finishCell,
            function(finish) {
                startCell.get().each(function(start) {
                    editor.fire('TableSelectorChange', {
                        start,
                        finish,
                    });
                });
            },
        );
        var memTopLeft = createSelector(topLeftSnaps);
        var memBottomRight = createSelector(bottomRightSnaps);
        const topLeft = build$1(memTopLeft.asSpec());
        const bottomRight = build$1(memBottomRight.asSpec());
        const showOrHideHandle = function(selector, cell, isAbove, isBelow) {
            const cellRect = cell.dom().getBoundingClientRect();
            remove$6(selector.element(), 'display');
            const viewportHeight = defaultView(
                Element.fromDom(editor.getBody()),
            ).dom().innerHeight;
            const aboveViewport = isAbove(cellRect);
            const belowViewport = isBelow(cellRect, viewportHeight);
            if (aboveViewport || belowViewport) {
                set$2(selector.element(), 'display', 'none');
            }
        };
        const snapTo = function(selector, cell, getSnapConfig, pos) {
            const snap = getSnapConfig(cell);
            Dragging.snapTo(selector, snap);
            const isAbove = function(rect) {
                return rect[pos] < 0;
            };
            const isBelow = function(rect, viewportHeight) {
                return rect[pos] > viewportHeight;
            };
            showOrHideHandle(selector, cell, isAbove, isBelow);
        };
        const snapTopLeft = function(cell) {
            return snapTo(topLeft, cell, getTopLeftSnap, 'top');
        };
        const snapLastTopLeft = function() {
            return startCell.get().each(snapTopLeft);
        };
        const snapBottomRight = function(cell) {
            return snapTo(bottomRight, cell, getBottomRightSnap, 'bottom');
        };
        const snapLastBottomRight = function() {
            return finishCell.get().each(snapBottomRight);
        };
        if (platform$1.deviceType.isTouch()) {
            editor.on('TableSelectionChange', function(e) {
                if (!isVisible.get()) {
                    attach$1(sink, topLeft);
                    attach$1(sink, bottomRight);
                    isVisible.set(true);
                }
                startCell.set(Option.some(e.start));
                finishCell.set(Option.some(e.finish));
                e.otherCells.each(function(otherCells) {
                    tlTds.set(otherCells.upOrLeftCells);
                    brTds.set(otherCells.downOrRightCells);
                    snapTopLeft(e.start);
                    snapBottomRight(e.finish);
                });
            });
            editor.on('ResizeEditor ResizeWindow ScrollContent', function() {
                snapLastTopLeft();
                snapLastBottomRight();
            });
            editor.on('TableSelectionClear', function() {
                if (isVisible.get()) {
                    detach(topLeft);
                    detach(bottomRight);
                    isVisible.set(false);
                }
                startCell.set(Option.none());
                finishCell.set(Option.none());
            });
        }
    };
    const TableSelectorHandles = { setup: setup$b };

    let ResizeTypes;
    (function(ResizeTypes) {
        ResizeTypes[(ResizeTypes.None = 0)] = 'None';
        ResizeTypes[(ResizeTypes.Both = 1)] = 'Both';
        ResizeTypes[(ResizeTypes.Vertical = 2)] = 'Vertical';
    })(ResizeTypes || (ResizeTypes = {}));
    const getDimensions = function(
        editor,
        deltas,
        resizeType,
        originalHeight,
        originalWidth,
    ) {
        const dimensions = {};
        dimensions.height = Utils.calcCappedSize(
            originalHeight + deltas.top(),
            getMinHeightSetting(editor),
            getMaxHeightSetting(editor),
        );
        if (resizeType === ResizeTypes.Both) {
            dimensions.width = Utils.calcCappedSize(
                originalWidth + deltas.left(),
                getMinWidthSetting(editor),
                getMaxWidthSetting(editor),
            );
        }
        return dimensions;
    };
    const resize$3 = function(editor, deltas, resizeType) {
        const container = Element.fromDom(editor.getContainer());
        const dimensions = getDimensions(
            editor,
            deltas,
            resizeType,
            get$6(container),
            get$7(container),
        );
        each$1(dimensions, function(val, dim) {
            return set$2(container, dim, Utils.numToPx(val));
        });
        Events.fireResizeEditor(editor);
    };

    const isHidden$1 = function(elm) {
        if (elm.nodeType === 1) {
            if (elm.nodeName === 'BR' || !!elm.getAttribute('data-mce-bogus')) {
                return true;
            }
            if (elm.getAttribute('data-mce-type') === 'bookmark') {
                return true;
            }
        }
        return false;
    };
    const renderElementPath = function(editor, settings) {
        if (!settings.delimiter) {
            settings.delimiter = '\xBB';
        }
        const getDataPath = function(data) {
            const parts = data || [];
            const newPathElements = map(parts, function(part, index) {
                return Button.sketch({
                    dom: {
                        tag: 'div',
                        classes: ['tox-statusbar__path-item'],
                        attributes: {
                            role: 'button',
                            'data-index': index,
                            'tab-index': -1,
                            'aria-level': index + 1,
                        },
                        innerHtml: part.name,
                    },
                    action(btn) {
                        editor.focus();
                        editor.selection.select(part.element);
                        editor.nodeChanged();
                    },
                });
            });
            const divider = {
                dom: {
                    tag: 'div',
                    classes: ['tox-statusbar__path-divider'],
                    attributes: { 'aria-hidden': true },
                    innerHtml: ` ${settings.delimiter} `,
                },
            };
            return foldl(
                newPathElements.slice(1),
                function(acc, element) {
                    const newAcc = acc;
                    newAcc.push(divider);
                    newAcc.push(element);
                    return newAcc;
                },
                [newPathElements[0]],
            );
        };
        const updatePath = function(parents) {
            const newPath = [];
            let i = parents.length;
            while (i-- > 0) {
                const parent = parents[i];
                if (parent.nodeType === 1 && !isHidden$1(parent)) {
                    const args = editor.fire('ResolveName', {
                        name: parent.nodeName.toLowerCase(),
                        target: parent,
                    });
                    if (!args.isDefaultPrevented()) {
                        newPath.push({
                            name: args.name,
                            element: parent,
                        });
                    }
                    if (args.isPropagationStopped()) {
                        break;
                    }
                }
            }
            return newPath;
        };
        return {
            dom: {
                tag: 'div',
                classes: ['tox-statusbar__path'],
                attributes: { role: 'navigation' },
            },
            behaviours: derive$1([
                Keying.config({
                    mode: 'flow',
                    selector: 'div[role=button]',
                }),
                Tabstopping.config({}),
                Replacing.config({}),
                config('elementPathEvents', [
                    runOnAttached(function(comp, e) {
                        editor.shortcuts.add(
                            'alt+F11',
                            'focus statusbar elementpath',
                            function() {
                                return Keying.focusIn(comp);
                            },
                        );
                        editor.on('NodeChange', function(e) {
                            const newPath = updatePath(e.parents);
                            if (newPath.length > 0) {
                                Replacing.set(comp, getDataPath(newPath));
                            }
                        });
                    }),
                ]),
            ]),
            components: [],
        };
    };
    const ElementPath = { renderElementPath };

    const renderWordCount = function(editor, providersBackstage) {
        const replaceCountText = function(comp, count, mode) {
            return Replacing.set(comp, [
                text(
                    providersBackstage.translate([`{0} ${mode}`, count[mode]]),
                ),
            ]);
        };
        return Button.sketch({
            dom: {
                tag: 'button',
                classes: ['tox-statusbar__wordcount'],
            },
            components: [],
            buttonBehaviours: derive$1([
                Tabstopping.config({}),
                Replacing.config({}),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: {
                            mode: 'words',
                            count: {
                                words: 0,
                                characters: 0,
                            },
                        },
                    },
                }),
                config('wordcount-events', [
                    runOnExecute(function(comp) {
                        const currentVal = Representing.getValue(comp);
                        const newMode =
                            currentVal.mode === 'words'
                                ? 'characters'
                                : 'words';
                        Representing.setValue(comp, {
                            mode: newMode,
                            count: currentVal.count,
                        });
                        replaceCountText(comp, currentVal.count, newMode);
                    }),
                    runOnAttached(function(comp) {
                        editor.on('wordCountUpdate', function(e) {
                            const { mode } = Representing.getValue(comp);
                            Representing.setValue(comp, {
                                mode,
                                count: e.wordCount,
                            });
                            replaceCountText(comp, e.wordCount, mode);
                        });
                    }),
                ]),
            ]),
        });
    };

    const renderStatusbar = function(editor, providersBackstage) {
        const renderResizeHandlerIcon = function(resizeType) {
            return {
                dom: {
                    tag: 'div',
                    classes: ['tox-statusbar__resize-handle'],
                    attributes: {
                        title: providersBackstage.translate('Resize'),
                    },
                    innerHtml: get$c('resize-handle', providersBackstage.icons),
                },
                behaviours: derive$1([
                    Dragging.config({
                        mode: 'mouse',
                        repositionTarget: false,
                        onDrag(comp, target, delta) {
                            resize$3(editor, delta, resizeType);
                        },
                        blockerClass: 'tox-blocker',
                    }),
                ]),
            };
        };
        const renderBranding = function() {
            const label = global$5.translate(['Powered by {0}', 'Tiny']);
            const linkHtml = `<a href="https://www.tiny.cloud/?utm_campaign=editor_referral&amp;utm_medium=poweredby&amp;utm_source=tinymce&amp;utm_content=v5" rel="noopener" target="_blank" tabindex="-1" aria-label="${label}">${label}</a>`;
            return {
                dom: {
                    tag: 'span',
                    classes: ['tox-statusbar__branding'],
                    innerHtml: linkHtml,
                },
            };
        };
        const getResizeType = function(editor) {
            const fallback = !contains$1(editor.settings.plugins, 'autoresize');
            const resize = editor.getParam('resize', fallback);
            if (resize === false) {
                return ResizeTypes.None;
            }
            if (resize === 'both') {
                return ResizeTypes.Both;
            }
            return ResizeTypes.Vertical;
        };
        const getTextComponents = function() {
            const components = [];
            if (editor.getParam('elementpath', true, 'boolean')) {
                components.push(ElementPath.renderElementPath(editor, {}));
            }
            if (contains$1(editor.settings.plugins, 'wordcount')) {
                components.push(renderWordCount(editor, providersBackstage));
            }
            if (editor.getParam('branding', true, 'boolean')) {
                components.push(renderBranding());
            }
            if (components.length > 0) {
                return [
                    {
                        dom: {
                            tag: 'div',
                            classes: ['tox-statusbar__text-container'],
                        },
                        components,
                    },
                ];
            }
            return [];
        };
        const getComponents = function() {
            const components = getTextComponents();
            const resizeType = getResizeType(editor);
            if (resizeType !== ResizeTypes.None) {
                components.push(renderResizeHandlerIcon(resizeType));
            }
            return components;
        };
        return {
            dom: {
                tag: 'div',
                classes: ['tox-statusbar'],
            },
            components: getComponents(),
        };
    };

    const setup$c = function(editor) {
        const isInline = editor.inline;
        const mode = isInline ? Inline : Iframe;
        const header = isStickyToolbar(editor) ? StickyHeader : StaticHeader;
        let lazyOuterContainer = Option.none();
        const platform = detect$3();
        const isIE = platform.browser.isIE();
        const platformClasses = isIE ? ['tox-platform-ie'] : [];
        const isTouch = platform.deviceType.isTouch();
        const touchPlatformClass = 'tox-platform-touch';
        const deviceClasses = isTouch ? [touchPlatformClass] : [];
        const dirAttributes = global$5.isRtl()
            ? { attributes: { dir: 'rtl' } }
            : {};
        const lazyHeader = function() {
            return lazyOuterContainer.bind(OuterContainer.getHeader);
        };
        const sink = build$1({
            dom: {
                tag: 'div',
                classes: ['tox', 'tox-silver-sink', 'tox-tinymce-aux']
                    .concat(platformClasses)
                    .concat(deviceClasses),
                ...dirAttributes,
            },
            behaviours: derive$1([
                Positioning.config({
                    useFixed() {
                        return header.isDocked(lazyHeader);
                    },
                }),
            ]),
        });
        const lazySink = function() {
            return Result.value(sink);
        };
        const memAnchorBar = record({
            dom: {
                tag: 'div',
                classes: ['tox-anchorbar'],
            },
        });
        const lazyAnchorBar = function() {
            return lazyOuterContainer
                .bind(function(container) {
                    return memAnchorBar.getOpt(container);
                })
                .getOrDie('Could not find a anchor bar element');
        };
        const lazyMoreButton = function() {
            return lazyOuterContainer
                .bind(function(container) {
                    return OuterContainer.getMoreButton(container);
                })
                .getOrDie('Could not find more button element');
        };
        const lazyToolbar = function() {
            return lazyOuterContainer
                .bind(function(container) {
                    return OuterContainer.getToolbar(container);
                })
                .getOrDie('Could not find more toolbar element');
        };
        const lazyThrobber = function() {
            return lazyOuterContainer
                .bind(function(container) {
                    return OuterContainer.getThrobber(container);
                })
                .getOrDie('Could not find throbber element');
        };
        const backstage = init$8(sink, editor, lazyAnchorBar, lazyMoreButton);
        const partMenubar = OuterContainer.parts().menubar({
            dom: {
                tag: 'div',
                classes: ['tox-menubar'],
            },
            backstage,
            onEscape() {
                editor.focus();
            },
        });
        const toolbarDrawer = getToolbarDrawer(editor);
        const partToolbar = OuterContainer.parts().toolbar({
            dom: {
                tag: 'div',
                classes: ['tox-toolbar'],
            },
            getSink: lazySink,
            backstage,
            onEscape() {
                editor.focus();
            },
            split: toolbarDrawer,
            lazyToolbar,
            lazyMoreButton,
            lazyHeader() {
                return lazyHeader().getOrDie('Could not find header element');
            },
        });
        const partMultipleToolbar = OuterContainer.parts()['multiple-toolbar']({
            dom: {
                tag: 'div',
                classes: ['tox-toolbar-overlord'],
            },
            onEscape() {},
            split: toolbarDrawer,
        });
        const partSocket = OuterContainer.parts().socket({
            dom: {
                tag: 'div',
                classes: ['tox-edit-area'],
            },
        });
        const partSidebar = OuterContainer.parts().sidebar({
            dom: {
                tag: 'div',
                classes: ['tox-sidebar'],
            },
        });
        const partThrobber = OuterContainer.parts().throbber({
            dom: {
                tag: 'div',
                classes: ['tox-throbber'],
            },
            backstage,
        });
        const sb = editor.getParam('statusbar', true, 'boolean');
        const statusbar =
            sb && !isInline
                ? Option.some(
                      renderStatusbar(editor, backstage.shared.providers),
                  )
                : Option.none();
        const socketSidebarContainer = {
            dom: {
                tag: 'div',
                classes: ['tox-sidebar-wrap'],
            },
            components: [partSocket, partSidebar],
        };
        const hasMultipleToolbar = isMultipleToolbars(editor);
        const hasToolbar = isToolbarEnabled(editor);
        const hasMenubar = isMenubarEnabled(editor);
        const getPartToolbar = function() {
            if (hasMultipleToolbar) {
                return [partMultipleToolbar];
            }
            if (hasToolbar) {
                return [partToolbar];
            }
            return [];
        };
        const partHeader = OuterContainer.parts().header({
            dom: {
                tag: 'div',
                classes: ['tox-editor-header'],
            },
            components: flatten([
                hasMenubar ? [partMenubar] : [],
                getPartToolbar(),
                useFixedContainer(editor) ? [] : [memAnchorBar.asSpec()],
            ]),
            sticky: isStickyToolbar(editor),
            editor,
            getSink: lazySink,
        });
        const editorComponents = flatten([
            [partHeader],
            isInline ? [] : [socketSidebarContainer],
        ]);
        const editorContainer = {
            dom: {
                tag: 'div',
                classes: ['tox-editor-container'],
            },
            components: editorComponents,
        };
        const containerComponents = flatten([
            [editorContainer],
            isInline ? [] : statusbar.toArray(),
            [partThrobber],
        ]);
        const isHidden = isDistractionFree(editor);
        const attributes = {
            role: 'application',
            ...(global$5.isRtl() ? { dir: 'rtl' } : {}),
            ...(isHidden ? { 'aria-hidden': 'true' } : {}),
        };
        const outerContainer = build$1(
            OuterContainer.sketch({
                dom: {
                    tag: 'div',
                    classes: ['tox', 'tox-tinymce']
                        .concat(isInline ? ['tox-tinymce-inline'] : [])
                        .concat(deviceClasses)
                        .concat(platformClasses),
                    styles: {
                        visibility: 'hidden',
                        ...(isHidden
                            ? {
                                  opacity: '0',
                                  border: '0',
                              }
                            : {}),
                    },
                    attributes,
                },
                components: containerComponents,
                behaviours: derive$1([
                    Keying.config({
                        mode: 'cyclic',
                        selector:
                            '.tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a',
                    }),
                ]),
            }),
        );
        lazyOuterContainer = Option.some(outerContainer);
        editor.shortcuts.add('alt+F9', 'focus menubar', function() {
            OuterContainer.focusMenubar(outerContainer);
        });
        editor.shortcuts.add('alt+F10', 'focus toolbar', function() {
            OuterContainer.focusToolbar(outerContainer);
        });
        const mothership = takeover(outerContainer);
        const uiMothership = takeover(sink);
        Events$1.setup(editor, mothership, uiMothership);
        TouchEvents.setup(editor);
        const getUi = function() {
            const channels = {
                broadcastAll: uiMothership.broadcast,
                broadcastOn: uiMothership.broadcastOn,
                register() {},
            };
            return { channels };
        };
        const setEditorSize = function() {
            const parsedHeight = Utils.numToPx(getHeightWithFallback(editor));
            const parsedWidth = Utils.numToPx(getWidthWithFallback(editor));
            if (!editor.inline) {
                if (isValidValue('div', 'width', parsedWidth)) {
                    set$2(outerContainer.element(), 'width', parsedWidth);
                }
                if (isValidValue('div', 'height', parsedHeight)) {
                    set$2(outerContainer.element(), 'height', parsedHeight);
                } else {
                    set$2(outerContainer.element(), 'height', '200px');
                }
            }
            return parsedHeight;
        };
        const renderUI = function() {
            header.setup(editor, lazyHeader);
            FormatControls.setup(editor, backstage);
            setup$a(editor, lazySink, backstage);
            setup$7(editor);
            setup$8(editor, lazyThrobber, backstage.shared);
            const _a = editor.ui.registry.getAll();
            const { buttons } = _a;
            const { menuItems } = _a;
            const { contextToolbars } = _a;
            const { sidebars } = _a;
            const toolbarOpt = getMultipleToolbarsSetting(editor);
            const rawUiConfig = {
                menuItems,
                menus: !editor.settings.menu
                    ? {}
                    : map$1(editor.settings.menu, function(menu) {
                          return merge(menu, { items: menu.items });
                      }),
                menubar: editor.settings.menubar,
                toolbar: toolbarOpt.getOrThunk(function() {
                    return editor.getParam('toolbar', true);
                }),
                buttons,
                sidebar: sidebars,
            };
            ContextToolbar.register(editor, contextToolbars, sink, {
                backstage,
            });
            TableSelectorHandles.setup(editor, sink);
            const elm = editor.getElement();
            const height = setEditorSize();
            const uiComponents = {
                mothership,
                uiMothership,
                outerContainer,
            };
            const args = {
                targetNode: elm,
                height,
            };
            return mode.render(
                editor,
                uiComponents,
                rawUiConfig,
                backstage,
                args,
            );
        };
        return {
            mothership,
            uiMothership,
            backstage,
            renderUI,
            getUi,
        };
    };
    const Render = { setup: setup$c };

    const describedBy = function(describedElement, describeElement) {
        const describeId = Option.from(get$2(describedElement, 'id')).fold(
            function() {
                const id = generate$1('dialog-describe');
                set$1(describeElement, 'id', id);
                return id;
            },
            identity,
        );
        set$1(describedElement, 'aria-describedby', describeId);
    };

    const AriaLabel = {
        labelledBy(labelledElement, labelElement) {
            const labelId = Option.from(get$2(labelledElement, 'id')).fold(
                function() {
                    const id = generate$1('dialog-label');
                    set$1(labelElement, 'id', id);
                    return id;
                },
                identity,
            );
            set$1(labelledElement, 'aria-labelledby', labelId);
        },
    };

    const schema$w = constant([
        strict$1('lazySink'),
        option('dragBlockClass'),
        defaultedFunction('getBounds', win),
        defaulted$1('useTabstopAt', constant(true)),
        defaulted$1('eventOrder', {}),
        field$1('modalBehaviours', [Keying]),
        onKeyboardHandler('onExecute'),
        onStrictKeyboardHandler('onEscape'),
    ]);
    const basic = { sketch: identity };
    const parts$e = constant([
        optional({
            name: 'draghandle',
            overrides(detail, spec) {
                return {
                    behaviours: derive$1([
                        Dragging.config({
                            mode: 'mouse',
                            getTarget(handle) {
                                return ancestor$1(
                                    handle,
                                    '[role="dialog"]',
                                ).getOr(handle);
                            },
                            blockerClass: detail.dragBlockClass.getOrDie(
                                new Error(
                                    `The drag blocker class was not specified for a dialog with a drag handle: \n${JSON.stringify(
                                        spec,
                                        null,
                                        2,
                                    )}`,
                                ).message,
                            ),
                            getBounds: detail.getDragBounds,
                        }),
                    ]),
                };
            },
        }),
        required({
            schema: [strict$1('dom')],
            name: 'title',
        }),
        required({
            factory: basic,
            schema: [strict$1('dom')],
            name: 'close',
        }),
        required({
            factory: basic,
            schema: [strict$1('dom')],
            name: 'body',
        }),
        optional({
            factory: basic,
            schema: [strict$1('dom')],
            name: 'footer',
        }),
        external$1({
            factory: {
                sketch(spec, detail) {
                    return {
                        ...spec,
                        dom: detail.dom,
                        components: detail.components,
                    };
                },
            },
            schema: [
                defaulted$1('dom', {
                    tag: 'div',
                    styles: {
                        position: 'fixed',
                        left: '0px',
                        top: '0px',
                        right: '0px',
                        bottom: '0px',
                    },
                }),
                defaulted$1('components', []),
            ],
            name: 'blocker',
        }),
    ]);

    const factory$h = function(detail, components, spec, externals) {
        const dialogBusyEvent = generate$1('alloy.dialog.busy');
        const dialogIdleEvent = generate$1('alloy.dialog.idle');
        const busyBehaviours = derive$1([
            Keying.config({
                mode: 'special',
                onTab() {
                    return Option.some(true);
                },
                onShiftTab() {
                    return Option.some(true);
                },
            }),
            Focusing.config({}),
        ]);
        const showDialog = function(dialog) {
            const sink = detail.lazySink(dialog).getOrDie();
            const busyComp = Cell(Option.none());
            const externalBlocker = externals.blocker();
            const blocker = sink.getSystem().build({
                ...externalBlocker,
                components: externalBlocker.components.concat([
                    premade$1(dialog),
                ]),
                behaviours: derive$1([
                    Focusing.config({}),
                    config('dialog-blocker-events', [
                        runOnSource(focusin(), function() {
                            Keying.focusIn(dialog);
                        }),
                        run(dialogIdleEvent, function(blocker, se) {
                            if (has$1(dialog.element(), 'aria-busy')) {
                                remove$1(dialog.element(), 'aria-busy');
                                busyComp.get().each(function(bc) {
                                    return Replacing.remove(dialog, bc);
                                });
                            }
                        }),
                        run(dialogBusyEvent, function(blocker, se) {
                            set$1(dialog.element(), 'aria-busy', 'true');
                            const getBusySpec = se.event().getBusySpec();
                            busyComp.get().each(function(bc) {
                                Replacing.remove(dialog, bc);
                            });
                            const busySpec = getBusySpec(
                                dialog,
                                busyBehaviours,
                            );
                            const busy = blocker.getSystem().build(busySpec);
                            busyComp.set(Option.some(busy));
                            Replacing.append(dialog, premade$1(busy));
                            if (busy.hasConfigured(Keying)) {
                                Keying.focusIn(busy);
                            }
                        }),
                    ]),
                ]),
            });
            attach$1(sink, blocker);
            Keying.focusIn(dialog);
        };
        const hideDialog = function(dialog) {
            parent(dialog.element()).each(function(blockerDom) {
                dialog
                    .getSystem()
                    .getByDom(blockerDom)
                    .each(function(blocker) {
                        detach(blocker);
                    });
            });
        };
        const getDialogBody = function(dialog) {
            return getPartOrDie(dialog, detail, 'body');
        };
        const getDialogFooter = function(dialog) {
            return getPartOrDie(dialog, detail, 'footer');
        };
        const setBusy = function(dialog, getBusySpec) {
            emitWith(dialog, dialogBusyEvent, { getBusySpec });
        };
        const setIdle = function(dialog) {
            emit(dialog, dialogIdleEvent);
        };
        const modalEventsId = generate$1('modal-events');
        const eventOrder = {
            ...detail.eventOrder,
            'alloy.system.attached': [modalEventsId].concat(
                detail.eventOrder['alloy.system.attached'] || [],
            ),
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            apis: {
                show: showDialog,
                hide: hideDialog,
                getBody: getDialogBody,
                getFooter: getDialogFooter,
                setIdle,
                setBusy,
            },
            eventOrder,
            domModification: {
                attributes: {
                    role: 'dialog',
                    'aria-modal': 'true',
                },
            },
            behaviours: augment(detail.modalBehaviours, [
                Replacing.config({}),
                Keying.config({
                    mode: 'cyclic',
                    onEnter: detail.onExecute,
                    onEscape: detail.onEscape,
                    useTabstopAt: detail.useTabstopAt,
                }),
                config(modalEventsId, [
                    runOnAttached(function(c) {
                        AriaLabel.labelledBy(
                            c.element(),
                            getPartOrDie(c, detail, 'title').element(),
                        );
                        describedBy(
                            c.element(),
                            getPartOrDie(c, detail, 'body').element(),
                        );
                    }),
                ]),
            ]),
        };
    };
    const ModalDialog = composite$1({
        name: 'ModalDialog',
        configFields: schema$w(),
        partFields: parts$e(),
        factory: factory$h,
        apis: {
            show(apis, dialog) {
                apis.show(dialog);
            },
            hide(apis, dialog) {
                apis.hide(dialog);
            },
            getBody(apis, dialog) {
                return apis.getBody(dialog);
            },
            getFooter(apis, dialog) {
                return apis.getFooter(dialog);
            },
            setBusy(apis, dialog, getBusySpec) {
                apis.setBusy(dialog, getBusySpec);
            },
            setIdle(apis, dialog) {
                apis.setIdle(dialog);
            },
        },
    });

    const alertBannerFields = [
        strictString('type'),
        strictString('text'),
        strictStringEnum('level', ['info', 'warn', 'error', 'success']),
        strictString('icon'),
        defaulted$1('url', ''),
    ];
    const alertBannerSchema = objOf(alertBannerFields);

    const createBarFields = function(itemsField) {
        return [strictString('type'), itemsField];
    };

    const buttonFields = [
        strictString('type'),
        strictString('text'),
        defaultedBoolean('disabled', false),
        defaultedBoolean('primary', false),
        field(
            'name',
            'name',
            defaultedThunk(function() {
                return generate$1('button-name');
            }),
            string,
        ),
        optionString('icon'),
        defaultedBoolean('borderless', false),
    ];
    const buttonSchema = objOf(buttonFields);

    const checkboxFields = [
        strictString('type'),
        strictString('name'),
        strictString('label'),
        defaultedBoolean('disabled', false),
    ];
    const checkboxSchema = objOf(checkboxFields);
    const checkboxDataProcessor = boolean;

    const formComponentFields = [strictString('type'), strictString('name')];
    const formComponentWithLabelFields = formComponentFields.concat([
        optionString('label'),
    ]);

    const colorInputFields = formComponentWithLabelFields;
    const colorInputSchema = objOf(colorInputFields);
    const colorInputDataProcessor = string;

    const colorPickerFields = formComponentWithLabelFields;
    const colorPickerSchema = objOf(colorPickerFields);
    const colorPickerDataProcessor = string;

    const dropZoneFields = formComponentWithLabelFields;
    const dropZoneSchema = objOf(dropZoneFields);
    const dropZoneDataProcessor = arrOfVal();

    const createGridFields = function(itemsField) {
        return [strictString('type'), strictNumber('columns'), itemsField];
    };

    const iframeFields = formComponentWithLabelFields.concat([
        defaultedBoolean('sandboxed', true),
    ]);
    const iframeSchema = objOf(iframeFields);
    const iframeDataProcessor = string;

    const inputFields = formComponentWithLabelFields.concat([
        optionString('inputMode'),
        optionString('placeholder'),
        defaultedBoolean('maximized', false),
        defaultedBoolean('disabled', false),
    ]);
    const inputSchema = objOf(inputFields);
    const inputDataProcessor = string;

    const selectBoxFields = formComponentWithLabelFields.concat([
        strictArrayOfObj('items', [
            strictString('text'),
            strictString('value'),
        ]),
        defaultedNumber('size', 1),
        defaultedBoolean('disabled', false),
    ]);
    const selectBoxSchema = objOf(selectBoxFields);
    const selectBoxDataProcessor = string;

    const sizeInputFields = formComponentWithLabelFields.concat([
        defaultedBoolean('constrain', true),
        defaultedBoolean('disabled', false),
    ]);
    const sizeInputSchema = objOf(sizeInputFields);
    const sizeInputDataProcessor = objOf([
        strictString('width'),
        strictString('height'),
    ]);

    const textAreaFields = formComponentWithLabelFields.concat([
        optionString('placeholder'),
        defaultedBoolean('maximized', false),
        defaultedBoolean('disabled', false),
    ]);
    const textAreaSchema = objOf(textAreaFields);
    const textAreaDataProcessor = string;

    const urlInputFields = formComponentWithLabelFields.concat([
        defaultedStringEnum('filetype', 'file', ['image', 'media', 'file']),
        defaulted$1('disabled', false),
    ]);
    const urlInputSchema = objOf(urlInputFields);
    const urlInputDataProcessor = objOf([
        strictString('value'),
        defaulted$1('meta', {}),
    ]);

    const customEditorFields = formComponentFields.concat([
        defaultedString('tag', 'textarea'),
        strictString('scriptId'),
        strictString('scriptUrl'),
        defaultedPostMsg('settings', undefined),
    ]);
    const customEditorFieldsOld = formComponentFields.concat([
        defaultedString('tag', 'textarea'),
        strictFunction('init'),
    ]);
    const customEditorSchema = valueOf(function(v) {
        return asRaw(
            'customeditor.old',
            objOfOnly(customEditorFieldsOld),
            v,
        ).orThunk(function() {
            return asRaw('customeditor.new', objOfOnly(customEditorFields), v);
        });
    });
    const customEditorDataProcessor = string;

    const htmlPanelFields = [
        strictString('type'),
        strictString('html'),
        defaultedStringEnum('presets', 'presentation', [
            'presentation',
            'document',
        ]),
    ];
    const htmlPanelSchema = objOf(htmlPanelFields);

    const imageToolsFields = formComponentWithLabelFields.concat([
        strictOf(
            'currentState',
            objOf([strict$1('blob'), strictString('url')]),
        ),
    ]);
    const imageToolsSchema = objOf(imageToolsFields);

    const collectionFields = formComponentWithLabelFields.concat([
        defaulted$1('columns', 'auto'),
    ]);
    const collectionSchema = objOf(collectionFields);
    const collectionDataProcessor = arrOfObj$1([
        strictString('value'),
        strictString('text'),
        strictString('icon'),
    ]);

    const createLabelFields = function(itemsField) {
        return [strictString('type'), strictString('label'), itemsField];
    };

    const tableFields = [
        strictString('type'),
        strictArrayOf('header', string),
        strictArrayOf('cells', arrOf(string)),
    ];
    const tableSchema = objOf(tableFields);

    const createItemsField = function(name) {
        return field(
            'items',
            'items',
            strict(),
            arrOf(
                valueOf(function(v) {
                    return asRaw(
                        `Checking item of ${name}`,
                        itemSchema$2,
                        v,
                    ).fold(
                        function(sErr) {
                            return Result.error(formatError(sErr));
                        },
                        function(passValue) {
                            return Result.value(passValue);
                        },
                    );
                }),
            ),
        );
    };
    var itemSchema$2 = valueThunkOf(function() {
        return chooseProcessor('type', {
            alertbanner: alertBannerSchema,
            bar: objOf(createBarFields(createItemsField('bar'))),
            button: buttonSchema,
            checkbox: checkboxSchema,
            colorinput: colorInputSchema,
            colorpicker: colorPickerSchema,
            dropzone: dropZoneSchema,
            grid: objOf(createGridFields(createItemsField('grid'))),
            iframe: iframeSchema,
            input: inputSchema,
            selectbox: selectBoxSchema,
            sizeinput: sizeInputSchema,
            textarea: textAreaSchema,
            urlinput: urlInputSchema,
            customeditor: customEditorSchema,
            htmlpanel: htmlPanelSchema,
            imagetools: imageToolsSchema,
            collection: collectionSchema,
            label: objOf(createLabelFields(createItemsField('label'))),
            table: tableSchema,
            panel: panelSchema,
        });
    });
    const panelFields = [
        strictString('type'),
        defaulted$1('classes', []),
        strictArrayOf('items', itemSchema$2),
    ];
    var panelSchema = objOf(panelFields);

    const tabFields = [
        field(
            'name',
            'name',
            defaultedThunk(function() {
                return generate$1('tab-name');
            }),
            string,
        ),
        strictString('title'),
        strictArrayOf('items', itemSchema$2),
    ];
    const tabPanelFields = [
        strictString('type'),
        strictArrayOfObj('tabs', tabFields),
    ];
    const tabPanelSchema = objOf(tabPanelFields);

    const dialogToggleMenuItemSchema = objOf(
        [
            strictString('type'),
            strictString('name'),
            defaultedBoolean('active', false),
        ].concat(commonMenuItemFields),
    );
    const dialogToggleMenuItemDataProcessor = boolean;

    const baseButtonFields = [
        field(
            'name',
            'name',
            defaultedThunk(function() {
                return generate$1('button-name');
            }),
            string,
        ),
        optionString('icon'),
        defaultedStringEnum('align', 'end', ['start', 'end']),
        defaultedBoolean('primary', false),
        defaultedBoolean('disabled', false),
    ];
    const dialogButtonFields = __spreadArrays(baseButtonFields, [
        strictString('text'),
    ]);
    const normalButtonFields = __spreadArrays(
        [strictStringEnum('type', ['submit', 'cancel', 'custom'])],
        dialogButtonFields,
    );
    const menuButtonFields = __spreadArrays(
        [
            strictStringEnum('type', ['menu']),
            optionString('text'),
            optionString('tooltip'),
            optionString('icon'),
            strictArrayOf('items', dialogToggleMenuItemSchema),
            defaultedFunction('onSetup', function() {
                return noop;
            }),
        ],
        baseButtonFields,
    );
    const dialogButtonSchema = choose$1('type', {
        submit: normalButtonFields,
        cancel: normalButtonFields,
        custom: normalButtonFields,
        menu: menuButtonFields,
    });

    const dialogButtonFields$1 = dialogButtonFields;
    const dialogButtonSchema$1 = dialogButtonSchema;
    const dialogSchema = objOf([
        strictString('title'),
        strictOf(
            'body',
            chooseProcessor('type', {
                panel: panelSchema,
                tabpanel: tabPanelSchema,
            }),
        ),
        defaultedString('size', 'normal'),
        strictArrayOf('buttons', dialogButtonSchema$1),
        defaulted$1('initialData', {}),
        defaultedFunction('onAction', noop),
        defaultedFunction('onChange', noop),
        defaultedFunction('onSubmit', noop),
        defaultedFunction('onClose', noop),
        defaultedFunction('onCancel', noop),
        defaulted$1('onTabChange', noop),
    ]);
    const createDialog = function(spec) {
        return asRaw('dialog', dialogSchema, spec);
    };

    var getAllObjects = function(obj) {
        if (isObject(obj)) {
            return [obj].concat(bind(values(obj), getAllObjects));
        }
        if (isArray(obj)) {
            return bind(obj, getAllObjects);
        }
        return [];
    };

    const isNamedItem = function(obj) {
        return isString(obj.type) && isString(obj.name);
    };
    const dataProcessors = {
        checkbox: checkboxDataProcessor,
        colorinput: colorInputDataProcessor,
        colorpicker: colorPickerDataProcessor,
        dropzone: dropZoneDataProcessor,
        input: inputDataProcessor,
        iframe: iframeDataProcessor,
        sizeinput: sizeInputDataProcessor,
        selectbox: selectBoxDataProcessor,
        size: sizeInputDataProcessor,
        textarea: textAreaDataProcessor,
        urlinput: urlInputDataProcessor,
        customeditor: customEditorDataProcessor,
        collection: collectionDataProcessor,
        togglemenuitem: dialogToggleMenuItemDataProcessor,
    };
    const getDataProcessor = function(item) {
        return Option.from(dataProcessors[item.type]);
    };
    const getNamedItems = function(structure) {
        return filter(getAllObjects(structure), isNamedItem);
    };

    const createDataValidator = function(structure) {
        const namedItems = getNamedItems(structure);
        const fields = bind(namedItems, function(item) {
            return getDataProcessor(item).fold(
                function() {
                    return [];
                },
                function(schema) {
                    return [strictOf(item.name, schema)];
                },
            );
        });
        return objOf(fields);
    };

    const urlDialogButtonSchema = objOf(
        __spreadArrays(
            [strictStringEnum('type', ['cancel', 'custom'])],
            dialogButtonFields$1,
        ),
    );
    const urlDialogSchema = objOf([
        strictString('title'),
        strictString('url'),
        optionNumber('height'),
        optionNumber('width'),
        optionArrayOf('buttons', urlDialogButtonSchema),
        defaultedFunction('onAction', noop),
        defaultedFunction('onCancel', noop),
        defaultedFunction('onClose', noop),
        defaultedFunction('onMessage', noop),
    ]);
    const createUrlDialog = function(spec) {
        return asRaw('dialog', urlDialogSchema, spec);
    };

    const extract$1 = function(structure) {
        const internalDialog = getOrDie(createDialog(structure));
        const dataValidator = createDataValidator(structure);
        const { initialData } = structure;
        return {
            internalDialog,
            dataValidator,
            initialData,
        };
    };
    const DialogManager = {
        open(factory, structure) {
            const extraction = extract$1(structure);
            return factory(
                extraction.internalDialog,
                extraction.initialData,
                extraction.dataValidator,
            );
        },
        openUrl(factory, structure) {
            const internalDialog = getOrDie(createUrlDialog(structure));
            return factory(internalDialog);
        },
        redial(structure) {
            return extract$1(structure);
        },
    };

    const value$3 = function() {
        const subject = Cell(Option.none());
        const clear = function() {
            subject.set(Option.none());
        };
        const set = function(s) {
            subject.set(Option.some(s));
        };
        const on = function(f) {
            subject.get().each(f);
        };
        const isSet = function() {
            return subject.get().isSome();
        };
        return {
            clear,
            set,
            isSet,
            on,
        };
    };

    const toValidValues = function(values) {
        const errors = [];
        const result = {};
        each$1(values, function(value, name) {
            value.fold(
                function() {
                    errors.push(name);
                },
                function(v) {
                    result[name] = v;
                },
            );
        });
        return errors.length > 0 ? Result.error(errors) : Result.value(result);
    };

    const renderBodyPanel = function(spec, backstage) {
        const memForm = record(
            Form.sketch(function(parts) {
                return {
                    dom: {
                        tag: 'div',
                        classes: ['tox-form'].concat(spec.classes),
                    },
                    components: map(spec.items, function(item) {
                        return interpretInForm(parts, item, backstage);
                    }),
                };
            }),
        );
        return {
            dom: {
                tag: 'div',
                classes: ['tox-dialog__body'],
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-dialog__body-content'],
                    },
                    components: [memForm.asSpec()],
                },
            ],
            behaviours: derive$1([
                Keying.config({
                    mode: 'acyclic',
                    useTabstopAt: not(NavigableObject.isPseudoStop),
                }),
                ComposingConfigs.memento(memForm),
                RepresentingConfigs.memento(memForm, {
                    postprocess(formValue) {
                        return toValidValues(formValue).fold(
                            function(err) {
                                domGlobals.console.error(err);
                                return {};
                            },
                            function(vals) {
                                return vals;
                            },
                        );
                    },
                }),
            ]),
        };
    };

    const factory$i = function(detail, spec) {
        return {
            uid: detail.uid,
            dom: detail.dom,
            components: detail.components,
            events: events$7(detail.action),
            behaviours: augment(detail.tabButtonBehaviours, [
                Focusing.config({}),
                Keying.config({
                    mode: 'execution',
                    useSpace: true,
                    useEnter: true,
                }),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: detail.value,
                    },
                }),
            ]),
            domModification: detail.domModification,
        };
    };
    const TabButton = single$2({
        name: 'TabButton',
        configFields: [
            defaulted$1('uid', undefined),
            strict$1('value'),
            field(
                'dom',
                'dom',
                mergeWithThunk(function(spec) {
                    return {
                        attributes: {
                            role: 'tab',
                            id: generate$1('aria'),
                            'aria-selected': 'false',
                        },
                    };
                }),
                anyValue$1(),
            ),
            option('action'),
            defaulted$1('domModification', {}),
            field$1('tabButtonBehaviours', [Focusing, Keying, Representing]),
            strict$1('view'),
        ],
        factory: factory$i,
    });

    const schema$x = constant([
        strict$1('tabs'),
        strict$1('dom'),
        defaulted$1('clickToDismiss', false),
        field$1('tabbarBehaviours', [Highlighting, Keying]),
        markers(['tabClass', 'selectedClass']),
    ]);
    const tabsPart = group({
        factory: TabButton,
        name: 'tabs',
        unit: 'tab',
        overrides(barDetail, tabSpec) {
            const dismissTab$1 = function(tabbar, button) {
                Highlighting.dehighlight(tabbar, button);
                emitWith(tabbar, dismissTab(), {
                    tabbar,
                    button,
                });
            };
            const changeTab$1 = function(tabbar, button) {
                Highlighting.highlight(tabbar, button);
                emitWith(tabbar, changeTab(), {
                    tabbar,
                    button,
                });
            };
            return {
                action(button) {
                    const tabbar = button
                        .getSystem()
                        .getByUid(barDetail.uid)
                        .getOrDie();
                    const activeButton = Highlighting.isHighlighted(
                        tabbar,
                        button,
                    );
                    const response = (function() {
                        if (activeButton && barDetail.clickToDismiss) {
                            return dismissTab$1;
                        }
                        if (!activeButton) {
                            return changeTab$1;
                        }
                        return noop;
                    })();
                    response(tabbar, button);
                },
                domModification: { classes: [barDetail.markers.tabClass] },
            };
        },
    });
    const parts$f = constant([tabsPart]);

    const factory$j = function(detail, components, spec, externals) {
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            'debug.sketcher': 'Tabbar',
            domModification: { attributes: { role: 'tablist' } },
            behaviours: augment(detail.tabbarBehaviours, [
                Highlighting.config({
                    highlightClass: detail.markers.selectedClass,
                    itemClass: detail.markers.tabClass,
                    onHighlight(tabbar, tab) {
                        set$1(tab.element(), 'aria-selected', 'true');
                    },
                    onDehighlight(tabbar, tab) {
                        set$1(tab.element(), 'aria-selected', 'false');
                    },
                }),
                Keying.config({
                    mode: 'flow',
                    getInitial(tabbar) {
                        return Highlighting.getHighlighted(tabbar).map(function(
                            tab,
                        ) {
                            return tab.element();
                        });
                    },
                    selector: `.${detail.markers.tabClass}`,
                    executeOnMove: true,
                }),
            ]),
        };
    };
    const Tabbar = composite$1({
        name: 'Tabbar',
        configFields: schema$x(),
        partFields: parts$f(),
        factory: factory$j,
    });

    const factory$k = function(detail, spec) {
        return {
            uid: detail.uid,
            dom: detail.dom,
            behaviours: augment(detail.tabviewBehaviours, [
                Replacing.config({}),
            ]),
            domModification: { attributes: { role: 'tabpanel' } },
        };
    };
    const Tabview = single$2({
        name: 'Tabview',
        configFields: [field$1('tabviewBehaviours', [Replacing])],
        factory: factory$k,
    });

    const schema$y = constant([
        defaulted$1('selectFirst', true),
        onHandler('onChangeTab'),
        onHandler('onDismissTab'),
        defaulted$1('tabs', []),
        field$1('tabSectionBehaviours', []),
    ]);
    const barPart = required({
        factory: Tabbar,
        schema: [
            strict$1('dom'),
            strictObjOf('markers', [
                strict$1('tabClass'),
                strict$1('selectedClass'),
            ]),
        ],
        name: 'tabbar',
        defaults(detail) {
            return { tabs: detail.tabs };
        },
    });
    const viewPart = required({
        factory: Tabview,
        name: 'tabview',
    });
    const parts$g = constant([barPart, viewPart]);

    const factory$l = function(detail, components, spec, externals) {
        const changeTab$1 = function(button) {
            const tabValue = Representing.getValue(button);
            getPart(button, detail, 'tabview').each(function(tabview) {
                const tabWithValue = find(detail.tabs, function(t) {
                    return t.value === tabValue;
                });
                tabWithValue.each(function(tabData) {
                    const panel = tabData.view();
                    set$1(
                        tabview.element(),
                        'aria-labelledby',
                        get$2(button.element(), 'id'),
                    );
                    Replacing.set(tabview, panel);
                    detail.onChangeTab(tabview, button, panel);
                });
            });
        };
        const changeTabBy = function(section, byPred) {
            getPart(section, detail, 'tabbar').each(function(tabbar) {
                byPred(tabbar).each(emitExecute);
            });
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: get$b(detail.tabSectionBehaviours),
            events: derive(
                flatten([
                    detail.selectFirst
                        ? [
                              runOnAttached(function(section, simulatedEvent) {
                                  changeTabBy(section, Highlighting.getFirst);
                              }),
                          ]
                        : [],
                    [
                        run(changeTab(), function(section, simulatedEvent) {
                            const button = simulatedEvent.event().button();
                            changeTab$1(button);
                        }),
                        run(dismissTab(), function(section, simulatedEvent) {
                            const button = simulatedEvent.event().button();
                            detail.onDismissTab(section, button);
                        }),
                    ],
                ]),
            ),
            apis: {
                getViewItems(section) {
                    return getPart(section, detail, 'tabview')
                        .map(function(tabview) {
                            return Replacing.contents(tabview);
                        })
                        .getOr([]);
                },
                showTab(section, tabKey) {
                    const getTabIfNotActive = function(tabbar) {
                        const candidates = Highlighting.getCandidates(tabbar);
                        const optTab = find(candidates, function(c) {
                            return Representing.getValue(c) === tabKey;
                        });
                        return optTab.filter(function(tab) {
                            return !Highlighting.isHighlighted(tabbar, tab);
                        });
                    };
                    changeTabBy(section, getTabIfNotActive);
                },
            },
        };
    };
    const TabSection = composite$1({
        name: 'TabSection',
        configFields: schema$y(),
        partFields: parts$g(),
        factory: factory$l,
        apis: {
            getViewItems(apis, component) {
                return apis.getViewItems(component);
            },
            showTab(apis, component, tabKey) {
                apis.showTab(component, tabKey);
            },
        },
    });

    const measureHeights = function(allTabs, tabview, tabviewComp) {
        return map(allTabs, function(tab, i) {
            Replacing.set(tabviewComp, allTabs[i].view());
            const rect = tabview.dom().getBoundingClientRect();
            Replacing.set(tabviewComp, []);
            return rect.height;
        });
    };
    const getMaxHeight = function(heights) {
        return head(
            sort(heights, function(a, b) {
                if (a > b) {
                    return -1;
                }
                if (a < b) {
                    return +1;
                }
                return 0;
            }),
        );
    };
    const getMaxTabviewHeight = function(dialog, tabview, tablist) {
        const documentElement$1 = documentElement(dialog).dom();
        const rootElm = ancestor$1(dialog, '.tox-dialog-wrap').getOr(dialog);
        const isFixed = get$4(rootElm, 'position') === 'fixed';
        let maxHeight;
        if (isFixed) {
            maxHeight = Math.max(
                documentElement$1.clientHeight,
                domGlobals.window.innerHeight,
            );
        } else {
            maxHeight = Math.max(
                documentElement$1.offsetHeight,
                documentElement$1.scrollHeight,
            );
        }
        const tabviewHeight = get$6(tabview);
        const isTabListBeside =
            tabview.dom().offsetLeft >=
            tablist.dom().offsetLeft + get$7(tablist);
        const currentTabHeight = isTabListBeside
            ? Math.max(get$6(tablist), tabviewHeight)
            : tabviewHeight;
        const dialogTopMargin = parseInt(get$4(dialog, 'margin-top'), 10) || 0;
        const dialogBottomMargin =
            parseInt(get$4(dialog, 'margin-bottom'), 10) || 0;
        const dialogHeight =
            get$6(dialog) + dialogTopMargin + dialogBottomMargin;
        const chromeHeight = dialogHeight - currentTabHeight;
        return maxHeight - chromeHeight;
    };
    const showTab = function(allTabs, comp) {
        head(allTabs).each(function(tab) {
            return TabSection.showTab(comp, tab.value);
        });
    };
    const setTabviewHeight = function(tabview, height) {
        set$2(tabview, 'height', `${height}px`);
        if (!detect$3().browser.isIE()) {
            set$2(tabview, 'flex-basis', `${height}px`);
        } else {
            remove$6(tabview, 'flex-basis');
        }
    };
    const updateTabviewHeight = function(dialogBody, tabview, maxTabHeight) {
        ancestor$1(dialogBody, '[role="dialog"]').each(function(dialog) {
            descendant$1(dialog, '[role="tablist"]').each(function(tablist) {
                maxTabHeight
                    .get()
                    .map(function(height) {
                        set$2(tabview, 'height', '0');
                        set$2(tabview, 'flex-basis', '0');
                        return Math.min(
                            height,
                            getMaxTabviewHeight(dialog, tabview, tablist),
                        );
                    })
                    .each(function(height) {
                        setTabviewHeight(tabview, height);
                    });
            });
        });
    };
    const getTabview = function(dialog) {
        return descendant$1(dialog, '[role="tabpanel"]');
    };
    const setMode = function(allTabs) {
        const smartTabHeight = (function() {
            const maxTabHeight = Cell(Option.none());
            const extraEvents = [
                runOnAttached(function(comp) {
                    const dialog = comp.element();
                    getTabview(dialog).each(function(tabview) {
                        set$2(tabview, 'visibility', 'hidden');
                        comp.getSystem()
                            .getByDom(tabview)
                            .toOption()
                            .each(function(tabviewComp) {
                                const heights = measureHeights(
                                    allTabs,
                                    tabview,
                                    tabviewComp,
                                );
                                const maxTabHeightOpt = getMaxHeight(heights);
                                maxTabHeight.set(maxTabHeightOpt);
                            });
                        updateTabviewHeight(dialog, tabview, maxTabHeight);
                        remove$6(tabview, 'visibility');
                        showTab(allTabs, comp);
                        global$2.requestAnimationFrame(function() {
                            updateTabviewHeight(dialog, tabview, maxTabHeight);
                        });
                    });
                }),
                run(windowResize(), function(comp) {
                    const dialog = comp.element();
                    getTabview(dialog).each(function(tabview) {
                        updateTabviewHeight(dialog, tabview, maxTabHeight);
                    });
                }),
                run(formResizeEvent, function(comp, se) {
                    const dialog = comp.element();
                    getTabview(dialog).each(function(tabview) {
                        const oldFocus = active();
                        set$2(tabview, 'visibility', 'hidden');
                        const oldHeight = getRaw(tabview, 'height').map(
                            function(h) {
                                return parseInt(h, 10);
                            },
                        );
                        remove$6(tabview, 'height');
                        remove$6(tabview, 'flex-basis');
                        const newHeight = tabview.dom().getBoundingClientRect()
                            .height;
                        const hasGrown = oldHeight.forall(function(h) {
                            return newHeight > h;
                        });
                        if (hasGrown) {
                            maxTabHeight.set(Option.from(newHeight));
                            updateTabviewHeight(dialog, tabview, maxTabHeight);
                        } else {
                            oldHeight.each(function(h) {
                                setTabviewHeight(tabview, h);
                            });
                        }
                        remove$6(tabview, 'visibility');
                        oldFocus.each(focus$1);
                    });
                }),
            ];
            const selectFirst = false;
            return {
                extraEvents,
                selectFirst,
            };
        })();
        const naiveTabHeight = (function() {
            const extraEvents = [];
            const selectFirst = true;
            return {
                extraEvents,
                selectFirst,
            };
        })();
        return {
            smartTabHeight,
            naiveTabHeight,
        };
    };

    const SendDataToSectionChannel = 'send-data-to-section';
    const SendDataToViewChannel = 'send-data-to-view';
    const renderTabPanel = function(spec, backstage) {
        const storedValue = Cell({});
        const updateDataWithForm = function(form) {
            const formData = Representing.getValue(form);
            const validData = toValidValues(formData).getOr({});
            const currentData = storedValue.get();
            const newData = deepMerge(currentData, validData);
            storedValue.set(newData);
        };
        const setDataOnForm = function(form) {
            const tabData = storedValue.get();
            Representing.setValue(form, tabData);
        };
        const oldTab = Cell(null);
        const allTabs = map(spec.tabs, function(tab) {
            return {
                value: tab.name,
                dom: {
                    tag: 'div',
                    classes: ['tox-dialog__body-nav-item'],
                    innerHtml: backstage.shared.providers.translate(tab.title),
                },
                view() {
                    return [
                        Form.sketch(function(parts) {
                            return {
                                dom: {
                                    tag: 'div',
                                    classes: ['tox-form'],
                                },
                                components: map(tab.items, function(item) {
                                    return interpretInForm(
                                        parts,
                                        item,
                                        backstage,
                                    );
                                }),
                                formBehaviours: derive$1([
                                    Keying.config({
                                        mode: 'acyclic',
                                        useTabstopAt: not(
                                            NavigableObject.isPseudoStop,
                                        ),
                                    }),
                                    config('TabView.form.events', [
                                        runOnAttached(setDataOnForm),
                                        runOnDetached(updateDataWithForm),
                                    ]),
                                    Receiving.config({
                                        channels: wrapAll$1([
                                            {
                                                key: SendDataToSectionChannel,
                                                value: {
                                                    onReceive: updateDataWithForm,
                                                },
                                            },
                                            {
                                                key: SendDataToViewChannel,
                                                value: {
                                                    onReceive: setDataOnForm,
                                                },
                                            },
                                        ]),
                                    }),
                                ]),
                            };
                        }),
                    ];
                },
            };
        });
        const tabMode = setMode(allTabs).smartTabHeight;
        return TabSection.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-dialog__body'],
            },
            onChangeTab(section, button, _viewItems) {
                const name = Representing.getValue(button);
                emitWith(section, formTabChangeEvent, {
                    name,
                    oldName: oldTab.get(),
                });
                oldTab.set(name);
            },
            tabs: allTabs,
            components: [
                TabSection.parts().tabbar({
                    dom: {
                        tag: 'div',
                        classes: ['tox-dialog__body-nav'],
                    },
                    components: [Tabbar.parts().tabs({})],
                    markers: {
                        tabClass: 'tox-tab',
                        selectedClass: 'tox-dialog__body-nav-item--active',
                    },
                    tabbarBehaviours: derive$1([Tabstopping.config({})]),
                }),
                TabSection.parts().tabview({
                    dom: {
                        tag: 'div',
                        classes: ['tox-dialog__body-content'],
                    },
                }),
            ],
            selectFirst: tabMode.selectFirst,
            tabSectionBehaviours: derive$1([
                config('tabpanel', tabMode.extraEvents),
                Keying.config({ mode: 'acyclic' }),
                Composing.config({
                    find(comp) {
                        return head(TabSection.getViewItems(comp));
                    },
                }),
                Representing.config({
                    store: {
                        mode: 'manual',
                        getValue(tsection) {
                            tsection
                                .getSystem()
                                .broadcastOn([SendDataToSectionChannel], {});
                            return storedValue.get();
                        },
                        setValue(tsection, value) {
                            storedValue.set(value);
                            tsection
                                .getSystem()
                                .broadcastOn([SendDataToViewChannel], {});
                        },
                    },
                }),
            ]),
        });
    };

    const dialogChannel = generate$1('update-dialog');
    const titleChannel = generate$1('update-title');
    const bodyChannel = generate$1('update-body');
    const footerChannel = generate$1('update-footer');
    const bodySendMessageChannel = generate$1('body-send-message');

    const renderBody = function(spec, id, backstage, ariaAttrs) {
        const renderComponents = function(incoming) {
            switch (incoming.body.type) {
                case 'tabpanel': {
                    return [renderTabPanel(incoming.body, backstage)];
                }
                default: {
                    return [renderBodyPanel(incoming.body, backstage)];
                }
            }
        };
        const updateState = function(_comp, incoming) {
            return Option.some({
                isTabPanel() {
                    return incoming.body.type === 'tabpanel';
                },
            });
        };
        const ariaAttributes = { 'aria-live': 'polite' };
        return {
            dom: {
                tag: 'div',
                classes: ['tox-dialog__content-js'],
                attributes: {
                    ...id
                        .map(function(x) {
                            return { id: x };
                        })
                        .getOr({}),
                    ...(ariaAttrs ? ariaAttributes : {}),
                },
            },
            components: [],
            behaviours: derive$1([
                ComposingConfigs.childAt(0),
                Reflecting.config({
                    channel: bodyChannel,
                    updateState,
                    renderComponents,
                    initialData: spec,
                }),
            ]),
        };
    };
    const renderInlineBody = function(spec, contentId, backstage, ariaAttrs) {
        return renderBody(spec, Option.some(contentId), backstage, ariaAttrs);
    };
    const renderModalBody = function(spec, backstage) {
        const bodySpec = renderBody(spec, Option.none(), backstage, false);
        return ModalDialog.parts().body(bodySpec);
    };
    const renderIframeBody = function(spec) {
        const bodySpec = {
            dom: {
                tag: 'div',
                classes: ['tox-dialog__content-js'],
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-dialog__body-iframe'],
                    },
                    components: [
                        NavigableObject.craft({
                            dom: {
                                tag: 'iframe',
                                attributes: { src: spec.url },
                            },
                            behaviours: derive$1([
                                Tabstopping.config({}),
                                Focusing.config({}),
                            ]),
                        }),
                    ],
                },
            ],
            behaviours: derive$1([
                Keying.config({
                    mode: 'acyclic',
                    useTabstopAt: not(NavigableObject.isPseudoStop),
                }),
            ]),
        };
        return ModalDialog.parts().body(bodySpec);
    };

    const initCommonEvents = function(fireApiEvent, extras) {
        return [
            runWithTarget(focusin(), NavigableObject.onFocus),
            fireApiEvent(formCloseEvent, function(api, spec) {
                extras.onClose();
                spec.onClose();
            }),
            fireApiEvent(formCancelEvent, function(api, spec, _event, self) {
                spec.onCancel(api);
                emit(self, formCloseEvent);
            }),
            run(formUnblockEvent, function(c, se) {
                return extras.onUnblock();
            }),
            run(formBlockEvent, function(c, se) {
                return extras.onBlock(se.event());
            }),
        ];
    };
    const initUrlDialog = function(getInstanceApi, extras) {
        const fireApiEvent = function(eventName, f) {
            return run(eventName, function(c, se) {
                withSpec(c, function(spec, _c) {
                    f(getInstanceApi(), spec, se.event(), c);
                });
            });
        };
        var withSpec = function(c, f) {
            Reflecting.getState(c)
                .get()
                .each(function(currentDialog) {
                    f(currentDialog, c);
                });
        };
        return __spreadArrays(initCommonEvents(fireApiEvent, extras), [
            fireApiEvent(formActionEvent, function(api, spec, event) {
                spec.onAction(api, { name: event.name() });
            }),
        ]);
    };
    const initDialog = function(getInstanceApi, extras) {
        const fireApiEvent = function(eventName, f) {
            return run(eventName, function(c, se) {
                withSpec(c, function(spec, _c) {
                    f(getInstanceApi(), spec, se.event(), c);
                });
            });
        };
        var withSpec = function(c, f) {
            Reflecting.getState(c)
                .get()
                .each(function(currentDialogInit) {
                    f(currentDialogInit.internalDialog, c);
                });
        };
        return __spreadArrays(initCommonEvents(fireApiEvent, extras), [
            fireApiEvent(formSubmitEvent, function(api, spec) {
                return spec.onSubmit(api);
            }),
            fireApiEvent(formChangeEvent, function(api, spec, event) {
                spec.onChange(api, { name: event.name() });
            }),
            fireApiEvent(formActionEvent, function(
                api,
                spec,
                event,
                component,
            ) {
                const focusIn = function() {
                    return Keying.focusIn(component);
                };
                const current = active();
                spec.onAction(api, {
                    name: event.name(),
                    value: event.value(),
                });
                active().fold(
                    function() {
                        focusIn();
                    },
                    function(focused) {
                        if (
                            !contains$2(component.element(), focused) ||
                            has$1(focused, 'disabled')
                        ) {
                            focusIn();
                        } else if (
                            contains$2(focused, current.getOrNull()) &&
                            has$1(current.getOrDie(), 'disabled')
                        ) {
                            focusIn();
                        }
                    },
                );
            }),
            fireApiEvent(formTabChangeEvent, function(api, spec, event) {
                spec.onTabChange(api, {
                    newTabName: event.name(),
                    oldTabName: event.oldName(),
                });
            }),
            runOnDetached(function(component) {
                const api = getInstanceApi();
                Representing.setValue(component, api.getData());
            }),
        ]);
    };
    const SilverDialogEvents = {
        initUrlDialog,
        initDialog,
    };

    const makeButton = function(button, backstage) {
        return renderFooterButton(button, button.type, backstage);
    };
    const lookup$2 = function(compInSystem, footerButtons, buttonName) {
        return find(footerButtons, function(button) {
            return button.name === buttonName;
        }).bind(function(memButton) {
            return memButton.memento.getOpt(compInSystem);
        });
    };
    const renderComponents = function(_data, state) {
        const footerButtons = state
            .map(function(s) {
                return s.footerButtons;
            })
            .getOr([]);
        const buttonGroups = partition(footerButtons, function(button) {
            return button.align === 'start';
        });
        const makeGroup = function(edge, buttons) {
            return Container.sketch({
                dom: {
                    tag: 'div',
                    classes: [`tox-dialog__footer-${edge}`],
                },
                components: map(buttons, function(button) {
                    return button.memento.asSpec();
                }),
            });
        };
        const startButtons = makeGroup('start', buttonGroups.pass);
        const endButtons = makeGroup('end', buttonGroups.fail);
        return [startButtons, endButtons];
    };
    const renderFooter = function(initSpec, backstage) {
        const updateState = function(_comp, data) {
            const footerButtons = map(data.buttons, function(button) {
                const memButton = record(makeButton(button, backstage));
                return {
                    name: button.name,
                    align: button.align,
                    memento: memButton,
                };
            });
            const lookupByName = function(compInSystem, buttonName) {
                return lookup$2(compInSystem, footerButtons, buttonName);
            };
            return Option.some({
                lookupByName,
                footerButtons,
            });
        };
        return {
            dom: fromHtml$2('<div class="tox-dialog__footer"></div>'),
            components: [],
            behaviours: derive$1([
                Reflecting.config({
                    channel: footerChannel,
                    initialData: initSpec,
                    updateState,
                    renderComponents,
                }),
            ]),
        };
    };
    const renderInlineFooter = function(initSpec, backstage) {
        return renderFooter(initSpec, backstage);
    };
    const renderModalFooter = function(initSpec, backstage) {
        return ModalDialog.parts().footer(renderFooter(initSpec, backstage));
    };

    const getCompByName = function(access, name) {
        const root = access.getRoot();
        if (root.getSystem().isConnected()) {
            const form_1 = Composing.getCurrent(access.getFormWrapper()).getOr(
                access.getFormWrapper(),
            );
            return Form.getField(form_1, name).fold(
                function() {
                    const footer = access.getFooter();
                    const footerState = Reflecting.getState(footer);
                    return footerState.get().bind(function(f) {
                        return f.lookupByName(form_1, name);
                    });
                },
                function(comp) {
                    return Option.some(comp);
                },
            );
        }
        return Option.none();
    };
    const validateData = function(access, data) {
        const root = access.getRoot();
        return Reflecting.getState(root)
            .get()
            .map(function(dialogState) {
                return getOrDie(asRaw('data', dialogState.dataValidator, data));
            })
            .getOr(data);
    };
    const getDialogApi = function(access, doRedial, menuItemStates) {
        const withRoot = function(f) {
            const root = access.getRoot();
            if (root.getSystem().isConnected()) {
                f(root);
            }
        };
        const getData = function() {
            const root = access.getRoot();
            const valueComp = root.getSystem().isConnected()
                ? access.getFormWrapper()
                : root;
            const representedValues = Representing.getValue(valueComp);
            const menuItemCurrentState = map$1(menuItemStates, function(cell) {
                return cell.get();
            });
            return {
                ...representedValues,
                ...menuItemCurrentState,
            };
        };
        const setData = function(newData) {
            withRoot(function(_) {
                const prevData = instanceApi.getData();
                const mergedData = merge(prevData, newData);
                const newInternalData = validateData(access, mergedData);
                const form = access.getFormWrapper();
                Representing.setValue(form, newInternalData);
                each$1(menuItemStates, function(v, k) {
                    if (has(mergedData, k)) {
                        v.set(mergedData[k]);
                    }
                });
            });
        };
        const disable = function(name) {
            getCompByName(access, name).each(Disabling.disable);
        };
        const enable = function(name) {
            getCompByName(access, name).each(Disabling.enable);
        };
        const focus = function(name) {
            getCompByName(access, name).each(Focusing.focus);
        };
        const block = function(message) {
            if (!isString(message)) {
                throw new Error(
                    'The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument',
                );
            }
            withRoot(function(root) {
                emitWith(root, formBlockEvent, { message });
            });
        };
        const unblock = function() {
            withRoot(function(root) {
                emit(root, formUnblockEvent);
            });
        };
        const showTab = function(name) {
            withRoot(function(_) {
                const body = access.getBody();
                const bodyState = Reflecting.getState(body);
                if (
                    bodyState.get().exists(function(b) {
                        return b.isTabPanel();
                    })
                ) {
                    Composing.getCurrent(body).each(function(tabSection) {
                        TabSection.showTab(tabSection, name);
                    });
                }
            });
        };
        const redial = function(d) {
            withRoot(function(root) {
                const dialogInit = doRedial(d);
                root.getSystem().broadcastOn([dialogChannel], dialogInit);
                root.getSystem().broadcastOn(
                    [titleChannel],
                    dialogInit.internalDialog,
                );
                root.getSystem().broadcastOn(
                    [bodyChannel],
                    dialogInit.internalDialog,
                );
                root.getSystem().broadcastOn(
                    [footerChannel],
                    dialogInit.internalDialog,
                );
                instanceApi.setData(dialogInit.initialData);
            });
        };
        const close = function() {
            withRoot(function(root) {
                emit(root, formCloseEvent);
            });
        };
        var instanceApi = {
            getData,
            setData,
            disable,
            enable,
            focus,
            block,
            unblock,
            showTab,
            redial,
            close,
        };
        return instanceApi;
    };

    const isTouch = global$6.deviceType.isTouch();
    const hiddenHeader = function(title, close) {
        return {
            dom: {
                tag: 'div',
                styles: { display: 'none' },
                classes: ['tox-dialog__header'],
            },
            components: [title, close],
        };
    };
    const pClose = function(onClose, providersBackstage) {
        return ModalDialog.parts().close(
            Button.sketch({
                dom: {
                    tag: 'button',
                    classes: [
                        'tox-button',
                        'tox-button--icon',
                        'tox-button--naked',
                    ],
                    attributes: {
                        type: 'button',
                        'aria-label': providersBackstage.translate('Close'),
                    },
                },
                action: onClose,
                buttonBehaviours: derive$1([Tabstopping.config({})]),
            }),
        );
    };
    const pUntitled = function() {
        return ModalDialog.parts().title({
            dom: {
                tag: 'div',
                classes: ['tox-dialog__title'],
                innerHtml: '',
                styles: { display: 'none' },
            },
        });
    };
    const pBodyMessage = function(message, providersBackstage) {
        return ModalDialog.parts().body({
            dom: {
                tag: 'div',
                classes: ['tox-dialog__body'],
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-dialog__body-content'],
                    },
                    components: [
                        {
                            dom: fromHtml$2(
                                `<p>${providersBackstage.translate(
                                    message,
                                )}</p>`,
                            ),
                        },
                    ],
                },
            ],
        });
    };
    const pFooter = function(buttons) {
        return ModalDialog.parts().footer({
            dom: {
                tag: 'div',
                classes: ['tox-dialog__footer'],
            },
            components: buttons,
        });
    };
    const pFooterGroup = function(startButtons, endButtons) {
        return [
            Container.sketch({
                dom: {
                    tag: 'div',
                    classes: ['tox-dialog__footer-start'],
                },
                components: startButtons,
            }),
            Container.sketch({
                dom: {
                    tag: 'div',
                    classes: ['tox-dialog__footer-end'],
                },
                components: endButtons,
            }),
        ];
    };
    const renderDialog = function(spec) {
        let _a;
        const dialogClass = 'tox-dialog';
        const blockerClass = `${dialogClass}-wrap`;
        const blockerBackdropClass = `${blockerClass}__backdrop`;
        const scrollLockClass = `${dialogClass}__disable-scroll`;
        return ModalDialog.sketch({
            lazySink: spec.lazySink,
            onEscape(comp) {
                spec.onEscape(comp);
                return Option.some(true);
            },
            useTabstopAt(elem) {
                return !NavigableObject.isPseudoStop(elem);
            },
            dom: {
                tag: 'div',
                classes: [dialogClass].concat(spec.extraClasses),
                styles: { position: 'relative', ...spec.extraStyles },
            },
            components: __spreadArrays(
                [spec.header, spec.body],
                spec.footer.toArray(),
            ),
            parts: {
                blocker: {
                    dom: fromHtml$2(`<div class="${blockerClass}"></div>`),
                    components: [
                        {
                            dom: {
                                tag: 'div',
                                classes: isTouch
                                    ? [
                                          blockerBackdropClass,
                                          `${blockerBackdropClass}--opaque`,
                                      ]
                                    : [blockerBackdropClass],
                            },
                        },
                    ],
                },
            },
            dragBlockClass: blockerClass,
            modalBehaviours: derive$1(
                __spreadArrays(
                    [
                        Focusing.config({}),
                        config(
                            'dialog-events',
                            spec.dialogEvents.concat([
                                runOnSource(focusin(), function(comp, se) {
                                    Keying.focusIn(comp);
                                }),
                            ]),
                        ),
                        config('scroll-lock', [
                            runOnAttached(function() {
                                add$2(body(), scrollLockClass);
                            }),
                            runOnDetached(function() {
                                remove$4(body(), scrollLockClass);
                            }),
                        ]),
                    ],
                    spec.extraBehaviours,
                ),
            ),
            eventOrder: __assign(
                ((_a = {}),
                (_a[execute()] = ['dialog-events']),
                (_a[attachedToDom()] = [
                    'scroll-lock',
                    'dialog-events',
                    'alloy.base.behaviour',
                ]),
                (_a[detachedFromDom()] = [
                    'alloy.base.behaviour',
                    'dialog-events',
                    'scroll-lock',
                ]),
                _a),
                spec.eventOrder,
            ),
        });
    };

    const renderClose = function(providersBackstage) {
        return Button.sketch({
            dom: {
                tag: 'button',
                classes: [
                    'tox-button',
                    'tox-button--icon',
                    'tox-button--naked',
                ],
                attributes: {
                    type: 'button',
                    'aria-label': providersBackstage.translate('Close'),
                    title: providersBackstage.translate('Close'),
                },
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-icon'],
                        innerHtml:
                            '<svg width="24" height="24" xmlns="http://www.w3.org/2000/svg"><path d="M17.953 7.453L13.422 12l4.531 4.547-1.406 1.406L12 13.422l-4.547 4.531-1.406-1.406L10.578 12 6.047 7.453l1.406-1.406L12 10.578l4.547-4.531z" fill-rule="evenodd"></path></svg>',
                    },
                },
            ],
            action(comp) {
                emit(comp, formCancelEvent);
            },
        });
    };
    const renderTitle = function(spec, id, providersBackstage) {
        const renderComponents = function(data) {
            return [text(providersBackstage.translate(data.title))];
        };
        return {
            dom: {
                tag: 'div',
                classes: ['tox-dialog__title'],
                attributes: {
                    ...id
                        .map(function(x) {
                            return { id: x };
                        })
                        .getOr({}),
                },
            },
            components: renderComponents(spec),
            behaviours: derive$1([
                Reflecting.config({
                    channel: titleChannel,
                    renderComponents,
                }),
            ]),
        };
    };
    const renderDragHandle = function() {
        return {
            dom: fromHtml$2('<div class="tox-dialog__draghandle"></div>'),
        };
    };
    const renderInlineHeader = function(spec, titleId, providersBackstage) {
        return Container.sketch({
            dom: fromHtml$2('<div class="tox-dialog__header"></div>'),
            components: [
                renderTitle(spec, Option.some(titleId), providersBackstage),
                renderDragHandle(),
                renderClose(providersBackstage),
            ],
            containerBehaviours: derive$1([
                Dragging.config({
                    mode: 'mouse',
                    blockerClass: 'blocker',
                    getTarget(handle) {
                        return closest$3(handle, '[role="dialog"]').getOrDie();
                    },
                    snaps: {
                        getSnapPoints() {
                            return [];
                        },
                        leftAttr: 'data-drag-left',
                        topAttr: 'data-drag-top',
                    },
                }),
            ]),
        });
    };
    const renderModalHeader = function(spec, providersBackstage) {
        const pTitle = ModalDialog.parts().title(
            renderTitle(spec, Option.none(), providersBackstage),
        );
        const pHandle = ModalDialog.parts().draghandle(renderDragHandle());
        const pClose = ModalDialog.parts().close(
            renderClose(providersBackstage),
        );
        const components = [pTitle]
            .concat(spec.draggable ? [pHandle] : [])
            .concat([pClose]);
        return Container.sketch({
            dom: fromHtml$2('<div class="tox-dialog__header"></div>'),
            components,
        });
    };

    const getHeader = function(title, backstage) {
        return renderModalHeader(
            {
                title: backstage.shared.providers.translate(title),
                draggable: backstage.dialog.isDraggableModal(),
            },
            backstage.shared.providers,
        );
    };
    const getEventExtras = function(lazyDialog, extra) {
        return {
            onClose() {
                return extra.closeWindow();
            },
            onBlock(blockEvent) {
                ModalDialog.setBusy(lazyDialog(), function(d, bs) {
                    return {
                        dom: {
                            tag: 'div',
                            classes: ['tox-dialog__busy-spinner'],
                            attributes: { 'aria-label': blockEvent.message() },
                            styles: {
                                left: '0px',
                                right: '0px',
                                bottom: '0px',
                                top: '0px',
                                position: 'absolute',
                            },
                        },
                        behaviours: bs,
                        components: [
                            {
                                dom: fromHtml$2(
                                    '<div class="tox-spinner"><div></div><div></div><div></div></div>',
                                ),
                            },
                        ],
                    };
                });
            },
            onUnblock() {
                ModalDialog.setIdle(lazyDialog());
            },
        };
    };
    const renderModalDialog = function(
        spec,
        initialData,
        dialogEvents,
        backstage,
    ) {
        let _a;
        const updateState = function(_comp, incoming) {
            return Option.some(incoming);
        };
        return build$1(
            renderDialog({
                ...spec,
                lazySink: backstage.shared.getSink,
                extraBehaviours: __spreadArrays(
                    [
                        Reflecting.config({
                            channel: dialogChannel,
                            updateState,
                            initialData,
                        }),
                        RepresentingConfigs.memory({}),
                    ],
                    spec.extraBehaviours,
                ),
                onEscape(comp) {
                    emit(comp, formCancelEvent);
                },
                dialogEvents,
                eventOrder:
                    ((_a = {}),
                    (_a[receive()] = ['reflecting', 'receiving']),
                    (_a[attachedToDom()] = [
                        'scroll-lock',
                        'reflecting',
                        'messages',
                        'dialog-events',
                        'alloy.base.behaviour',
                    ]),
                    (_a[detachedFromDom()] = [
                        'alloy.base.behaviour',
                        'dialog-events',
                        'messages',
                        'reflecting',
                        'scroll-lock',
                    ]),
                    _a),
            }),
        );
    };
    const mapMenuButtons = function(buttons) {
        const mapItems = function(button) {
            const items = map(button.items, function(item) {
                const cell = Cell(false);
                return { ...item, storage: cell };
            });
            return { ...button, items };
        };
        return map(buttons, function(button) {
            if (button.type === 'menu') {
                return mapItems(button);
            }
            return button;
        });
    };
    const extractCellsToObject = function(buttons) {
        return foldl(
            buttons,
            function(acc, button) {
                if (button.type === 'menu') {
                    const menuButton = button;
                    return foldl(
                        menuButton.items,
                        function(innerAcc, item) {
                            innerAcc[item.name] = item.storage;
                            return innerAcc;
                        },
                        acc,
                    );
                }
                return acc;
            },
            {},
        );
    };

    const renderDialog$1 = function(dialogInit, extra, backstage) {
        const header = getHeader(dialogInit.internalDialog.title, backstage);
        const body = renderModalBody(
            { body: dialogInit.internalDialog.body },
            backstage,
        );
        const storagedMenuButtons = mapMenuButtons(
            dialogInit.internalDialog.buttons,
        );
        const objOfCells = extractCellsToObject(storagedMenuButtons);
        const footer = renderModalFooter(
            { buttons: storagedMenuButtons },
            backstage,
        );
        const dialogEvents = SilverDialogEvents.initDialog(
            function() {
                return instanceApi;
            },
            getEventExtras(function() {
                return dialog;
            }, extra),
        );
        const dialogSize =
            dialogInit.internalDialog.size !== 'normal'
                ? dialogInit.internalDialog.size === 'large'
                    ? ['tox-dialog--width-lg']
                    : ['tox-dialog--width-md']
                : [];
        const spec = {
            header,
            body,
            footer: Option.some(footer),
            extraClasses: dialogSize,
            extraBehaviours: [],
            extraStyles: {},
        };
        var dialog = renderModalDialog(
            spec,
            dialogInit,
            dialogEvents,
            backstage,
        );
        const modalAccess = (function() {
            const getForm = function() {
                const outerForm = ModalDialog.getBody(dialog);
                return Composing.getCurrent(outerForm).getOr(outerForm);
            };
            return {
                getRoot() {
                    return dialog;
                },
                getBody() {
                    return ModalDialog.getBody(dialog);
                },
                getFooter() {
                    return ModalDialog.getFooter(dialog);
                },
                getFormWrapper: getForm,
            };
        })();
        var instanceApi = getDialogApi(modalAccess, extra.redial, objOfCells);
        return {
            dialog,
            instanceApi,
        };
    };

    const renderInlineDialog = function(
        dialogInit,
        extra,
        backstage,
        ariaAttrs,
    ) {
        let _a;
        let _b;
        const dialogLabelId = generate$1('dialog-label');
        const dialogContentId = generate$1('dialog-content');
        const updateState = function(_comp, incoming) {
            return Option.some(incoming);
        };
        const memHeader = record(
            renderInlineHeader(
                {
                    title: dialogInit.internalDialog.title,
                    draggable: true,
                },
                dialogLabelId,
                backstage.shared.providers,
            ),
        );
        const memBody = record(
            renderInlineBody(
                { body: dialogInit.internalDialog.body },
                dialogContentId,
                backstage,
                ariaAttrs,
            ),
        );
        const storagedMenuButtons = mapMenuButtons(
            dialogInit.internalDialog.buttons,
        );
        const objOfCells = extractCellsToObject(storagedMenuButtons);
        const memFooter = record(
            renderInlineFooter({ buttons: storagedMenuButtons }, backstage),
        );
        const dialogEvents = SilverDialogEvents.initDialog(
            function() {
                return instanceApi;
            },
            {
                onBlock() {},
                onUnblock() {},
                onClose() {
                    return extra.closeWindow();
                },
            },
        );
        const dialog = build$1({
            dom: {
                tag: 'div',
                classes: ['tox-dialog', 'tox-dialog-inline'],
                attributes:
                    ((_a = { role: 'dialog' }),
                    (_a['aria-labelledby'] = dialogLabelId),
                    (_a['aria-describedby'] = `${dialogContentId}`),
                    _a),
            },
            eventOrder:
                ((_b = {}),
                (_b[receive()] = [Reflecting.name(), Receiving.name()]),
                (_b[execute()] = ['execute-on-form']),
                (_b[attachedToDom()] = ['reflecting', 'execute-on-form']),
                _b),
            behaviours: derive$1([
                Keying.config({
                    mode: 'cyclic',
                    onEscape(c) {
                        emit(c, formCloseEvent);
                        return Option.some(true);
                    },
                    useTabstopAt(elem) {
                        return (
                            !NavigableObject.isPseudoStop(elem) &&
                            (name(elem) !== 'button' ||
                                get$2(elem, 'disabled') !== 'disabled')
                        );
                    },
                }),
                Reflecting.config({
                    channel: dialogChannel,
                    updateState,
                    initialData: dialogInit,
                }),
                Focusing.config({}),
                config(
                    'execute-on-form',
                    dialogEvents.concat([
                        runOnSource(focusin(), function(comp, se) {
                            Keying.focusIn(comp);
                        }),
                    ]),
                ),
                RepresentingConfigs.memory({}),
            ]),
            components: [
                memHeader.asSpec(),
                memBody.asSpec(),
                memFooter.asSpec(),
            ],
        });
        var instanceApi = getDialogApi(
            {
                getRoot() {
                    return dialog;
                },
                getFooter() {
                    return memFooter.get(dialog);
                },
                getBody() {
                    return memBody.get(dialog);
                },
                getFormWrapper() {
                    const body = memBody.get(dialog);
                    return Composing.getCurrent(body).getOr(body);
                },
            },
            extra.redial,
            objOfCells,
        );
        return {
            dialog,
            instanceApi,
        };
    };

    const global$g = tinymce.util.Tools.resolve('tinymce.util.URI');

    const getUrlDialogApi = function(root) {
        const withRoot = function(f) {
            if (root.getSystem().isConnected()) {
                f(root);
            }
        };
        const block = function(message) {
            if (!isString(message)) {
                throw new Error(
                    'The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument',
                );
            }
            withRoot(function(root) {
                emitWith(root, formBlockEvent, { message });
            });
        };
        const unblock = function() {
            withRoot(function(root) {
                emit(root, formUnblockEvent);
            });
        };
        const close = function() {
            withRoot(function(root) {
                emit(root, formCloseEvent);
            });
        };
        const sendMessage = function(data) {
            withRoot(function(root) {
                root.getSystem().broadcastOn([bodySendMessageChannel], data);
            });
        };
        return {
            block,
            unblock,
            close,
            sendMessage,
        };
    };

    const SUPPORTED_MESSAGE_ACTIONS = [
        'insertContent',
        'setContent',
        'execCommand',
        'close',
        'block',
        'unblock',
    ];
    const isSupportedMessage = function(data) {
        return (
            isObject(data) &&
            SUPPORTED_MESSAGE_ACTIONS.indexOf(data.mceAction) !== -1
        );
    };
    const isCustomMessage = function(data) {
        return (
            !isSupportedMessage(data) &&
            isObject(data) &&
            has(data, 'mceAction')
        );
    };
    const handleMessage = function(editor, api, data) {
        switch (data.mceAction) {
            case 'insertContent':
                editor.insertContent(data.content);
                break;
            case 'setContent':
                editor.setContent(data.content);
                break;
            case 'execCommand':
                var ui = isBoolean(data.ui) ? data.ui : false;
                editor.execCommand(data.cmd, ui, data.value);
                break;
            case 'close':
                api.close();
                break;
            case 'block':
                api.block(data.message);
                break;
            case 'unblock':
                api.unblock();
                break;
        }
    };
    const renderUrlDialog = function(internalDialog, extra, editor, backstage) {
        let _a;
        const header = getHeader(internalDialog.title, backstage);
        const body = renderIframeBody(internalDialog);
        const footer = internalDialog.buttons.bind(function(buttons) {
            if (buttons.length === 0) {
                return Option.none();
            }
            return Option.some(renderModalFooter({ buttons }, backstage));
        });
        const dialogEvents = SilverDialogEvents.initUrlDialog(
            function() {
                return instanceApi;
            },
            getEventExtras(function() {
                return dialog;
            }, extra),
        );
        const styles = {
            ...internalDialog.height.fold(
                function() {
                    return {};
                },
                function(height) {
                    return {
                        height: `${height}px`,
                        'max-height': `${height}px`,
                    };
                },
            ),
            ...internalDialog.width.fold(
                function() {
                    return {};
                },
                function(width) {
                    return {
                        width: `${width}px`,
                        'max-width': `${width}px`,
                    };
                },
            ),
        };
        const classes =
            internalDialog.width.isNone() && internalDialog.height.isNone()
                ? ['tox-dialog--width-lg']
                : [];
        const iframeUri = new global$g(internalDialog.url, {
            base_uri: new global$g(domGlobals.window.location.href),
        });
        const iframeDomain = `${iframeUri.protocol}://${iframeUri.host}${
            iframeUri.port ? `:${iframeUri.port}` : ''
        }`;
        const messageHandlerUnbinder = Cell(Option.none());
        const extraBehaviours = [
            config('messages', [
                runOnAttached(function() {
                    const unbind = bind$3(
                        Element.fromDom(domGlobals.window),
                        'message',
                        function(e) {
                            if (
                                iframeUri.isSameOrigin(
                                    new global$g(e.raw().origin),
                                )
                            ) {
                                const { data } = e.raw();
                                if (isSupportedMessage(data)) {
                                    handleMessage(editor, instanceApi, data);
                                } else if (isCustomMessage(data)) {
                                    internalDialog.onMessage(instanceApi, data);
                                }
                            }
                        },
                    );
                    messageHandlerUnbinder.set(Option.some(unbind));
                }),
                runOnDetached(function() {
                    messageHandlerUnbinder.get().each(function(unbinder) {
                        return unbinder.unbind();
                    });
                }),
            ]),
            Receiving.config({
                channels:
                    ((_a = {}),
                    (_a[bodySendMessageChannel] = {
                        onReceive(comp, data) {
                            descendant$1(comp.element(), 'iframe').each(
                                function(iframeEle) {
                                    const iframeWin = iframeEle.dom()
                                        .contentWindow;
                                    iframeWin.postMessage(data, iframeDomain);
                                },
                            );
                        },
                    }),
                    _a),
            }),
        ];
        const spec = {
            header,
            body,
            footer,
            extraClasses: classes,
            extraBehaviours,
            extraStyles: styles,
        };
        var dialog = renderModalDialog(
            spec,
            internalDialog,
            dialogEvents,
            backstage,
        );
        var instanceApi = getUrlDialogApi(dialog);
        return {
            dialog,
            instanceApi,
        };
    };

    const setup$d = function(extras) {
        const sharedBackstage = extras.backstage.shared;
        const open = function(message, callback) {
            const closeDialog = function() {
                ModalDialog.hide(alertDialog);
                callback();
            };
            const memFooterClose = record(
                renderFooterButton(
                    {
                        name: 'close-alert',
                        text: 'OK',
                        primary: true,
                        align: 'end',
                        disabled: false,
                        icon: Option.none(),
                    },
                    'cancel',
                    extras.backstage,
                ),
            );
            const titleSpec = pUntitled();
            const closeSpec = pClose(closeDialog, sharedBackstage.providers);
            var alertDialog = build$1(
                renderDialog({
                    lazySink() {
                        return sharedBackstage.getSink();
                    },
                    header: hiddenHeader(titleSpec, closeSpec),
                    body: pBodyMessage(message, sharedBackstage.providers),
                    footer: Option.some(
                        pFooter(pFooterGroup([], [memFooterClose.asSpec()])),
                    ),
                    onEscape: closeDialog,
                    extraClasses: ['tox-alert-dialog'],
                    extraBehaviours: [],
                    extraStyles: {},
                    dialogEvents: [run(formCancelEvent, closeDialog)],
                    eventOrder: {},
                }),
            );
            ModalDialog.show(alertDialog);
            const footerCloseButton = memFooterClose.get(alertDialog);
            Focusing.focus(footerCloseButton);
        };
        return { open };
    };

    const setup$e = function(extras) {
        const sharedBackstage = extras.backstage.shared;
        const open = function(message, callback) {
            const closeDialog = function(state) {
                ModalDialog.hide(confirmDialog);
                callback(state);
            };
            const memFooterYes = record(
                renderFooterButton(
                    {
                        name: 'yes',
                        text: 'Yes',
                        primary: true,
                        align: 'end',
                        disabled: false,
                        icon: Option.none(),
                    },
                    'submit',
                    extras.backstage,
                ),
            );
            const footerNo = renderFooterButton(
                {
                    name: 'no',
                    text: 'No',
                    primary: true,
                    align: 'end',
                    disabled: false,
                    icon: Option.none(),
                },
                'cancel',
                extras.backstage,
            );
            const titleSpec = pUntitled();
            const closeSpec = pClose(function() {
                return closeDialog(false);
            }, sharedBackstage.providers);
            var confirmDialog = build$1(
                renderDialog({
                    lazySink() {
                        return sharedBackstage.getSink();
                    },
                    header: hiddenHeader(titleSpec, closeSpec),
                    body: pBodyMessage(message, sharedBackstage.providers),
                    footer: Option.some(
                        pFooter(
                            pFooterGroup([], [footerNo, memFooterYes.asSpec()]),
                        ),
                    ),
                    onEscape() {
                        return closeDialog(false);
                    },
                    extraClasses: ['tox-confirm-dialog'],
                    extraBehaviours: [],
                    extraStyles: {},
                    dialogEvents: [
                        run(formCancelEvent, function() {
                            return closeDialog(false);
                        }),
                        run(formSubmitEvent, function() {
                            return closeDialog(true);
                        }),
                    ],
                    eventOrder: {},
                }),
            );
            ModalDialog.show(confirmDialog);
            const footerYesButton = memFooterYes.get(confirmDialog);
            Focusing.focus(footerYesButton);
        };
        return { open };
    };

    const validateData$1 = function(data, validator) {
        return getOrDie(asRaw('data', validator, data));
    };
    const inlineAdditionalBehaviours = function(editor, isStickyToolbar) {
        if (isStickyToolbar) {
            return [];
        }
        return [
            Docking.config({
                contextual: {
                    lazyContext() {
                        return Option.some(
                            box(
                                Element.fromDom(
                                    editor.getContentAreaContainer(),
                                ),
                            ),
                        );
                    },
                    fadeInClass: 'tox-dialog-dock-fadein',
                    fadeOutClass: 'tox-dialog-dock-fadeout',
                    transitionClass: 'tox-dialog-dock-transition',
                },
                leftAttr: 'data-dock-left',
                topAttr: 'data-dock-top',
                positionAttr: 'data-dock-pos',
                modes: ['top'],
            }),
        ];
    };
    const setup$f = function(extras) {
        const { backstage } = extras;
        const { editor } = extras;
        const isStickyToolbar$1 = isStickyToolbar(editor);
        const alertDialog = setup$d(extras);
        const confirmDialog = setup$e(extras);
        const open = function(config, params, closeWindow) {
            if (params !== undefined && params.inline === 'toolbar') {
                return openInlineDialog(
                    config,
                    backstage.shared.anchors.toolbar(),
                    closeWindow,
                    params.ariaAttrs,
                );
            }
            if (params !== undefined && params.inline === 'cursor') {
                return openInlineDialog(
                    config,
                    backstage.shared.anchors.cursor(),
                    closeWindow,
                    params.ariaAttrs,
                );
            }
            return openModalDialog(config, closeWindow);
        };
        const openUrl = function(config, closeWindow) {
            return openModalUrlDialog(config, closeWindow);
        };
        var openModalUrlDialog = function(config, closeWindow) {
            const factory = function(contents) {
                var dialog = renderUrlDialog(
                    contents,
                    {
                        closeWindow() {
                            ModalDialog.hide(dialog.dialog);
                            closeWindow(dialog.instanceApi);
                        },
                    },
                    editor,
                    backstage,
                );
                ModalDialog.show(dialog.dialog);
                return dialog.instanceApi;
            };
            return DialogManager.openUrl(factory, config);
        };
        var openModalDialog = function(config, closeWindow) {
            const factory = function(
                contents,
                internalInitialData,
                dataValidator,
            ) {
                const initialData = internalInitialData;
                const dialogInit = {
                    dataValidator,
                    initialData,
                    internalDialog: contents,
                };
                var dialog = renderDialog$1(
                    dialogInit,
                    {
                        redial: DialogManager.redial,
                        closeWindow() {
                            ModalDialog.hide(dialog.dialog);
                            closeWindow(dialog.instanceApi);
                        },
                    },
                    backstage,
                );
                ModalDialog.show(dialog.dialog);
                dialog.instanceApi.setData(initialData);
                return dialog.instanceApi;
            };
            return DialogManager.open(factory, config);
        };
        var openInlineDialog = function(
            config$1,
            anchor,
            closeWindow,
            ariaAttrs,
        ) {
            const factory = function(
                contents,
                internalInitialData,
                dataValidator,
            ) {
                const initialData = validateData$1(
                    internalInitialData,
                    dataValidator,
                );
                const inlineDialog = value$3();
                const dialogInit = {
                    dataValidator,
                    initialData,
                    internalDialog: contents,
                };
                const refreshDocking = function() {
                    return inlineDialog.on(function(dialog) {
                        Docking.refresh(dialog);
                    });
                };
                var dialogUi = renderInlineDialog(
                    dialogInit,
                    {
                        redial: DialogManager.redial,
                        closeWindow() {
                            inlineDialog.on(InlineView.hide);
                            editor.off('ResizeEditor', refreshDocking);
                            inlineDialog.clear();
                            closeWindow(dialogUi.instanceApi);
                        },
                    },
                    backstage,
                    ariaAttrs,
                );
                const inlineDialogComp = build$1(
                    InlineView.sketch({
                        lazySink: backstage.shared.getSink,
                        dom: {
                            tag: 'div',
                            classes: [],
                        },
                        fireDismissalEventInstead: {},
                        inlineBehaviours: derive$1(
                            __spreadArrays(
                                [
                                    config('window-manager-inline-events', [
                                        run(dismissRequested(), function(
                                            comp,
                                            se,
                                        ) {
                                            emit(
                                                dialogUi.dialog,
                                                formCancelEvent,
                                            );
                                        }),
                                    ]),
                                ],
                                inlineAdditionalBehaviours(
                                    editor,
                                    isStickyToolbar$1,
                                ),
                            ),
                        ),
                    }),
                );
                inlineDialog.set(inlineDialogComp);
                InlineView.showWithin(
                    inlineDialogComp,
                    anchor,
                    premade$1(dialogUi.dialog),
                    Option.some(body()),
                );
                if (!isStickyToolbar$1) {
                    Docking.refresh(inlineDialogComp);
                    editor.on('ResizeEditor', refreshDocking);
                }
                dialogUi.instanceApi.setData(initialData);
                Keying.focusIn(dialogUi.dialog);
                return dialogUi.instanceApi;
            };
            return DialogManager.open(factory, config$1);
        };
        const confirm = function(message, callback) {
            confirmDialog.open(message, function(state) {
                callback(state);
            });
        };
        const alert = function(message, callback) {
            alertDialog.open(message, function() {
                callback();
            });
        };
        const close = function(instanceApi) {
            instanceApi.close();
        };
        return {
            open,
            openUrl,
            alert,
            close,
            confirm,
        };
    };
    const WindowManager = { setup: setup$f };

    function Theme() {
        global$1.add('silver', function(editor) {
            const _a = Render.setup(editor);
            const { uiMothership } = _a;
            const { backstage } = _a;
            const { renderUI } = _a;
            const { getUi } = _a;
            Autocompleter.register(editor, backstage.shared);
            const windowMgr = WindowManager.setup({
                editor,
                backstage,
            });
            return {
                renderUI,
                getWindowManagerImpl: constant(windowMgr),
                getNotificationManagerImpl() {
                    return NotificationManagerImpl(
                        editor,
                        { backstage },
                        uiMothership,
                    );
                },
                ui: getUi(),
            };
        });
    }

    Theme();
})(window);
